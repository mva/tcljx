(ns tcljx.alpha.ptest__pp-test
  (:require [tcljx.alpha.textflow :as tf]
            [tcljx.alpha.ptest__pp :as pp]
            [tcljx.alpha.ptest :refer :all]))

;;; Emit `forms` as a single long line.  Not pretty, but very simple.
(defn pretty0-forms ^String [forms]
  (-> (StringBuilder.)
      (tf/print-into (pp/pretty0-fragment forms))
      (.toString)))
(defn pretty0-form ^String [form]
  (pretty0-forms (list form)))

(defmacro is-pr0* [exp forms]
  (with-meta `(is (= ~exp (pretty0-forms ~forms)))
    (meta &form)))                      ;provide correct :line to `is`

(deftest pretty0-root-test
  (is-pr0* "" ())
  (is-pr0* "" [])
  
  (is-pr0* "1" '(1))
  (is-pr0* "1 2" '(1 2)))


(defmacro is-pr0 [exp form]
  (with-meta `(is (= ~exp (pretty0-form (object ~form))))
    (meta &form)))                      ;provide correct :line to `is`

(deftest pretty0-form-test
  ;; atomic text
  (is-pr0 "nil" nil)
  (is-pr0 "true" true)
  (is-pr0 "false" false)
  (is-pr0 "sym" 'sym)
  (is-pr0 ":kw" :kw)
  (is-pr0 "123" 123)
  (is-pr0 "\\space" \space)
  (is-pr0 "\\newline" \newline)
  (is-pr0 "\\A" \A)
  (is-pr0 "\\u0000" \u0000)
  (is-pr0 "\\u007f" \u007f)

  ;; numbers
  (is-pr0 "1.0" 1.0)
  (is-pr0 "1.0f" 1.0f)
  (is-pr0 "123l" 123l)
  (is-pr0 "##Inf" Double/POSITIVE_INFINITY)
  (is-pr0 "##-Inf" Double/NEGATIVE_INFINITY)
  (is-pr0 "##NaN" Double/NaN)
  
  ;; strings (incl escapes for \" and \\)
  (is-pr0 "\"\"" "")
  (is-pr0 "\"foo\"" "foo")
  (is-pr0 "\"\\\\\"" "\\")
  (is-pr0 "\"\\\"\"" "\"")
  
  ;; patterns
  (is-pr0 "#\".\"" #".")
  (is-pr0 "#\"\\\\\"" #"\\")
  (is-pr0 "#\"\\\"\"" #"\"")
  (is-pr0 "#\"\\Q*\\E\"" #"\Q*\E")
  (is-pr0 "#\"\\Q\\\"\\E\"" #"\Q\"\E")
  
  ;; collection: list
  (is-pr0 "()" ())
  (is-pr0 "(1)" '(1))
  (is-pr0 "(1 2)" '(1 2))
  
  ;; collection: vector
  (is-pr0 "[]" [])
  (is-pr0 "[1]" [1])
  (is-pr0 "[1 2]" [1 2])

  ;; collection: map
  (is-pr0 "{}" {})
  (is-pr0 "{:a 123}" {:a 123})
  ;; order of entries not deterministic for two or more
  
  ;; collection: set
  (is-pr0 "#{}" #{})
  (is-pr0 "#{:a}" #{:a})
  ;; order of elements not deterministic for two or more
  )

(deftest pretty0-map-entry-test
  (let [m (array-map :a 123 :b 345)]
    (is-pr0 "{:a 123, :b 345}" m)
    (is-pr0 "([:a 123] [:b 345])" (seq m))))

(deftest pretty0-meta-test
  (is (= "^{} ()"
         (pretty0-form ^{} ())))
  (is (= "^{\"abc\" true} ()"
         (pretty0-form ^{"abc" true} ())))
  (is (= "^{\"abc\" true} ()"
         (pretty0-form '^{"abc" true} ())))
  
  (is (= "^{} []"
         (pretty0-form ^{} [])))
  (is (= "^{\"abc\" true} []"
         (pretty0-form ^{"abc" true} [])))

  ;; shorthand notation
  (is (= "^:foo sym"
         (pretty0-form '^:foo sym)))
  (is (= "^String sym"
         (pretty0-form '^String sym))))

(defn pretty1-forms ^String [^int page-width forms]
  (-> (StringBuilder.)
      (tf/print-into (pp/pretty1-fragment forms page-width))
      (.toString)))
(defmacro is-pr1 [exp page-width forms]
  (with-meta `(is (= ~exp (pretty1-forms ~page-width ~forms)))
    (meta &form)))                      ;provide correct :line to `is`
(defmacro tl-forms [& forms]
  `(quote ~forms))

(deftest pretty1-abc-test
  (let [abc (tl-forms A [B C])] ;modified doc1 example from yield-pp.pdf
    (is-pr1 "A [B C]" 8 abc)
    (is-pr1 "A [B C]" 7 abc)
    (is-pr1 "A\n[B C]" 6 abc)
    (is-pr1 "A\n[B C]" 5 abc)
    (is-pr1 "A\n[B\n C]" 4 abc)
    (is-pr1 "A\n[B\n C]" 3 abc)
    (is-pr1 "A\n[B\n C]" 2 abc)
    (is-pr1 "A\n[B\n C]" 1 abc)))

(deftest pretty1-inner-last-test
  (let [nested-abc (tl-forms (a (b c)))]
    (is-pr1 "(a (b c))" 9 nested-abc)
    (is-pr1 "(a\n (b c))" 8 nested-abc)
    (is-pr1 "(a\n (b c))" 7 nested-abc)
    (is-pr1 "(a\n (b\n  c))" 6 nested-abc))

  (let [nested-abcd (tl-forms (a (b c) d))]
    (is-pr1 "(a (b c) d)" 11 nested-abcd)
    (is-pr1 "(a\n (b c)\n d)" 10 nested-abcd)
    (is-pr1 "(a\n (b c)\n d)" 6 nested-abcd)
    (is-pr1 "(a\n (b\n  c)\n d)" 5 nested-abcd)))

(def flat-vector (tl-forms [1 2 3]))
(def nested-vector (tl-forms [[1 2 3]]))
(deftest pretty1-align-test
  (is-pr1 "[1 2 3]" 7 flat-vector)
  (is-pr1 "[1\n 2\n 3]" 6 flat-vector)

  (is-pr1 "[[1 2 3]]" 10 nested-vector)
  (is-pr1 "[[1 2 3]]" 9 nested-vector)

  ;; Nested would vector fit, outer would not.  By reserving space for
  ;; the "]" after the "3]", the layout decision of the inner vector
  ;; is forced to "needs line breaks"
  (is-pr1 "[[1\n  2\n  3]]" 8 nested-vector)
  
  (is-pr1 "[[1\n  2\n  3]]" 7 nested-vector))

(def nested-data
  (tl-forms ({:args [["VkInstance = 0x7f1bd84f53d0" 0]
                     ["const VkAllocationCallbacks* = NULL" 0]]}
             {:fct "vkDestroyDebugUtilsMessengerEXT"})))

(deftest nested-data-test
  (is-pr1 "({:args [[\"VkInstance = 0x7f1bd84f53d0\" 0]\n         [\"const VkAllocationCallbacks* = NULL\" 0]]}\n {:fct \"vkDestroyDebugUtilsMessengerEXT\"})"
          80 nested-data))
