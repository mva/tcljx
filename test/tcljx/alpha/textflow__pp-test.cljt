(ns tcljx.alpha.textflow__pp-test
  (:require [tcljx.alpha.textflow :as tf]
            [tcljx.alpha.textflow__insn :as tfi]
            [tcljx.alpha.textflow__pp :as pp]
            [tcljx.alpha.ptest :refer :all]
            [tinyclj.string :as str]))

;;; Emit `forms` as a single long line.  Not pretty, but very simple.
(defn pretty0-forms ^String [forms]
  (-> (StringBuilder.)
      (tf/print-into (-> (tf/mk-buffered) (pp/pretty0 forms)))
      (.toString)))
(defn pretty0-form ^String [form]
  (pretty0-forms (list form)))

(defmacro is-pr0* [exp forms]
  (with-meta `(is (= ~exp (pretty0-forms ~forms)))
    (meta &form)))                      ;provide correct :line to `is`

(deftest pretty0-root-test
  (is-pr0* "" ())
  (is-pr0* "" [])
  
  (is-pr0* "1" '(1))
  (is-pr0* "1 2" '(1 2)))


(defmacro is-pr0 [exp form]
  (with-meta `(is (= ~exp (pretty0-form (object ~form))))
    (meta &form)))                      ;provide correct :line to `is`

(deftest pretty0-form-test
  ;; atomic text
  (is-pr0 "nil" nil)
  (is-pr0 "true" true)
  (is-pr0 "false" false)
  (is-pr0 "sym" 'sym)
  (is-pr0 ":kw" :kw)
  (is-pr0 "123" 123)
  (is-pr0 "\\space" \space)
  (is-pr0 "\\newline" \newline)
  (is-pr0 "\\A" \A)
  (is-pr0 "\\u0000" \u0000)
  (is-pr0 "\\u007f" \u007f)

  ;; numbers
  (is-pr0 "1.0" 1.0)
  (is-pr0 "1.0f" 1.0f)
  (is-pr0 "123l" 123l)
  (is-pr0 "##Inf" Double/POSITIVE_INFINITY)
  (is-pr0 "##-Inf" Double/NEGATIVE_INFINITY)
  (is-pr0 "##NaN" Double/NaN)
  
  ;; strings (incl escapes for \" and \\)
  (is-pr0 "\"\"" "")
  (is-pr0 "\"foo\"" "foo")
  (is-pr0 "\"\\\\\"" "\\")
  (is-pr0 "\"\\\"\"" "\"")
  
  ;; patterns
  (is-pr0 "#\".\"" #".")
  (is-pr0 "#\"\\\\\"" #"\\")
  (is-pr0 "#\"\\\"\"" #"\"")
  (is-pr0 "#\"\\Q*\\E\"" #"\Q*\E")
  (is-pr0 "#\"\\Q\\\"\\E\"" #"\Q\"\E")
  
  ;; collection: list
  (is-pr0 "()" ())
  (is-pr0 "(1)" '(1))
  (is-pr0 "(1 2)" '(1 2))
  
  ;; collection: vector
  (is-pr0 "[]" [])
  (is-pr0 "[1]" [1])
  (is-pr0 "[1 2]" [1 2])

  ;; collection: map
  (is-pr0 "{}" {})
  (is-pr0 "{:a 123}" {:a 123})
  ;; order of entries not deterministic for two or more
  
  ;; collection: set
  (is-pr0 "#{}" #{})
  (is-pr0 "#{:a}" #{:a})
  ;; order of elements not deterministic for two or more
  )

(deftest pretty0-map-entry-test
  (let [m (array-map :a 123 :b 345)]
    (is-pr0 "{:a 123, :b 345}" m)
    (is-pr0 "([:a 123] [:b 345])" (seq m))))

(deftest pretty0-meta-test
  (is (= "^{} ()"
         (pretty0-form ^{} ())))
  (is (= "^{\"abc\" true} ()"
         (pretty0-form ^{"abc" true} ())))
  (is (= "^{\"abc\" true} ()"
         (pretty0-form '^{"abc" true} ())))
  
  (is (= "^{} []"
         (pretty0-form ^{} [])))
  (is (= "^{\"abc\" true} []"
         (pretty0-form ^{"abc" true} [])))

  ;; shorthand notation
  (is (= "^:foo sym"
         (pretty0-form '^:foo sym)))
  (is (= "^String sym"
         (pretty0-form '^String sym))))

(defn pretty1-forms ^String [^int page-width forms]
  (-> (StringBuilder.)
      (tf/print-into (-> (tf/mk-buffered)
                         (pp/pretty1 forms page-width)))
      (.toString)))
(defmacro is-pr1 [exp page-width forms]
  (with-meta `(is (= ~exp (pretty1-forms ~page-width ~forms)))
    (meta &form)))                      ;provide correct :line to `is`
(defmacro tl-forms [& forms]
  `(quote ~forms))

(deftest pretty1-abc-test
  (let [abc (tl-forms A [B C])] ;modified doc1 example from yield-pp.pdf
    (is-pr1 "A [B C]" 8 abc)
    (is-pr1 "A [B C]" 7 abc)
    (is-pr1 "A\n[B C]" 6 abc)
    (is-pr1 "A\n[B C]" 5 abc)
    (is-pr1 "A\n[B\n C]" 4 abc)
    (is-pr1 "A\n[B\n C]" 3 abc)
    (is-pr1 "A\n[B\n C]" 2 abc)
    (is-pr1 "A\n[B\n C]" 1 abc)))

(deftest pretty1-inner-last-test
  (let [nested-abc (tl-forms (a (b c)))]
    (is-pr1 "(a (b c))" 9 nested-abc)
    (is-pr1 "(a\n (b c))" 8 nested-abc)
    (is-pr1 "(a\n (b c))" 7 nested-abc)
    (is-pr1 "(a\n (b\n  c))" 6 nested-abc))

  (let [nested-abcd (tl-forms (a (b c) d))]
    (is-pr1 "(a (b c) d)" 11 nested-abcd)
    (is-pr1 "(a\n (b c)\n d)" 10 nested-abcd)
    (is-pr1 "(a\n (b c)\n d)" 6 nested-abcd)
    (is-pr1 "(a\n (b\n  c)\n d)" 5 nested-abcd)))

(def flat-vector (tl-forms [1 2 3]))
(def nested-vector (tl-forms [[1 2 3]]))
(deftest pretty1-align-test
  (is-pr1 "[1 2 3]" 7 flat-vector)
  (is-pr1 "[1\n 2\n 3]" 6 flat-vector)

  (is-pr1 "[[1 2 3]]" 10 nested-vector)
  (is-pr1 "[[1 2 3]]" 9 nested-vector)

  ;; Nested would vector fit, outer would not.  By reserving space for
  ;; the "]" after the "3]", the layout decision of the inner vector
  ;; is forced to "needs line breaks"
  (is-pr1 "[[1\n  2\n  3]]" 8 nested-vector)
  
  (is-pr1 "[[1\n  2\n  3]]" 7 nested-vector))

(def nested-data
  (tl-forms ({:args [["VkInstance = 0x7f1bd84f53d0" 0]
                     ["const VkAllocationCallbacks* = NULL" 0]]}
             {:fct "vkDestroyDebugUtilsMessengerEXT"})))

(deftest nested-data-test
  (is-pr1 "({:args\n  [[\"VkInstance = 0x7f1bd84f53d0\" 0] [\"const VkAllocationCallbacks* = NULL\" 0]]}\n {:fct \"vkDestroyDebugUtilsMessengerEXT\"})"
          80 nested-data))

;;; ------------------------------------------------------------------------

(defn alts [& forms]
  (pp/alternates nil forms))

(letfn [(frag-linev ^vector [^Object/1 frag]
          (vec (-> (StringBuilder.)
                   (tf/print-into* frag "\n" tfi/style-default)
                   (.toString)
                   (str/split #"\n"))))
        (side-by-side ^vector [^seq linev-seq]
          (let [n (count (first linev-seq))]
            (doseq [linev linev-seq]
              (assert (= (count linev) n)))
            (apply mapv vector linev-seq)))]
  (defn view-forms ^vector [^int page-width ^int view-count forms]
    (assert (pos? view-count))
    (let [multi-frag (-> (tf/mk-buffered)
                         (pp/pretty1 forms page-width)
                         (tf/fragment))
          views (map #(-> (tf/mk-buffered)
                          (pp/isolate-view-into multi-frag ^int %)
                          (tf/fragment)
                          (frag-linev))
                     (range view-count))]
      (side-by-side views))))

(defmacro is-alts [exp page-width view forms]
  (with-meta `(is (= ~exp (view-forms ~page-width ~view ~forms)))
    (meta &form)))                      ;provide correct :line to `is`

(deftest empty-alternates-test
  ;; the empty alternates show up as an empty form surrounded by
  ;; spaces
  (is-alts [["a  b"]] 16 1 (list 'a (alts) 'b))

  ;; selecting a non-existing view looks like an empty view
  (is-alts [["a A b" "a  b"]] 16 2 (list 'a (alts 'A) 'b)))

(deftest basic-alternates-test
  (is-alts [["a A b" "a B b" "a  b"]] 16 3 (list 'a (alts 'A 'B) 'b)))

(deftest different-width-alternates-test
  (is-alts [["foobar" "123   "]]
           16 2 (list (alts 'foobar 123)))
  (is-alts [["123   " "foobar"]]
           16 2 (list (alts 123 'foobar)))
  
  (is-alts [["[foobar]" "[123   ]"]]
           16 2 (list (vector (alts 'foobar 123))))
  (is-alts [["[123   ]" "[foobar]"]]
           16 2 (list (vector (alts 123 'foobar))))
  
  (is-alts [["foobar" "      "]]
           16 2 (list (alts 'foobar pp/empty-form)))
  (is-alts [["      " "foobar"]]
           16 2 (list (alts pp/empty-form 'foobar)))
  
  (is-alts [["[foobar]" "[      ]"]]
           16 2 (list (vector (alts 'foobar pp/empty-form))))
  (is-alts [["[      ]" "[foobar]"]]
           16 2 (list (vector (alts pp/empty-form 'foobar)))))
