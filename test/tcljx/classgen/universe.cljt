(ns tcljx.classgen.universe
  (:require
   (tcljx.data
    [config :as cfg] [files :as files] [resolve :as resolve] [meta :as meta]
    [wrong :as wrong] [context :as context] [model :as model])
   (tcljx.parser
    [form :as form] [parse :as parse] [namespace :as namespace])
   (tcljx.classgen
    [classfile :as classfile] [runtime :as rt] [envgraph :as envgraph]
    [entity :as entity] [emit :as emit] [insn :as insn] [build :as build]
    [codegen :as codegen] [defgen :as defgen] [primitive :as primitive]))
  (:import
   (tcljx.data.model Resolver NamespaceProvider ProvidedNamespace
                     NamespaceBuilder Expr ExprFactory Parser)
   (tcljx.classgen.classfile Loader PackageBuilder)
   (tcljx.classgen.envgraph EnvSegment EnvMethod)
   (tcljx.classgen.insn Insn)
   (java.lang.classfile ClassFile ClassBuilder CodeBuilder)
   (java.lang.invoke MethodType MethodHandle MethodHandles)
   (java.nio.file Path)))

(deftype ImplementationUnavailableException []
  Exception)

(def ^:private mt-Class-bytes (MethodType/methodType Class byte/1))
(defn- get-ephemeral-factory ^MethodHandle [^PackageBuilder pkg-build]
  (let [ld (-> pkg-build .lookup-in-pkg .lookupClass .getClassLoader
               (classfile/class-loader-instance "tclj-eph" nil))]
    (-> (MethodHandles/lookup)
        (.findVirtual (class ld) "ephemeralClass" mt-Class-bytes)
        (.bindTo ld))))

(deftype NmspBuilderImpl [^NamespaceProvider universe
                          ^String ns-str
                          ^ExprFactory code-gen
                          ^:unsynchronized-mutable ^EnvSegment segment
                          ^PackageBuilder pkg-build
                          ^:unsynchronized-mutable ^map globals
                          ^:unsynchronized-mutable ^map known-ns
                          ^:unsynchronized-mutable ^map ns-alias
                          ^:unsynchronized-mutable ^map imports
                          ^:unsynchronized-mutable ^String current-source-file
                          ^:unsynchronized-mutable ^MethodHandle ephemeral-of]
  Resolver
  (ns-str [_]
    ns-str)
  (globals [_]                       ;only call from namespace thread!
    globals)
  (lookup-namespace [_ alias]
    (if (or (nil? alias) (= alias ns-str))
      ns-str
      (.valAt ns-alias alias nil)))
  (lookup-class [_ nm]
    (or
     (.valAt imports nm nil)
     (when-some [cl (resolve/class-for-name (.lookup-in-pkg pkg-build) nm)]
       (set! imports (assoc imports nm cl))
       cl)))
  (lookup-def [this nmsp nm]
    (if (or (nil? nmsp) (= nmsp ns-str))
      (.valAt globals nm nil)
      (when-some [nmsp* (.lookup-namespace this nmsp)]
        (-> known-ns ^map (.valAt nmsp* nil) (.valAt nm nil)))))
  (import-class [_ class]
    (set! imports (-> imports
                      (assoc (resolve/imported-short-name class) class)
                      (assoc (resolve/imported-long-name class) class))))
  (ephemeral-factory [_]
    (or ephemeral-of
        (set! ephemeral-of (get-ephemeral-factory pkg-build))))
  
  NamespaceBuilder
  (universe [_]
    universe)
  (process-require [this require provided]
    this)                               ;FIXME...
  (process-imports [this import-strs]
    (doseq [^String nm import-strs]
      (if-some [cl (.lookup-class this nm)]
        (.import-class this cl)
        (throw (wrong/info-class-not-found nm))))
    this)
  (new-def-immutable [_ nm init]
    (let [ent (defgen/entity-def-immutable (.segment-class segment) nm init)
          bnd (model/mk-binding ent nm false)
          init-ce (.emitter init)]
      (.stage-task! segment ent)
      (set! globals (assoc globals nm (if (entity/jvm-const? init-ce)
                                        init-ce
                                        (.bound-to bnd))))
      (insn/mk-insn bnd (insn/expr-type init))))
  (new-def-mutable [_ nm init]
    (let [ent (defgen/entity-def-mutable (.segment-class segment) nm init)
          bnd (model/mk-binding ent nm false)]
      (.stage-task! segment ent)
      (set! globals (assoc globals nm (.bound-to bnd)))
      (insn/mk-insn bnd (insn/expr-type init))))
  (new-def-alias [_ nm other-ent other-qname]
    (.stage-task! segment (defgen/task-def-alias nm other-ent other-qname))
    (set! globals (assoc globals nm other-ent))
    (insn/mk-insn other-ent (.value-type other-ent)))

  (load-file [this path-str]
    (assert false))
  
  (process-init-form [this fctx form]
    ;; This method is only called for expression forms that do not
    ;; manipulate `known-ns` or `ns-alias`.  The `globals` at start is
    ;; stored as part of of `scope`.
    (let [parser (form/mk-parser code-gen this globals)
          imports-at-start imports
          segm-size-at-start (.size-staged segment)
          expr (try
                 (parse/form parser fctx form)
                 (catch ImplementationUnavailableException _
                   ;; flush current segment into a class file, revert
                   ;; state, and try again to parse `form`
                   (.commit-segment-and-revert
                    this segm-size-at-start (.bindings* parser)
                    imports-at-start)
                   (parse/form parser fctx form)))]
      (.stage-task! segment expr)
      this))

  (finish [this]
    (.commit-segment-and-revert this (.size-staged segment) globals imports)
    (build/capstone pkg-build segment)
    (ProvidedNamespace. ns-str))
  (commit-segment-and-revert [this end-of-segment then-globals then-imports]
    (let [segm-acc (build/prepare-segment (.tasks segment) end-of-segment)]
      (build/segment pkg-build current-source-file segment segm-acc this))
    
    ;; revert back to requested state & move to next segment
    (set! segment (envgraph/next-segment segment))
    (set! globals then-globals)
    (set! imports then-imports)))

;;; ------------------------------------------------------------------------

(deftype UniverseBuilder [^Loader loader
                          ^map ns-form-map
                          ^:unsynchronized-mutable ^map known-ns
                          ^map ns-alias]
  NamespaceProvider
  (require-namespaces [this ns-strs]
    (letfn [(mk-nmsp-builder ^NamespaceBuilder [^String ns-str]
              (let [source-file nil
                    pkg-build (classfile/mk-package-builder loader ns-str)
                    segment (envgraph/mk-first-segment ns-str)
                    ef (-> (envgraph/mk-method-clinit segment)
                           (codegen/mk-factory))
                    globals primitive/primitive-nmsp-globals
                    imports (resolve/predefined-imports (.rt-lookup loader))]
                (NmspBuilderImpl. this ns-str ef segment pkg-build
                                  globals known-ns ns-alias imports
                                  source-file nil)))
            
            (build-namespace ^ProvidedNamespace [^String ns-str ^seq ns-forms]
              (loop [acc (mk-nmsp-builder ns-str), forms (seq ns-forms)]
                (if (nil? forms)
                  (.finish acc)
                  (recur (namespace/parse-top-level-form acc context/fctx-initial
                                                         (first forms))
                         (next forms)))))]
      
      (let [a (new ProvidedNamespace/1 (alength ns-strs))]
        (dotimes [i (alength a)]
          (let [ns-str (aget ns-strs i)]
            (->> (or (known-ns ns-str)
                     (when-some [ns-forms (ns-form-map ns-str)]
                       (let [pr-nmsp (build-namespace ns-str ns-forms)]
                         (set! known-ns (assoc known-ns ns-str pr-nmsp))
                         pr-nmsp)))
                 (aset a i))))
        a))))

;;; No class files are written to disk if `dest-dir` is nil.
(defn mk-universe ^NamespaceProvider [^map ns-form-map ^Loader loader]
  (let [provided-ns (reduce dissoc
                            {cfg/core-lib (ProvidedNamespace. cfg/core-lib)}
                            (keys ns-form-map))
        ns-alias {}]
    (UniverseBuilder. loader ns-form-map provided-ns ns-alias)))
