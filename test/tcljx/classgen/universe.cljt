(ns tcljx.classgen.universe
  (:require
   (tcljx.data
    [config :as cfg] [files :as files] [resolve :as resolve] [meta :as meta]
    [wrong :as wrong] [context :as context] [ir :as ir])
   (tcljx.parser
    [form :as form] [parse :as parse] [namespace :as namespace])
   (tcljx.classgen
    [classfile :as classfile] [runtime :as rt] [constgen :as constgen]
    [segment :as segment] [emit :as emit] [insn :as insn]
    [codegen :as codegen] [entity :as entity] [defgen :as defgen] [primitive :as primitive]
    [build :as build] [fnenv :as fnenv]))
  (:import
   (tcljx.data.ir Resolver NamespaceProvider ProvidedNamespace NmspClass
                  NamespaceBuilder Expr ExprFactory EntityFactory Parser)
   (tcljx.classgen.classfile Loader PackageBuilder)
   (tcljx.classgen.segment Segment SegmentBuilder)
   (tcljx.classgen.insn Insn)
   (java.lang.classfile ClassFile ClassBuilder CodeBuilder)
   (java.lang.invoke MethodType MethodHandle MethodHandles)
   (java.nio.file Path)
   (java.util ArrayList)))

(deftype ImplementationUnavailableException []
  Exception)

(def ^:private mt-Class-bytes (MethodType/methodType Class byte/1))
(defn- get-ephemeral-factory ^MethodHandle [^PackageBuilder pkg-build]
  (let [ld (-> pkg-build .lookup-in-pkg .lookupClass .getClassLoader
               (classfile/class-loader-instance "tclj-eph" nil))]
    (-> (MethodHandles/lookup)
        (.findVirtual (class ld) "ephemeralClass" mt-Class-bytes)
        (.bindTo ld))))

(deftype NmspBuilderImpl [^NamespaceProvider universe
                          ^String ns-str
                          ^ExprFactory code-gen
                          ^EntityFactory entity-gen
                          ^:unsynchronized-mutable ^Segment segment
                          ^PackageBuilder pkg-build
                          ^:unsynchronized-mutable ^map globals
                          ^:unsynchronized-mutable ^map known-ns
                          ^:unsynchronized-mutable ^map ns-alias
                          ^:unsynchronized-mutable ^map imports
                          ^:unsynchronized-mutable ^String current-source-file
                          ^:unsynchronized-mutable ^MethodHandle ephemeral-of]
  Resolver
  (ns-str [_]
    ns-str)
  (globals [_]                       ;only call from namespace thread!
    globals)
  (lookup-namespace [_ alias]
    (if (or (nil? alias) (= alias ns-str))
      ns-str
      (.valAt ns-alias alias nil)))
  (lookup-class [_ nm]
    (or
     (.valAt imports nm nil)
     (when-some [cl (resolve/class-for-name (.lookup-in-pkg pkg-build) nm)]
       (set! imports (assoc imports nm cl))
       cl)))
  (lookup-def [this nmsp nm]
    (if (or (nil? nmsp) (= nmsp ns-str))
      (.valAt globals nm nil)
      (when-some [nmsp* (.lookup-namespace this nmsp)]
        (-> known-ns ^map (.valAt nmsp* nil) (.valAt nm nil)))))
  (import-class [_ class]
    (set! imports (-> imports
                      (assoc (resolve/imported-short-name class) class)
                      (assoc (resolve/imported-long-name class) class))))
  (ephemeral-factory [_]
    (or ephemeral-of
        (set! ephemeral-of (get-ephemeral-factory pkg-build))))
  
  NamespaceBuilder
  (universe [_]
    universe)
  (process-require [this require provided]
    this)                               ;FIXME...
  (process-imports [this import-strs]
    (doseq [^String nm import-strs]
      (if-some [cl (.lookup-class this nm)]
        (.import-class this cl)
        (throw (wrong/info-class-not-found nm))))
    this)
  (new-def-immutable [_ nm init]
    #_(prn :new-def-immutable nm)
    (let [p (defgen/promise-def-immutable (.segment-class segment) nm init)
          bnd (ir/mk-binding (-> p .expr-of .emitter) nm false)
          init-ce (.emitter init)]
      (segment/stage-segment-task! segment p)
      (set! globals (assoc globals nm (if (constgen/jvm-const? init-ce)
                                        init-ce
                                        (.bound-to bnd))))
      (insn/mk-insn bnd (insn/expr-type init))))
  (new-def-mutable [_ nm init]
    #_(prn :new-def-mutable nm)
    (let [p (defgen/promise-def-mutable (.segment-class segment) nm init)
          bnd (ir/mk-binding (-> p .expr-of .emitter) nm false)]
      (segment/stage-segment-task! segment p)
      (set! globals (assoc globals nm (.bound-to bnd)))
      (insn/mk-insn bnd (insn/expr-type init))))
  (new-def-alias [_ nm other-ent other-qname]
    #_(prn :new-def-alias nm)
    (let [p (defgen/promise-def-alias nm other-ent other-qname)]
      (segment/stage-segment-task! segment p)
      (set! globals (assoc globals nm other-ent))
      (.expr-of p)))
  (load-file [this path-str]
    (assert false))
  
  (process-init-form [this fctx form]
    ;; This method is only called for expression forms that do not
    ;; manipulate `known-ns` or `ns-alias`.  The `globals` at start is
    ;; stored as part of of `scope`.
    (let [parser (form/mk-parser code-gen entity-gen this globals)
          imports-at-start imports
          segm-size-at-start (segment/size-segment-tasks segment)
          expr (try
                 (parse/form parser fctx form)
                 (catch ImplementationUnavailableException _
                   ;; flush current segment into a class file, revert
                   ;; state, and try again to parse `form`
                   (.commit-segment-and-revert
                    this segm-size-at-start (.bindings* parser)
                    imports-at-start)
                   (set! ephemeral-of nil) ;may contain stale classes
                   (parse/form parser fctx form)))] ;try again *once*
      (segment/stage-segment-task! segment expr)
      this))

  (finish [this]
    (.commit-segment-and-revert this (segment/size-segment-tasks segment) globals imports)
    (->> (build/capstone pkg-build segment)
         (ir/mk-nmsp-class (segment/capstone-class segment) (.super-class segment))
         (classfile/bwdi pkg-build))
    (ProvidedNamespace. ns-str))
  (commit-segment-and-revert [this end-of-segment then-globals then-imports]
    (let [tasks (-> (.subList (.tasks segment) 0 end-of-segment)
                    (fnenv/transitive-closure!))
          clinit-statms (segment/clinit-statements tasks)
          acp (segment/code-promises tasks)
          class-elements (ArrayList.), other-classes (ArrayList.)
          sb (SegmentBuilder. class-elements other-classes
                              (.segment-class segment))
          env-factory (fnenv/mk-env-factory (build/env-carrying-fns acp))]
      (dotimes [i (alength acp)]
        (.generate-and-deliver (aget acp i) sb env-factory))
      (doseq [ncl other-classes]
        (classfile/declare-class pkg-build ncl))
      (doseq [^NmspClass ncl other-classes]
        (classfile/bwdi pkg-build ncl))
      (->> (build/segment current-source-file segment
                          class-elements clinit-statms)
           (ir/mk-nmsp-class (.segment-class segment) (.super-class segment))
           (classfile/bwdi pkg-build)))
    
    ;; revert back to requested state & move to next segment
    (set! segment (segment/next-segment segment))
    (set! globals then-globals)
    (set! imports then-imports)))

;;; ------------------------------------------------------------------------

(deftype UniverseBuilder [^Loader loader
                          ^map ns-form-map
                          ^:unsynchronized-mutable ^map known-ns
                          ^map ns-alias]
  NamespaceProvider
  (require-namespaces [this ns-strs]
    (letfn [(mk-nmsp-builder ^NamespaceBuilder [^String ns-str]
              (let [source-file nil
                    pkg-build (classfile/mk-package-builder loader ns-str)
                    segment (segment/mk-first-segment ns-str)
                    etf (entity/mk-clinit-etf ns-str (.tasks segment))
                    xf (codegen/mk-factory)
                    globals primitive/primitive-nmsp-globals
                    imports (resolve/predefined-imports (.rt-lookup loader))]
                (NmspBuilderImpl. this ns-str xf etf segment pkg-build
                                  globals known-ns ns-alias imports
                                  source-file nil)))
            
            (build-namespace ^ProvidedNamespace [^String ns-str ^seq ns-forms]
              (loop [acc (mk-nmsp-builder ns-str), forms (seq ns-forms)]
                (if (nil? forms)
                  (.finish acc)
                  (recur (namespace/parse-top-level-form acc context/fctx-initial
                                                         (first forms))
                         (next forms)))))]
      
      (let [a (new ProvidedNamespace/1 (alength ns-strs))]
        (dotimes [i (alength a)]
          (let [ns-str (aget ns-strs i)]
            (->> (or (known-ns ns-str)
                     (when-some [ns-forms (ns-form-map ns-str)]
                       (let [pr-nmsp (build-namespace ns-str ns-forms)]
                         (set! known-ns (assoc known-ns ns-str pr-nmsp))
                         pr-nmsp)))
                 (aset a i))))
        a))))

;;; No class files are written to disk if `dest-dir` is nil.
(defn mk-universe ^NamespaceProvider [^map ns-form-map ^Loader loader]
  (let [provided-ns (reduce dissoc
                            {cfg/core-lib (ProvidedNamespace. cfg/core-lib)}
                            (keys ns-form-map))
        ns-alias {}]
    (UniverseBuilder. loader ns-form-map provided-ns ns-alias)))
