(ns tcljx.classgen.universe
  (:require
   (tcljx.data
    [config :as cfg] [files :as files] [resolve :as resolve] [meta :as meta]
    [wrong :as wrong] [context :as context] [model :as model])
   (tcljx.parser
     [form :as form] [parse :as parse] [namespace :as namespace])
   (tcljx.classgen
    [loader :as loader] [runtime :as rt] [classfile :as classfile]
    [envgraph :as envgraph] [entity :as entity] [emit :as emit] [insn :as insn]
    [build :as build] [codegen :as codegen] [defgen :as defgen]
    [primitive :as primitive]))
  (:import
   (tcljx.data.model Resolver NamespaceProvider ProvidedNamespace
                     NamespaceBuilder Expr ExprFactory Parser)
   (tcljx.classgen.loader Loader PackageBuilder)
   (tcljx.classgen.envgraph EnvSegment EnvMethod)
   (tcljx.classgen.insn Insn)
   (java.lang.classfile ClassBuilder CodeBuilder)
   (java.nio.file Path)))

(deftype ImplementationUnavailableException []
  Exception)

(deftype NmspBuilderImpl [^NamespaceProvider universe
                          ^String ns-str
                          ^ExprFactory code-gen
                          ^:unsynchronized-mutable ^EnvSegment segment
                          ^PackageBuilder pkg-build
                          ^:unsynchronized-mutable ^map globals
                          ^:unsynchronized-mutable ^map known-ns
                          ^:unsynchronized-mutable ^map ns-alias
                          ^:unsynchronized-mutable ^map imports
                          ^:unsynchronized-mutable ^String current-source-file]
  Resolver
  (ns-str [_]
    ns-str)
  (lookup-namespace [_ alias]
    (.valAt ns-alias alias nil))
  (lookup-class [_ nm]
    (or
     (.valAt imports nm nil)
     (when-some [cl (resolve/class-for-name (.lookup-in-pkg pkg-build) nm)]
       (set! imports (assoc imports nm cl))
       cl)))
  (lookup-def [this nmsp nm]
    (if (or (nil? nmsp) (= nmsp ns-str))
      (.valAt globals nm nil)
      (when-some [nmsp* (.lookup-namespace this nmsp)]
        (-> known-ns ^map (.valAt nmsp* nil) (.valAt nm nil)))))
    
  NamespaceBuilder
  (universe [_]
    universe)
  (process-require [this require provided]
    this)                               ;FIXME...
  (process-imports [this import-strs]
    (doseq [^String nm import-strs]
      (if-some [cl (.lookup-class this nm)]
        (set! imports (-> imports
                          (assoc (resolve/imported-short-name cl) cl)
                          (assoc (.getName cl) cl)))
        (throw (wrong/info-class-not-found nm))))
    this)
  ;; (add-def [_ nm bnd]
  ;;   (set! globals (assoc globals nm bnd))
  ;;   bnd)
  (new-def-immutable [_ nm init]
    (let [bnd (defgen/new-def-immutable segment nm init)
          init-ce (.emitter init)]
      (set! globals (assoc globals nm (if (entity/jvm-const? init-ce)
                                        init-ce
                                        (.bound-to bnd))))
      (insn/mk-insn bnd Void/TYPE)))
  (new-def-mutable [_ nm init]
    (let [bnd (defgen/new-def-mutable segment nm init)]
      (set! globals (assoc globals nm (.bound-to bnd)))
      (insn/mk-insn bnd Void/TYPE)))
  (new-def-alias [_ nm other-ent other-nmsp other-nm]
    (assert false))

  (load-file [this path-str]
    (assert false))
  
  (process-init-form [this fctx form]
    ;; This method is only called for expression forms that do not
    ;; manipulate `known-ns` or `ns-alias`.  The `globals` at start is
    ;; stored as part of of `scope`.
    (let [parser (form/mk-parser code-gen this globals)
          imports-at-start imports
          segm-size-at-start (.size-staged segment)
          expr (try
                 (parse/form parser fctx form)
                 (catch ImplementationUnavailableException _
                   ;; flush current segment into a class file, revert
                   ;; state, and try again to parse `form`
                   (.commit-segment-and-revert
                    this segm-size-at-start (.bindings* parser)
                    imports-at-start)
                   (parse/form parser fctx form)))]
      (.stage-task! segment (.emitter expr))
      this))

  (finish [this]
    (.commit-segment-and-revert this (.size-staged segment) globals imports)
    (build/capstone pkg-build segment)
    (ProvidedNamespace. ns-str))
  (commit-segment-and-revert [_ end-of-segment then-globals then-imports]
    (let [segm-acc (build/prepare-segment (.tasks segment) end-of-segment)]
      (build/segment pkg-build current-source-file segment segm-acc))
    
    ;; revert back to requested state & move to next segment
    (set! segment (envgraph/next-segment segment))
    (set! globals then-globals)
    (set! imports then-imports)))

;;; ------------------------------------------------------------------------

(deftype UniverseBuilder [^Loader loader
                          ^map ns-form-map
                          ^:unsynchronized-mutable ^map known-ns
                          ^map ns-alias]
  NamespaceProvider
  (require-namespaces [this ns-strs]
    (letfn [(mk-nmsp-builder ^NamespaceBuilder [^String ns-str]
              (let [source-file nil
                    pkg-build (loader/mk-package-builder loader ns-str)
                    segment (envgraph/mk-first-segment ns-str)
                    ef (-> (envgraph/mk-method-clinit segment)
                           (codegen/mk-factory))
                    globals primitive/primitive-nmsp-globals
                    imports (resolve/predefined-imports (.rt-lookup loader))]
                (NmspBuilderImpl. this ns-str ef segment pkg-build
                                  globals known-ns ns-alias imports
                                  source-file)))
            
            (build-namespace ^ProvidedNamespace [^String ns-str ^seq ns-forms]
              (loop [acc (mk-nmsp-builder ns-str), forms (seq ns-forms)]
                (if (nil? forms)
                  (.finish acc)
                  (recur (namespace/parse-top-level-form acc context/fctx-initial
                                                         (first forms))
                         (next forms)))))]
      
      (let [a (new ProvidedNamespace/1 (alength ns-strs))]
        (dotimes [i (alength a)]
          (let [ns-str (aget ns-strs i)]
            (->> (or (known-ns ns-str)
                     (when-some [ns-forms (ns-form-map ns-str)]
                       (let [pr-nmsp (build-namespace ns-str ns-forms)]
                         (set! known-ns (assoc known-ns ns-str pr-nmsp))
                         pr-nmsp)))
                 (aset a i))))
        a))))

;;; No class files are written to disk if `dest-dir` is nil.
(defn mk-universe ^NamespaceProvider [^map ns-form-map ^Loader loader]
  (let [provided-ns (reduce dissoc
                            {cfg/core-lib (ProvidedNamespace. cfg/core-lib)}
                            (keys ns-form-map))
        ns-alias {}]
    (UniverseBuilder. loader ns-form-map provided-ns ns-alias)))
