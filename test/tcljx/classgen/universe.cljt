(ns tcljx.classgen.universe
  (:require
   (tcljx.data
    [config :as cfg] [files :as files] [resolve :as resolve] [model :as model]
    [wrong :as wrong])
   (tcljx.parser
    [context :as context] [form :as form] [namespace :as namespace])
   (tcljx.classgen
    [loader :as loader] [runtime :as rt] [classfile :as classfile]
    [emit :as emit] [insn :as insn] [segmgen :as segmgen] [codegen :as codegen]
    [defgen :as defgen] [primitive :as primitive]))
  (:import
   (tcljx.data.model Resolver NamespaceProvider ProvidedNamespace
                     NamespaceBuilder SegmentBuilder
                     Expr ExprFactory Scope)
   (tcljx.classgen.loader Loader PackageBuilder)
   (tcljx.classgen.insn Insn)
   (java.lang.classfile ClassBuilder CodeBuilder)
   (java.nio.file Path)
   (java.util ArrayList)
   (java.util.concurrent ConcurrentHashMap)
   (java.util.function Consumer)))

(deftype ImplementationUnavailableException []
  Exception)

(deftype NmspBuilderImpl [^NamespaceProvider universe
                          ^String ns-str
                          ^ExprFactory code-gen
                          ^ArrayList segment-elements
                          ^ArrayList pending-functions ;added to by `code-gen`
                          ^PackageBuilder pkg-build
                          ^:unsynchronized-mutable ^map globals
                          ^:unsynchronized-mutable ^map known-ns
                          ^:unsynchronized-mutable ^map ns-alias
                          ^:unsynchronized-mutable ^map imports
                          ^:unsynchronized-mutable ^String current-source-file
                          ^:unsynchronized-mutable ^int current-segm-id]
  Resolver
  (ns-str [_]
    ns-str)
  (lookup-namespace [_ alias]
    (.valAt ns-alias alias nil))
  (lookup-class [_ nm]
    (or
     (.valAt imports nm nil)
     (when-some [cl (resolve/class-for-name (.lookup-in-pkg pkg-build) nm)]
       (set! imports (assoc imports nm cl))
       cl)))
  (lookup-def [this nmsp nm]
    (if (or (nil? nmsp) (= nmsp ns-str))
      (.valAt globals nm nil)
      (when-some [nmsp* (.lookup-namespace this nmsp)]
        (-> known-ns ^map (.valAt nmsp* nil) (.valAt nm nil)))))
  (pick-unique-name [_ dflt-nm]
    dflt-nm)
  
  NamespaceBuilder
  (universe [_]
    universe)
  (process-require [this require provided]
    this)                               ;FIXME...
  (process-imports [this import-strs]
    (doseq [^String nm import-strs]
      (if-some [cl (.lookup-class this nm)]
        (set! imports (-> imports
                          (assoc (resolve/imported-short-name cl) cl)
                          (assoc (.getName cl) cl)))
        (throw (wrong/info-class-not-found nm))))
    this)
  ;; (add-def [_ nm bnd]
  ;;   (set! globals (assoc globals nm bnd))
  ;;   bnd)
  (new-def-init [_ nm init]
    (let [this-segm (segmgen/segment-cld pkg-build current-segm-id)]
      (defgen/new-def-init segment-elements this-segm nm init)))
  (new-def-alias [_ nm other]
    (assert false))

  (load-file [this path-str]
    (assert false))
  
  (process-init-form [this form]
    ;; This method is only called for expression forms that do not
    ;; manipulate `known-ns` or `ns-alias`.  The `globals` at start is
    ;; stored as part of of `scope`.
    (let [scope (form/mk-scope code-gen this globals)
          imports-at-start imports
          segment-elements-at-start (.size segment-elements)
          expr (try
                 (context/parse-form scope form)
                 (catch ImplementationUnavailableException _
                   ;; flush current segment into a class file, revert
                   ;; state, and try again to parse `form`
                   (.commit-segment-and-revert
                    this segment-elements-at-start
                    (.bindings* scope) imports-at-start)
                   (context/parse-form scope form)))]
      (.add segment-elements expr)
      (when-not (.isEmpty pending-functions)
        (codegen/process-functions! segment-elements pending-functions))
      this))

  (finish [this]
    (.commit-segment-and-revert this (.size segment-elements) globals imports)
    (segmgen/define-capstone pkg-build current-segm-id)
    (ProvidedNamespace. ns-str))

  SegmentBuilder
  (commit-segment-and-revert [_ end-of-segment-elements
                              then-globals then-imports]
    (segmgen/define-segment pkg-build current-segm-id current-source-file
      (^Consumer fn ^void [^ClassBuilder cb]
       (dotimes [i end-of-segment-elements]
         (let [elem (.get segment-elements i)]
           (when (classfile/class-element-emitter? elem)
             (classfile/emit-class-element cb elem)))))
      (let [a (doto (ArrayList.)
                (.add (segmgen/clinit-prologue ns-str current-segm-id)))]
        (loop [i 0]
          (if (< i end-of-segment-elements)
            (let [elem (.get segment-elements i)]
              (when (instance? Insn elem)
                (.add a elem))
              (recur (inc i)))
            (do (.add a (segmgen/clinit-epilogue pkg-build current-segm-id))
                (insn/progn (insn/insns-of* a) insn/insn-empty))))))
    
    ;; revert back to requested state & move to next segment
    (set! globals then-globals)
    (set! imports then-imports)
    (.clear segment-elements)
    (set! current-segm-id (inc current-segm-id))))

;;; ------------------------------------------------------------------------

(deftype UniverseBuilder [^Loader loader
                          ^map ns-form-map
                          ^:unsynchronized-mutable ^map known-ns
                          ^map ns-alias]
  NamespaceProvider
  (require-namespaces [this ns-strs]
    (letfn [(mk-nmsp-builder ^NamespaceBuilder [^String ns-str]
              (let [source-file nil
                    pkg-build (loader/mk-package-builder loader ns-str)
                    pending-functions (ArrayList.)
                    ef (codegen/mk-code-generator pending-functions)
                    segment-elements (ArrayList.)
                    globals primitive/primitive-nmsp-globals
                    imports (resolve/predefined-imports (.rt-lookup loader))]
                (NmspBuilderImpl. this ns-str ef
                                  segment-elements pending-functions
                                  pkg-build globals known-ns ns-alias imports
                                  source-file segmgen/first-segm-id)))
            
            (build-namespace ^ProvidedNamespace [^String ns-str ^seq ns-forms]
              (-> (reduce namespace/parse-top-level-form
                          (mk-nmsp-builder ns-str)
                          ns-forms)
                  (NamespaceBuilder/.finish)))]
      
      (let [a (new ProvidedNamespace/1 (alength ns-strs))]
        (dotimes [i (alength a)]
          (let [ns-str (aget ns-strs i)]
            (->> (or (known-ns ns-str)
                     (when-some [ns-forms (ns-form-map ns-str)]
                       (let [pr-nmsp (build-namespace ns-str ns-forms)]
                         (set! known-ns (assoc known-ns ns-str pr-nmsp))
                         pr-nmsp)))
                 (aset a i))))
        a))))

;;; No class files are written to disk if `dest-dir` is nil.
(defn mk-universe ^NamespaceProvider [^map ns-form-map ^Loader loader]
  (let [provided-ns (reduce dissoc
                            {cfg/core-lib (ProvidedNamespace. cfg/core-lib)}
                            (keys ns-form-map))
        ns-alias {}]
    (UniverseBuilder. loader ns-form-map provided-ns ns-alias)))
