;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https:;;www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.classgen.invoke-test
  (:require [tcljx.classgen.bootstrap :refer [asm-expr]]
            [tcljx.alpha.ptest :refer :all]))

;;; Note: Some of the tests below may need an (identity ...) wrapper
;;; eventually.

(deftest constructor-invoke-test
  (is (= '[(NEW HashMap) (DUP)
           (INVOKESPECIAL HashMap "<init>" "()V")
           (ARETURN)]
         (asm-expr (new java.util.HashMap))))

  ;; Third party Java libraries cannot have a static method called
  ;; `new`, because in Java `new` is a keyword and not an identifier.
  ;; Clojure's deftype does not support static methods at all.  Taking
  ;; this into account, there is little downside to having the dot
  ;; form supporting `new` as symbolic constructor name as well.
  (is (= '[(NEW HashMap) (DUP)
           (INVOKESPECIAL HashMap "<init>" "()V")
           (ARETURN)]
         (asm-expr (. java.util.HashMap new)))))

(deftest static-field-test
  (is (= '[(GETSTATIC Math "PI" "D")
           (DRETURN)]
         (asm-expr (. java.lang.Math PI)))))

(deftest static-invoke-test
  (is (= '[(INVOKESTATIC System "getProperties"
                         "()Ljava/util/Properties;")
           (ARETURN)]
         (asm-expr (. java.lang.System getProperties))))
  (is (= '[(LDC "foo")
           (INVOKESTATIC System "getProperty"
                         "(Ljava/lang/String;)Ljava/lang/String;")
           (ARETURN)]
         (asm-expr (. java.lang.System getProperty "foo"))))

  (is (= '[(INVOKESTATIC MethodHandles "lookup"
                         "()Ljava/lang/invoke/MethodHandles$Lookup;")
           (ARETURN)]
         (asm-expr (. java.lang.invoke.MethodHandles lookup))))
  (is (= '[["LOCAL 0: MethodHandles$Lookup l"]
           (ALOAD_0)
           (INVOKESTATIC RT "setCoreLookup"
                         "(Ljava/lang/invoke/MethodHandles$Lookup;)V")
           (RETURN)]
         (asm-expr [^java.lang.invoke.MethodHandles$Lookup l]
                   (identity (. tinyclj.lang.RT setCoreLookup l)))))

  ;; Math/log takes a double and requires implicit conversion from int
  ;; (is (= '(INVOKE-XREF STATIC "Math" "log" "(D)D" :owner-is-class)
  ;;        (asm-expr (. java.lang.Math log 123))))
  ;; (is (thrown-with-msg? WrongInfo #"no static method matching"
  ;;                       (dot-static java.lang.Math "log" jb/boolean)))
  ;; (is (thrown-with-msg? WrongInfo #"no static method matching"
  ;;                       (dot-static java.lang.Math "log" jb/char)))
  
  ;; Math/max has four paired overloads
  (is (= '[(ICONST_1) (ICONST_2)
           (INVOKESTATIC Math "max" "(II)I")
           (IRETURN)]
         (asm-expr (. java.lang.Math max 1 2))))
  (is (= '[(LCONST_1) (LDC2_W 2l)
           (INVOKESTATIC Math "max" "(JJ)J")
           (LRETURN)]
         (asm-expr (. java.lang.Math max 1l 2l))))
  (is (= '[(FCONST_1) (FCONST_2)
           (INVOKESTATIC Math "max" "(FF)F")
           (FRETURN)]
         (asm-expr (. java.lang.Math max 1.0f 2.0f))))
  (is (= '[(DCONST_1) (LDC2_W 2.0)
           (INVOKESTATIC Math "max" "(DD)D")
           (DRETURN)]
         (asm-expr (. java.lang.Math max 1.0 2.0))))

  ;; ;; varargs call with box of primitive int passed via the `args`
  ;; ;; array of type `Object...`
  ;; (is (= '(INVOKE-XREF STATIC "String" "format"
  ;;                      "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;"
  ;;                      :owner-is-class)
  ;;        (dot-static String "format" String jb/int)))
  )


(deftest virtual-field-test
  (is (= '[["LOCAL 0: Point obj"]
           (ALOAD_0)
           (GETFIELD Point "x" "I")
           (IRETURN)]
         (asm-expr [^java.awt.Point obj] (. obj x)))))

;;; Note: In general, the owner of an invoke instruction is the class
;;; from which the resolve process started, *not* the class that
;;; defines the invoked method.  The same is true for field
;;; instructions, when e.g. a static final field of a base class is
;;; resolved using one of its extending classes.
(deftest virtual-invoke-test
  (is (= '[(LDC "foo")
           (INVOKEVIRTUAL String "toUpperCase" "()Ljava/lang/String;")
           (ARETURN)]
         (asm-expr (. "foo" toUpperCase))))
  (is (= '[(LDC Class)
           (INVOKEVIRTUAL Class "getName" "()Ljava/lang/String;")
           (ARETURN)]
         (asm-expr (. (identity Class) getName))))

  ;; ;; varargs call: no `parameterTypes` and three `parameterTypes`
  ;; (is (= '(INVOKE-XREF VIRTUAL "Class" "getMethod"
  ;;                      "(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;"
  ;;                      :owner-is-class)
  ;;        (dot-virtual Class "getMethod" String)))
  ;; (is (= '(INVOKE-XREF VIRTUAL "Class" "getConstructor"
  ;;                      "([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;"
  ;;                      :owner-is-class)
  ;;        (dot-virtual Class "getConstructor" Class Class Class)))

  ;; ;; `withInterfaceSymbols` with an `Object` argument is ambiguous in
  ;; ;; Clojure (but not in Java!), and resolved to a single method with
  ;; ;; `List`, `ClassDesc`, or an empty argument list
  ;; (is (thrown-with-msg? WrongInfo #"multiple virtual methods match"
  ;;                       (dot-virtual java.lang.classfile.ClassBuilder
  ;;                                    "withInterfaceSymbols" Object)))
  (is (= '[["LOCAL 0: ClassBuilder obj"]
           ["LOCAL 1: List arg1"]
           (ALOAD_0)
           (ALOAD_1)
           (INVOKEINTERFACE ClassBuilder "withInterfaceSymbols"
                            "(Ljava/util/List;)Ljava/lang/classfile/ClassBuilder;"
                            :itf)
           (ARETURN)]
         (asm-expr [^java.lang.classfile.ClassBuilder obj
                    ^java.util.List arg1]
                   (. obj withInterfaceSymbols arg1))))
  (is (= '[["LOCAL 0: ClassBuilder obj"]
           ["LOCAL 1: ClassDesc[] arg1"]
           (ALOAD_0)
           (ALOAD_1)
           (INVOKEINTERFACE ClassBuilder "withInterfaceSymbols"
                            "([Ljava/lang/constant/ClassDesc;)Ljava/lang/classfile/ClassBuilder;"
                            :itf)
           (ARETURN)]
         (asm-expr [^java.lang.classfile.ClassBuilder obj
                    ^java.lang.constant.ClassDesc/1 arg1]
                   (. obj withInterfaceSymbols arg1))))
  ;; (is (= '(INVOKE-XREF INTERFACE_VIRTUAL "ClassBuilder" "withInterfaceSymbols"
  ;;                      "([Ljava/lang/constant/ClassDesc;)Ljava/lang/classfile/ClassBuilder;"
  ;;                      :owner-is-itf)
  ;;        (dot-virtual java.lang.classfile.ClassBuilder "withInterfaceSymbols")))
  )

;; (deftest interface-varargs-clash-test
;;   ;; this should resolve to the varargs method
;;   ;; static MethodTypeDesc of(ClassDesc returnDesc, ClassDesc... paramDescs)
;;   (is (= '(INVOKE-XREF INTERFACE_STATIC "MethodTypeDesc" "of"
;;                        "(Ljava/lang/constant/ClassDesc;[Ljava/lang/constant/ClassDesc;)Ljava/lang/constant/MethodTypeDesc;"
;;                        :owner-is-itf)
;;          (dot-static java.lang.constant.MethodTypeDesc "of"
;;                      java.lang.constant.ClassDesc
;;                      java.lang.constant.ClassDesc)))
  
;;   ;; this should resolve to the List method
;;   ;; static MethodTypeDesc of(ClassDesc returnDesc, List<ClassDesc> paramDescs)
;;   (is (= '(INVOKE-XREF INTERFACE_STATIC
;;                        "MethodTypeDesc" "of"
;;                        "(Ljava/lang/constant/ClassDesc;Ljava/util/List;)Ljava/lang/constant/MethodTypeDesc;"
;;                        :owner-is-itf)
;;          (dot-static java.lang.constant.MethodTypeDesc "of"
;;                      java.lang.constant.ClassDesc
;;                      java.util.List))))

;; (deftest compatible-args-test
;;   ;; the "dominate" checks must establish any precondition required by
;;   ;; `alignment` before calling it
;;   (is (= '(INVOKE-XREF INTERFACE_STATIC "Set" "of"
;;                        "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Set;"
;;                        :owner-is-itf)
;;          (dot-static java.util.Set "of"
;;                      java.nio.file.attribute.PosixFilePermission
;;                      java.nio.file.attribute.PosixFilePermission
;;                      java.nio.file.attribute.PosixFilePermission))))

;; (deftest one-arg-vs-one-plus-varargs-test
;;   (is (= '(INVOKE-XREF INTERFACE_VIRTUAL "Path" "resolve"
;;                        "(Ljava/lang/String;)Ljava/nio/file/Path;"
;;                        :owner-is-itf)
;;          (dot-virtual java.nio.file.Path "resolve" String)))
;;   (is (= '(INVOKE-XREF INTERFACE_VIRTUAL "Path" "resolve"
;;                        "(Ljava/lang/String;[Ljava/lang/String;)Ljava/nio/file/Path;"
;;                        :owner-is-itf)
;;          (dot-virtual java.nio.file.Path "resolve" String String))))

;; (deftest void-argument-test
;;   (is (= '(INVOKE-XREF STATIC "Math" "log" "(D)D" :owner-is-class)
;;          (dot-static java.lang.Math "log" jb/void)))
;;   (is (= '(INVOKE-XREF STATIC "Objects" "toString"
;;                        "(Ljava/lang/Object;)Ljava/lang/String;" :owner-is-class)
;;          (dot-static java.util.Objects "toString" jb/void))))

;; ;;; Argument nil is treated specially when looking for matching
;; ;;; methods.  Instead of satisfying a primitive parameter by unboxing
;; ;;; nil (which must fail at runtime), treat such a constellation as a
;; ;;; mismatch similar to incompatible types.
;; (deftest nil-argument-to-primitive-parameter-test
;;   ;; single candidate: argument is of type int
;;   (is (thrown-with-msg? WrongInfo #"no static method matching"
;;                         (invoke/dot-member x/flags-no-ln java.lang.Integer
;;                                            "bitCount" [x/expr-nil-object]
;;                                            resolve/opts-static)))
;;   ;; overloaded: argument is either int, long, float, or double
;;   (is (thrown-with-msg? WrongInfo #"no static method matching"
;;                         (invoke/dot-member x/flags-no-ln java.lang.Math
;;                                            "abs" [x/expr-nil-object]
;;                                            resolve/opts-static))))

;; ;;; Clojure 1.12.0-alpha6 has this to say: "Note: Static fields are
;; ;;; values and should be referenced without parens unless they are
;; ;;; intended as function calls, e.g (System/out) should be
;; ;;; System/out. Future Clojure releases will treat the fieldâ€™s value
;; ;;; as something invokable and invoke it."
;; ;;;
;; ;;; Dot form translation is unchanged, but the interpretation of
;; ;;; `Classname/member` is adjusted accordingly.
;; (deftest invoke-static-field-test
;;   (is (thrown-with-msg? WrongInfo #"does not implement `IFn`"
;;                         (asm-expr (System/out)))))
