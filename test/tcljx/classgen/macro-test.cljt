;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https:;;www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.classgen.macro-test
  (:require [tcljx.classgen.bootstrap :refer [nmsp asm-expr]]
            [tcljx.alpha.ptest :refer :all]))

(def exp-one-macro
  '[[(CLASS Vx [PUBLIC ABSTRACT] "pkg/ns0/_10")
     [(METHOD [PUBLIC STATIC FINAL] "one-macro~2" "(Ljava/lang/Object;Ljava/lang/Object;)I")
      ["LOCAL 0: Object &form"]
      ["LOCAL 1: Object &env"]
      (ICONST_1)
      (IRETURN)]
     [(METHOD [PUBLIC STATIC FINAL] "one-macro" "()Ltinyclj/lang/StaticFn;")
      (RuntimeVisibleAnnotations (Macro))
      (LDC [:bsm-static-fn "_" "Ltinyclj/lang/StaticFn;"
            [[STATIC . "one-macro~2" "(Ljava/lang/Object;Ljava/lang/Object;)I"]]])
      (ARETURN)]

     [(METHOD [PUBLIC STATIC] "<clinit>" "()V")
      (LDC "pkg.ns0")
      (INVOKESTATIC RT "createNamespace" "(Ljava/lang/String;)V")
      (RETURN)]]
    [(CLASS Vx [PUBLIC ABSTRACT] "pkg/ns0/_11" nil "pkg/ns0/_10")
     [(METHOD [PUBLIC STATIC FINAL] "one" "()I")
      (ICONST_1)
      (IRETURN)]
     [(METHOD [PUBLIC STATIC] "<clinit>" "()V")
      (RETURN)]]
    [(CLASS Vx [PUBLIC ABSTRACT] "pkg/ns0/___" nil "pkg/ns0/_11")
     [(METHOD [PUBLIC STATIC FINAL SYNTHETIC] "requires~1" "()Ljava/lang/String;")
      (LDC "clojure.core")
      (ARETURN)]]])

(deftest open-code-macro
  (is (= exp-one-macro
         (nmsp '[(ns pkg.ns0)
                 (def ^:macro one-macro
                   (fn* one-macro ^int [&form &env]
                        1))
                 (def one (one-macro))]))))

;;; This construction will not work as long as `do` forms on the
;;; namespace level are not unpacked into multiple top-level forms.
(deftest macro-inside-do
  (is (thrown-with-msg? Exception #"cannot define and expand macro in same top-level form"
                        (nmsp '[(ns pkg.ns0)
                                (do
                                  (def ^:macro one-macro
                                    (fn* one-macro ^int [&form &env]
                                         1))
                                  (def one (one-macro)))]))))

(deftest macro-call-to-same-segment
  ;; my-defn should call sigs from the same namespace segment
  (is (= '[[(CLASS Vx [PUBLIC ABSTRACT] "pkg/ns0/_10")
            [(METHOD [PUBLIC STATIC FINAL] "cons" "()Ltinyclj/lang/StaticFn;")
             (LDC [:bsm-static-fn "_" "Ltinyclj/lang/StaticFn;"
                   [[STATIC RT "cons" "(Ljava/lang/Object;Ljava/lang/Object;)Lclojure/lang/ISeq;"]]])
             (ARETURN)]
            
            [(METHOD [PUBLIC STATIC FINAL BRIDGE VARARGS SYNTHETIC] "loop~3" "(Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;")
             #_["LOCAL 0: Object &form"]
             #_["LOCAL 1: Object &env"]
             #_["LOCAL 2: Object[] decl"]
             (ALOAD_0)
             (ALOAD_1)
             (ALOAD_2)
             (INVOKESTATIC ArraySeq "create" "([Ljava/lang/Object;)Lclojure/lang/ArraySeq;")
             (INVOKESTATIC . "loop~3" "(Ljava/lang/Object;Ljava/lang/Object;Lclojure/lang/ISeq;)Ljava/lang/Object;")
             (ARETURN)]
            [(METHOD [PUBLIC STATIC FINAL] "loop~3" "(Ljava/lang/Object;Ljava/lang/Object;Lclojure/lang/ISeq;)Ljava/lang/Object;")
             ["LOCAL 0: Object &form"]
             ["LOCAL 1: Object &env"]
             ["LOCAL 2: ISeq decl"]
             (LDC [:bsm-quote "symbol" "Lclojure/lang/Symbol;" ["loop*"]])
             (ALOAD_2)
             (INVOKESTATIC RT "cons" "(Ljava/lang/Object;Ljava/lang/Object;)Lclojure/lang/ISeq;")
             (ARETURN)]
            [(METHOD [PUBLIC STATIC FINAL] "loop" "()Ltinyclj/lang/StaticFn;")
             (RuntimeVisibleAnnotations (Macro))
             (LDC [:bsm-static-fn "_" "Ltinyclj/lang/StaticFn;"
                   [[STATIC . "loop~3" "(Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;"]]])
             (ARETURN)]
            
            [(METHOD [PUBLIC STATIC FINAL BRIDGE VARARGS SYNTHETIC] "my-fn~3"
                     "(Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;")
             (ALOAD_0)
             (ALOAD_1)
             (ALOAD_2)
             (INVOKESTATIC ArraySeq "create"
                           "([Ljava/lang/Object;)Lclojure/lang/ArraySeq;")
             (INVOKESTATIC . "my-fn~3"
                           "(Ljava/lang/Object;Ljava/lang/Object;Lclojure/lang/ISeq;)Ljava/lang/Object;")
             (ARETURN)]
            [(METHOD [PUBLIC STATIC FINAL] "my-fn~3"
                     "(Ljava/lang/Object;Ljava/lang/Object;Lclojure/lang/ISeq;)Ljava/lang/Object;")
             ["LOCAL 0: Object &form"]
             ["LOCAL 1: Object &env"]
             ["LOCAL 2: ISeq decl"]
             (LDC [:bsm-quote "symbol" "Lclojure/lang/Symbol;" ["fn*"]])
             (ALOAD_2)
             (INVOKESTATIC RT "cons"
                           "(Ljava/lang/Object;Ljava/lang/Object;)Lclojure/lang/ISeq;")
             (ARETURN)]
            [(METHOD [PUBLIC STATIC FINAL] "my-fn" "()Ltinyclj/lang/StaticFn;")
             (RuntimeVisibleAnnotations (Macro))
             (LDC [:bsm-static-fn "_" "Ltinyclj/lang/StaticFn;"
                   [[STATIC . "my-fn~3"
                     "(Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;"]]])
             (ARETURN)]
            
            [(METHOD [PUBLIC STATIC] "<clinit>" "()V")
             (LDC "pkg.ns0")
             (INVOKESTATIC RT "createNamespace" "(Ljava/lang/String;)V")
             (RETURN)]]
           
           [(CLASS Vx [PUBLIC ABSTRACT] "pkg/ns0/_11" nil "pkg/ns0/_10")
            [(METHOD [PUBLIC STATIC FINAL] "first" "()Ltinyclj/lang/StaticFn;")
             (LDC [:bsm-static-fn "_" "Ltinyclj/lang/StaticFn;"
                   [[STATIC RT "first" "(Ljava/lang/Object;)Ljava/lang/Object;"]]])
             (ARETURN)]
            
            [(METHOD [PUBLIC STATIC FINAL] "sigs~1" "(Ljava/lang/Object;)Ljava/lang/Object;")
             ["LOCAL 0: Object fdecl"]
             (ACONST_NULL)
             (ARETURN)]            
            [(METHOD [PUBLIC STATIC FINAL] "sigs" "()Ltinyclj/lang/StaticFn;")
             (LDC [:bsm-static-fn "_" "Ltinyclj/lang/StaticFn;"
                   [[STATIC . "sigs~1" "(Ljava/lang/Object;)Ljava/lang/Object;"]]])
             (ARETURN)]
            
            [(METHOD [PUBLIC STATIC FINAL BRIDGE VARARGS SYNTHETIC] "my-defn~4" "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;")
             #_["LOCAL 0: Object &form"]
             #_["LOCAL 1: Object &env"]
             #_["LOCAL 2: Object name"]
             #_["LOCAL 3: Object[] fdecl"]
             (ALOAD_0)
             (ALOAD_1)
             (ALOAD_2)
             (ALOAD_3)
             (INVOKESTATIC ArraySeq "create" "([Ljava/lang/Object;)Lclojure/lang/ArraySeq;")
             (INVOKESTATIC . "my-defn~4" "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Lclojure/lang/ISeq;)Ljava/lang/Object;")
             (ARETURN)]
            [(METHOD [PUBLIC STATIC FINAL] "my-defn~4" "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Lclojure/lang/ISeq;)Ljava/lang/Object;")
             ["LOCAL 0: Object &form"]
             ["LOCAL 1: Object &env"]
             ["LOCAL 2: Object name"]
             ["LOCAL 3: ISeq fdecl"]
             (LDC [:bsm-quote "symbol" "Lclojure/lang/Symbol;" ["def"]])
             (ALOAD_2)
             (ALOAD_3)
             (INVOKESTATIC . "sigs~1" "(Ljava/lang/Object;)Ljava/lang/Object;")
             (ACONST_NULL)
             (INVOKESTATIC RT "cons" "(Ljava/lang/Object;Ljava/lang/Object;)Lclojure/lang/ISeq;")
             (INVOKESTATIC RT "cons" "(Ljava/lang/Object;Ljava/lang/Object;)Lclojure/lang/ISeq;")
             (INVOKESTATIC RT "cons" "(Ljava/lang/Object;Ljava/lang/Object;)Lclojure/lang/ISeq;")
             (ARETURN)]
            [(METHOD [PUBLIC STATIC FINAL] "my-defn" "()Ltinyclj/lang/StaticFn;")
             (RuntimeVisibleAnnotations (Macro))
             (LDC [:bsm-static-fn "_" "Ltinyclj/lang/StaticFn;"
                   [[STATIC . "my-defn~4" "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;"]]])
             (ARETURN)]

            [(METHOD [PUBLIC STATIC] "<clinit>" "()V")
             (RETURN)]]
           
           [(CLASS Vx [PUBLIC ABSTRACT] "pkg/ns0/_12" nil "pkg/ns0/_11")
            [(METHOD [PUBLIC STATIC FINAL] "to-array" "()Ljava/lang/Object;")
             (ACONST_NULL)
             (ARETURN)]

            [(METHOD [PUBLIC STATIC] "<clinit>" "()V")
             (RETURN)]]

           [(CLASS Vx [PUBLIC ABSTRACT] "pkg/ns0/___" nil "pkg/ns0/_12")
            [(METHOD [PUBLIC STATIC FINAL SYNTHETIC] "requires~1" "()Ljava/lang/String;")
             (LDC "clojure.core")
             (ARETURN)]]]
         (nmsp '[(ns pkg.ns0)
                 ;; pkg/ns0/_10.class
                 (def cons (fn* cons ^clojure.lang.ISeq [x seq]
                                (. clojure.lang.RT (cons x seq))))
                 (def ^:macro loop (fn* loop [&form &env & decl]
                                        (cons 'loop* decl)))
                 (def ^:macro my-fn (fn* my-fn [&form &env & decl]
                                         (cons 'fn* decl)))
                 ;; pkg/ns0/_11.class
                 (def first (my-fn first [coll]
                                   (. clojure.lang.RT (first coll))))
                 (def sigs (my-fn sigs [fdecl]
                                  (loop [])))
                 (def ^:macro my-defn (my-fn my-defn [&form &env name & fdecl]
                                             (cons 'def
                                                   (cons name
                                                         (cons (sigs fdecl) nil)))))
                 ;; pkg/ns0/_12.class
                 (my-defn to-array ^Object/1 [coll]
                          (. clojure.lang.RT (toArray coll)))]))))

(deftest early-macro-reference
  (is (thrown-with-msg? Exception #"cannot define and expand macro in same top-level form"
                        (nmsp '[(ns pkg.ns0)
                                (let* []
                                  (def ^:macro one-macro
                                    (fn* one-macro ^int [&form &env]
                                         1))
                                  (def one (one-macro)))]))))
