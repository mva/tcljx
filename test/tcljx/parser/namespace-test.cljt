;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https:;;www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.parser.namespace-test
  (:require
   (tcljx [model :as model])
   (tcljx.parser [wrong :as wrong] [reader :as reader] [context :as context]
                 [form :as form] [namespace :as namespace])
   [tcljx.alpha.ptest :refer :all])
  (:import
   (tcljx.model NamespaceBuilder ProvidedNamespace NamespaceProvider
                CodeEmitter Entity Binding Expr Resolver ExprFactory Scope)
   (tcljx.parser.wrong WrongInfo)))

(deftype CodeData [form]
  java.lang.Record
  CodeEmitter
  (emit-code [_ xb line]
    (throw (UnsupportedOperationException.))))

(deftype ExprStub [^CodeEmitter data]
  Expr
  (entity [_]
    (when (instance? Entity data)
      data)))

(defn mk-code ^CodeEmitter [form]
  (CodeData. form))
(defn mk-expr ^Expr [code-or-form]
  (ExprStub. (cond-> code-or-form
               (not (instance? CodeEmitter code-or-form))
               (mk-code))))

(deftype BindingStub [^String namespace ^String name form]
  java.lang.Record
  CodeEmitter
  (emit-code [_ xb line]
    (throw (UnsupportedOperationException.)))
  Binding
  (bound-value [this]
    (mk-expr [:bound-value (model/binding-name this)])))

(defn class-data ^symbol [x]
  (if (nil? x) 'Null (symbol nil (.getSimpleName (class x)))))
(defn expr-data [^Expr x]
  (when (some? x)
    (let [data (.data ^ExprStub x)]
      (condp instance? data
        CodeData (.form ^CodeData data)
        BindingStub (.form ^BindingStub data)))))

(deftype ExprFactoryStub [^java.util.ArrayList forms]
  ExprFactory
  (new-array [_ n]
    (new ExprStub/1 n))
  (line-number [_ line value]
    (if (some? line)
      (mk-expr [:line-number line (expr-data value)])
      value))
  (constant [_ value]
    (mk-expr [:constant value (class-data value)]))
  (progn [_ xs]
    (mk-expr (reduce (comp conj expr-data) [:progn] xs)))
  
  (new-def-init [_ nmsp nm init]
    (let [ns-str (.ns-str nmsp)
          ns-sym (symbol ns-str nm)
          x (mk-expr (BindingStub. ns-str nm
                                   [:initialize-def ns-sym (expr-data init)]))]
      (.add-def nmsp nm (model/require-entity x))
      x))
  (new-def-alias [this nmsp nm other]
    (let [ns-str (.ns-str nmsp)
          ns-sym (symbol ns-str nm)
          x (mk-expr (BindingStub. ns-str nm
                                   [:alias-def ns-sym (model/binding-name other)]))]
      (.add-def nmsp nm (model/require-entity x))
      x))
  (assignment [_ bnd init]
    (mk-expr [:assignment (model/binding-name bnd) (expr-data init)]))
  
  (mk-expr [this form]
    (if (= form 'not-defined)
      (wrong/unresolved "undefined symbol " form)
      (mk-expr form))))

(deftype NmspBuilderStub [^String ns-str
                          ^java.util.ArrayList segment-forms
                          ^:unsynchronized-mutable ^map globals]
  Resolver
  (ns-str [_]
    ns-str)
  (lookup-def [_ nmsp nm]
    (if (or (nil? nmsp) (= nmsp ns-str))
      (.valAt globals nm nil)
      (assert false)))

  NamespaceBuilder
  (universe [_]
    (^NamespaceProvider fn [ns-strs]
     (let [a (new ProvidedNamespace/1 (alength ns-strs))]
       (dotimes [i (alength a)]
         (aset a i (ProvidedNamespace. (aget ns-strs i))))
       a)))
  (process-require [this require provided]
    (.add segment-forms
          (cond-> []
            true
            (conj :require (.ns-str require))
            
            (some? (.alias-str require))
            (conj :as (.alias-str require))

            true
            (conj :refer (or (.refer-strs require) :all))
            
            true
            (conj :rename (.rename-strs require))

            (not (empty? (.exclude-strs require)))
            (conj :exclude (.exclude-strs require))))
    this)
  (process-imports [this imports]
    (when-not (empty? imports)
      (.add segment-forms (vec (list* :imports imports))))
    this)
  (add-def [_ nm bnd]
    (set! globals (assoc globals nm bnd))
    bnd)

  (load-file [this path-str]
    (.add segment-forms [:load path-str])
    this)

  (process-init-form [this form]
    (let [ef (ExprFactoryStub. segment-forms)
          scope (form/mk-scope ef this {})]
      (.add segment-forms (expr-data (context/parse-form scope form)))
      this)))

(defn mk-nmsp-builder ^NamespaceBuilder []
  (let [ns-str "nmsp.expected"
        segment-forms (java.util.ArrayList.)
        globals {}]
    (NmspBuilderStub. ns-str segment-forms globals)))
(defn parse-forms-string ^vector [^String cs]
  (let [nmsp (mk-nmsp-builder)
        fb (reader/mk-form-builder cs nmsp)]
    (-> nmsp
        ^NmspBuilderStub (namespace/parse-top-level-forms 0 fb)
        (.segment-forms)
        (vec))))
(defn parse-forms ^vector [^vector formv]
  (let [nmsp (mk-nmsp-builder)]
    (-> ^NmspBuilderStub (reduce namespace/parse-top-level-form nmsp formv)
        (.segment-forms)
        (vec))))

(deftest parse-forms-test
  ;; use parse-forms-string, going through tcljx.parser.reader
  (is (= '[]
         (parse-forms-string "")))
  (is (= '[[:line-number 1 (some form)]]
         (parse-forms-string "(some form)")))
  ;; use parse-forms, relying on the host compiler's form processing
  (is (= '[]
         (parse-forms '[])))
  (is (= '[(some form)]
         (parse-forms '[(some form)]))))

;;; ------------------------------------------------------------------------

(deftest namespace-name-mismatch
  ;; use parse-forms-string, going through tcljx.parser.reader
  (is (thrown-with-msg? WrongInfo #"ns name mismatch"
                        (parse-forms-string "(ns ns.actual)")))
  ;; use parse-forms, relying on the host compiler's form processing
  (is (thrown-with-msg? WrongInfo #"ns name mismatch"
                        (parse-forms '[(ns ns.actual)]))))


(deftest ns-require-default-core-test
  ;; simple name
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]
           [:require "require.full.name" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require require.full.name))])))

  ;; prefix syntax with zero, one, or two names
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full)))])))
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]
           [:require "require.full.name-1" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1)))])))
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]
           [:require "require.full.name-1" :refer [] :rename {}]
           [:require "require.full.name-2" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1 name-2)))]))))

(deftest ns-require-refer-clojure-none-test
  ;; simple name
  (is (= '[[:require "require.full.name" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require require.full.name)
                          (:refer-clojure :none))])))
  (is (= '[[:require "require.full.name" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :none)
                          (:require require.full.name))])))

  ;; prefix syntax with zero, one, or two names
  (is (= '[]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full))
                          (:refer-clojure :none))])))
  (is (= '[[:require "require.full.name-1" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1))
                          (:refer-clojure :none))])))
  (is (= '[[:require "require.full.name-1" :refer [] :rename {}]
           [:require "require.full.name-2" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1 name-2))
                          (:refer-clojure :none))]))))

(deftest refer-clojure-test
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure))])))
  
  (is (= '[]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :none))])))
  
  (is (= '[[:require "tinyclj.core" :refer ["fn"] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :only [fn]))])))
  
  (is (= '[[:require "tinyclj.core" :refer :all :rename {} :exclude ["fn"]]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :exclude [fn]))])))
  
  (is (= '[[:require "tinyclj.core" :refer :all :rename {"fn" "ccfn"}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :rename {fn ccfn}))]))))


(deftest ns-require-test
  (is (= '[[:require "foo.bar" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require foo.bar)
                          (:refer-clojure :none))])))
  (is (= '[[:require "foo.bar" :as "bar.foo" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :as bar.foo])
                          (:refer-clojure :none))])))
  
  (is (= '[[:require "foo.bar" :refer :all :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :refer :all])
                          (:refer-clojure :none))])))
  (is (= '[[:require "foo.bar" :refer ["a" "b"] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :refer [a b]])
                          (:refer-clojure :none))])))
  
  (is (= '[[:require "foo.bar" :refer [] :rename {"a" "b"}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :rename {a b}])
                          (:refer-clojure :none))]))))

(deftest ns-import-test
  ;; imports are processed after all requires
  (is (= [[:require "tinyclj.core" :refer :all :rename {}]
          [:imports "foo.bar"]]
         (parse-forms '[(ns nmsp.expected
                          (:import foo.bar))])))

  (is (= [[:imports "foo.bar"]]
         (parse-forms '[(ns nmsp.expected
                          (:import (foo bar))
                          (:refer-clojure :none))])))
  (is (= []
         (parse-forms '[(ns nmsp.expected
                          (:import (foo))
                          (:refer-clojure :none))])))

  ;; source code order should be preserved
  (is (= [[:imports "foo.first" "foo.second" "bar.first" "bar.second"]]
         (parse-forms '[(ns nmsp.expected
                          (:import (foo first second)
                                   (bar first second))
                          (:refer-clojure :none))]))))

(deftest require-test
  (is (= [[:require "foo" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require foo)])))
  (is (= [[:require "bar" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require 'bar)])))
  (is (= [[:require "foo.bar" :refer ["a" "b"] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require (foo [bar :refer [a b]]))])))
  (is (= [[:require "foo.bar" :refer ["a" "b"] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require '(foo [bar :refer [a b]]))]))))

(deftest load-test
  (is (= []
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (load)])))
  (is (= [[:load "foo"]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (load "foo")])))
  (is (= [[:load "foo"]
          [:load "bar"]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (load "foo" "bar")]))))

(deftest basic-def-test
  ;; new def with init
  (is (= '[[:initialize-def nmsp.expected/x [:constant 1 Integer]]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)])))

  ;; new def without init followed by assignment
  (is (= '[[:initialize-def nmsp.expected/x nil]
           [:assignment nmsp.expected/x [:constant 1 Integer]]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x)
                        (def x 1)])))

  ;; new def with init followed by an aliasing def
  (is (= '[[:initialize-def nmsp.expected/x [:constant 1 Integer]]
           [:alias-def nmsp.expected/y nmsp.expected/x]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)
                        (def y x)])))
  (is (= '[[:initialize-def nmsp.expected/x [:constant 1 Integer]]
           [:alias-def nmsp.expected/y nmsp.expected/x]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)
                        (def y nmsp.expected/x)])))

  ;; new def with init followed by a use of the def-ed name
  (is (= '[[:initialize-def nmsp.expected/x [:constant 1 Integer]]
           [:bound-value nmsp.expected/x]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)
                        x]))))
