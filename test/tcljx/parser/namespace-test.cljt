;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https:;;www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.parser.namespace-test
  (:require
   (tcljx.data [wrong :as wrong] [model :as model])
   (tcljx.parser [reader :as reader] [context :as context]
                 [form :as form] [namespace :as namespace])
   [tcljx.alpha.ptest :refer :all])
  (:import
   (tcljx.data.model NamespaceBuilder ProvidedNamespace NamespaceProvider
                     CodeEmitter Entity Global Invocable Expr Exprs ExprFactory
                     Resolver Scope)
   (tcljx.data.wrong WrongInfo)))

(deftype EmitterData [form]
  java.lang.Record
  CodeEmitter
  (emit-insn* [_ xb line requested-type]
    (throw (UnsupportedOperationException.))))

(deftype ExprStub [^CodeEmitter data]
  Expr
  (entity [_]
    (when (instance? Entity data)
      data)))

(deftype ExprsStub [^Expr/1 xs]
  Exprs
  (length [_] (alength xs))
  (get [_ i] (aget xs i))
  (set [_ i x] (aset xs i x)))

(defn mk-code ^CodeEmitter [form]
  (EmitterData. form))
(defn mk-expr ^Expr [code-or-form]
  (ExprStub. (cond-> code-or-form
               (not (instance? CodeEmitter code-or-form))
               (mk-code))))

(deftype GlobalStub [^String namespace ^String name ^CodeEmitter bound-to]
  java.lang.Record
  CodeEmitter
  (emit-insn* [_ xb line requested-type]
    (throw (UnsupportedOperationException.)))
  Global
  (bound-value [this]
    (mk-expr [:bound-value (model/global-name this)])))

(defn class-data ^symbol [x]
  (if (nil? x) 'Null (symbol nil (.getSimpleName (class x)))))

(letfn [(emitter-data [^CodeEmitter x]
          (condp instance? x
            EmitterData (.form ^EmitterData x)
            GlobalStub (recur (.bound-to ^GlobalStub x))))]

  (defn expr-data [^Expr x]
    (when (some? x)
      (emitter-data (.data ^ExprStub x)))))

(defn exprs-data [^Exprs xs]
  (map #(expr-data (.get xs ^int %)) (range (.length xs))))

(deftype InvocableStub []
  java.lang.Record
  Invocable
  (invoke* [_ form args]
    (mk-expr (into [:invoke form] (exprs-data args)))))

(deftype ExprFactoryStub [^java.util.ArrayList forms]
  ExprFactory
  (new-exprs [_ n]
    (ExprsStub. (new ExprStub/1 n)))
  (line-number [_ line value]
    (if (some? line)
      (mk-expr [:line-number line (expr-data value)])
      value))
  
  (new-constant [_ expr-type value]
    (mk-expr [:constant value (class-data value)]))
  
  (progn-expr [_ xs x]
    (mk-expr (-> (reduce (comp conj expr-data) [:progn] xs)
                 (conj (expr-data x)))))
  (invoke [this form inv args]
    (.invoke* inv form args))
  
  (new-def-init [_ nmsp nm init]
    (let [ns-str (.ns-str nmsp)
          ns-sym (symbol ns-str nm)
          init (EmitterData. [:initialize-def ns-sym (expr-data init)])
          global (GlobalStub. ns-str nm init)]
      (.add-def nmsp nm global)
      (mk-expr global)))
  (new-def-alias [this nmsp nm other]
    (let [ns-str (.ns-str nmsp)
          ns-sym (symbol ns-str nm)
          init (EmitterData. [:alias-def ns-sym (model/global-name other)])
          x (mk-expr (GlobalStub. ns-str nm init))]
      (.add-def nmsp nm (model/require-entity x))
      x))
  (assignment [_ bnd init]
    (mk-expr [:assignment (model/global-name bnd) (expr-data init)]))
  
  (mk-expr [this form]
    (if (= form 'not-defined)
      (throw (wrong/info-unresolved "undefined symbol " form))
      (mk-expr form))))

(deftype NmspBuilderStub [^String ns-str
                          ^java.util.ArrayList segment-forms
                          ^:unsynchronized-mutable ^map globals]
  Resolver
  (ns-str [_]
    ns-str)
  (lookup-class [_ nm]
    nil)
  (lookup-def [_ nmsp nm]
    (if (or (nil? nmsp) (= nmsp ns-str))
      (.valAt globals nm nil)
      (assert false)))

  NamespaceBuilder
  (universe [_]
    (^NamespaceProvider fn [ns-strs]
     (let [a (new ProvidedNamespace/1 (alength ns-strs))]
       (dotimes [i (alength a)]
         (aset a i (ProvidedNamespace. (aget ns-strs i))))
       a)))
  (process-require [this require provided]
    (.add segment-forms
          (cond-> []
            true
            (conj :require (.ns-str require))
            
            (some? (.alias-str require))
            (conj :as (.alias-str require))

            true
            (conj :refer (or (.refer-strs require) :all))
            
            true
            (conj :rename (.rename-strs require))

            (not (empty? (.exclude-strs require)))
            (conj :exclude (.exclude-strs require))))
    this)
  (process-imports [this imports]
    (when-not (empty? imports)
      (.add segment-forms (vec (list* :imports imports))))
    this)
  (add-def [_ nm bnd]
    (set! globals (assoc globals nm bnd))
    bnd)

  (load-file [this path-str]
    (.add segment-forms [:load path-str])
    this)

  (process-init-form [this form]
    (let [ef (ExprFactoryStub. segment-forms)
          scope (form/mk-scope ef this {})]
      (.add segment-forms (expr-data (context/parse-form scope form)))
      this)))

(defn mk-nmsp-builder ^NamespaceBuilder []
  (let [ns-str "nmsp.expected"
        segment-forms (java.util.ArrayList.)
        globals {"some" (GlobalStub. ns-str "some" (InvocableStub.))
                 "form" (GlobalStub. ns-str "form" nil)}]
    (NmspBuilderStub. ns-str segment-forms globals)))
(defn parse-forms-string ^vector [^String cs]
  (let [nmsp (mk-nmsp-builder)
        fb (reader/mk-form-builder cs nmsp)]
    (-> nmsp
        ^NmspBuilderStub (namespace/parse-top-level-forms 0 fb)
        (.segment-forms)
        (vec))))
(defn parse-forms ^vector [^vector formv]
  (let [nmsp (mk-nmsp-builder)]
    (-> ^NmspBuilderStub (reduce namespace/parse-top-level-form nmsp formv)
        (.segment-forms)
        (vec))))

(deftest parse-forms-test
  ;; use parse-forms-string, going through tcljx.parser.reader
  (is (= '[]
         (parse-forms-string "")))
  (is (= '[[:line-number 1
            [:invoke (some form) [:bound-value nmsp.expected/form]]]]
         (parse-forms-string "(some form)")))
  ;; use parse-forms, relying on the host compiler's form processing
  (is (= '[]
         (parse-forms '[])))
  (is (= '[[:invoke (some form) [:bound-value nmsp.expected/form]]]
         (parse-forms '[(some form)]))))

;;; ------------------------------------------------------------------------

(deftest namespace-name-mismatch
  ;; use parse-forms-string, going through tcljx.parser.reader
  (is (thrown-with-msg? WrongInfo #"ns name mismatch"
                        (parse-forms-string "(ns ns.actual)")))
  ;; use parse-forms, relying on the host compiler's form processing
  (is (thrown-with-msg? WrongInfo #"ns name mismatch"
                        (parse-forms '[(ns ns.actual)]))))


(deftest ns-require-default-core-test
  ;; simple name
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]
           [:require "require.full.name" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require require.full.name))])))

  ;; prefix syntax with zero, one, or two names
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full)))])))
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]
           [:require "require.full.name-1" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1)))])))
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]
           [:require "require.full.name-1" :refer [] :rename {}]
           [:require "require.full.name-2" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1 name-2)))]))))

(deftest ns-require-refer-clojure-none-test
  ;; simple name
  (is (= '[[:require "require.full.name" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require require.full.name)
                          (:refer-clojure :none))])))
  (is (= '[[:require "require.full.name" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :none)
                          (:require require.full.name))])))

  ;; prefix syntax with zero, one, or two names
  (is (= '[]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full))
                          (:refer-clojure :none))])))
  (is (= '[[:require "require.full.name-1" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1))
                          (:refer-clojure :none))])))
  (is (= '[[:require "require.full.name-1" :refer [] :rename {}]
           [:require "require.full.name-2" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1 name-2))
                          (:refer-clojure :none))]))))

(deftest refer-clojure-test
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure))])))
  
  (is (= '[]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :none))])))
  
  (is (= '[[:require "tinyclj.core" :refer ["fn"] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :only [fn]))])))
  
  (is (= '[[:require "tinyclj.core" :refer :all :rename {} :exclude ["fn"]]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :exclude [fn]))])))
  
  (is (= '[[:require "tinyclj.core" :refer :all :rename {"fn" "ccfn"}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :rename {fn ccfn}))]))))


(deftest ns-require-test
  (is (= '[[:require "foo.bar" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require foo.bar)
                          (:refer-clojure :none))])))
  (is (= '[[:require "foo.bar" :as "bar.foo" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :as bar.foo])
                          (:refer-clojure :none))])))
  
  (is (= '[[:require "foo.bar" :refer :all :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :refer :all])
                          (:refer-clojure :none))])))
  (is (= '[[:require "foo.bar" :refer ["a" "b"] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :refer [a b]])
                          (:refer-clojure :none))])))
  
  (is (= '[[:require "foo.bar" :refer [] :rename {"a" "b"}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :rename {a b}])
                          (:refer-clojure :none))]))))

(deftest ns-import-test
  ;; imports are processed after all requires
  (is (= [[:require "tinyclj.core" :refer :all :rename {}]
          [:imports "foo.bar"]]
         (parse-forms '[(ns nmsp.expected
                          (:import foo.bar))])))

  (is (= [[:imports "foo.bar"]]
         (parse-forms '[(ns nmsp.expected
                          (:import (foo bar))
                          (:refer-clojure :none))])))
  (is (= []
         (parse-forms '[(ns nmsp.expected
                          (:import (foo))
                          (:refer-clojure :none))])))

  ;; source code order should be preserved
  (is (= [[:imports "foo.first" "foo.second" "bar.first" "bar.second"]]
         (parse-forms '[(ns nmsp.expected
                          (:import (foo first second)
                                   (bar first second))
                          (:refer-clojure :none))]))))

(deftest require-test
  (is (= [[:require "foo" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require foo)])))
  (is (= [[:require "bar" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require 'bar)])))
  (is (= [[:require "foo.bar" :refer ["a" "b"] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require (foo [bar :refer [a b]]))])))
  (is (= [[:require "foo.bar" :refer ["a" "b"] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require '(foo [bar :refer [a b]]))]))))

(deftest load-test
  (is (= []
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (load)])))
  (is (= [[:load "foo"]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (load "foo")])))
  (is (= [[:load "foo"]
          [:load "bar"]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (load "foo" "bar")]))))

(deftest basic-def-test
  ;; new def with init
  (is (= '[[:initialize-def nmsp.expected/x [:constant 1 Integer]]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)])))

  ;; new def without init followed by assignment
  (is (= '[[:initialize-def nmsp.expected/x nil]
           [:assignment nmsp.expected/x [:constant 1 Integer]]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x)
                        (def x 1)])))

  ;; new def with init followed by an aliasing def
  (is (= '[[:initialize-def nmsp.expected/x [:constant 1 Integer]]
           [:alias-def nmsp.expected/y nmsp.expected/x]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)
                        (def y x)])))
  (is (= '[[:initialize-def nmsp.expected/x [:constant 1 Integer]]
           [:alias-def nmsp.expected/y nmsp.expected/x]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)
                        (def y nmsp.expected/x)])))

  ;; new def with init followed by a use of the def-ed name
  (is (= '[[:initialize-def nmsp.expected/x [:constant 1 Integer]]
           [:bound-value nmsp.expected/x]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)
                        x]))))
