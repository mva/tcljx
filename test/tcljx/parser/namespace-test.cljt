;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https:;;www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.parser.namespace-test
  (:require
   (tcljx.data [wrong :as wrong] [context :as context] [model :as model])
   (tcljx.parser [reader :as reader] [form :as form] [namespace :as namespace])
   [tcljx.alpha.ptest :refer :all])
  (:import
   (tcljx.data.model NamespaceBuilder ProvidedNamespace NamespaceProvider
                     CodeEmitter Entity Binding Invocable Expr Exprs ExprFactory
                     Resolver Scope)
   (tcljx.data.wrong WrongInfo)))

(deftype EntityData [form]
  java.lang.Record
  tcljx.data.model.GlobalEntity
  Entity
  (emit-insn* [_ xb consumed-type then-leave?]
    (throw (UnsupportedOperationException.))))

(deftype ExprStub [^CodeEmitter data]
  Expr
  (emitter [_]
    data))

(deftype ExprsStub [^Expr/1 xs]
  Exprs
  (length [_] (alength xs))
  (get [_ i] (aget xs i))
  (set [_ i x] (aset xs i x)))

(defn mk-entity ^CodeEmitter [form]
  (EntityData. form))
(defn mk-expr ^Expr [code-or-form]
  (ExprStub. (cond-> code-or-form
               (not (instance? CodeEmitter code-or-form))
               (mk-entity))))
(def expr-empty (mk-expr [:empty-expr]))

(deftype BindingStub [^String namespace ^String name
                      ^Entity bound-to ^Expr provided-value]
  java.lang.Record
  CodeEmitter
  (emit-insn* [_ xb consumed-type then-leave?]
    (throw (UnsupportedOperationException.))))

(defn class-data ^symbol [x]
  (if (nil? x) 'Null (symbol nil (.getSimpleName (class x)))))
(defn emitter-data [^CodeEmitter x]
  (condp instance? x
    EntityData (.form ^EntityData x)
    BindingStub [:binding
                 (emitter-data (.bound-to ^BindingStub x))
                 (when-some [v (.provided-value ^BindingStub x)]
                   (emitter-data (.data ^ExprStub v)))]))
(defn expr-data [^Expr x]
  (when (some? x)
    (emitter-data (.data ^ExprStub x))))

(defn exprs-data [^Exprs xs]
  (map #(expr-data (.get xs ^int %)) (range (.length xs))))

(deftype InvocableStub []
  java.lang.Record
  Invocable
  (invoke* [_ fctx form args]
    (mk-expr (into [:invoke (context/fctx-line fctx) form] (exprs-data args)))))

(deftype ExprFactoryStub [^java.util.ArrayList forms]
  ExprFactory
  (empty-expr [_]
    expr-empty)
  (new-exprs [_ n]
    (ExprsStub. (new ExprStub/1 n)))
  (value-of [_ ent form]
    (mk-expr [:value-of (emitter-data ent)]))
  (constant-entity [_ value type]
    (mk-entity [:constant value (class-data value)]))
  
  (progn-expr [_ xs x]
    (mk-expr (-> (reduce (comp conj expr-data) [:progn] xs)
                 (conj (expr-data x)))))
  (invoke [this fctx form inv args]
    (.invoke* inv fctx form args))
  
  (assignment [_ ent init]
    (mk-expr [:assignment (emitter-data ent) (expr-data init)]))
  
  (mk-expr [this form]
    (if (= form 'not-defined)
      (throw (wrong/info-unresolved form))
      (mk-expr form))))

(deftype NmspBuilderStub [^String ns-str
                          ^java.util.ArrayList segment-forms
                          ^:unsynchronized-mutable ^map globals]
  Resolver
  (ns-str [_]
    ns-str)
  (lookup-class [_ nm]
    nil)
  (lookup-def [_ nmsp nm]
    (if (or (nil? nmsp) (= nmsp ns-str))
      (.valAt globals nm nil)
      (assert false)))

  NamespaceBuilder
  (universe [_]
    (^NamespaceProvider fn [ns-strs]
     (let [a (new ProvidedNamespace/1 (alength ns-strs))]
       (dotimes [i (alength a)]
         (aset a i (ProvidedNamespace. (aget ns-strs i))))
       a)))
  (process-require [this require provided]
    (.add segment-forms
          (cond-> []
            true
            (conj :require (.ns-str require))
            
            (some? (.alias-str require))
            (conj :as (.alias-str require))

            true
            (conj :refer (or (.refer-strs require) :all))
            
            true
            (conj :rename (.rename-strs require))

            (not (empty? (.exclude-strs require)))
            (conj :exclude (.exclude-strs require))))
    this)
  (process-imports [this imports]
    (when-not (empty? imports)
      (.add segment-forms (vec (list* :imports imports))))
    this)
  (new-def-init [this nm init]
    (let [ns-sym (symbol ns-str nm)
          ent (EntityData. [:entity ns-sym])]
      (set! globals (assoc globals nm ent))
      (mk-expr (BindingStub. ns-str nm ent init))))
  (new-def-alias [this nm other]
    (let [ns-sym (symbol ns-str nm)
          ent (EntityData. [:alias-def ns-sym (emitter-data other)])]
      (set! globals (assoc globals nm ent))
      (mk-expr (BindingStub. ns-str nm ent nil))))

  (load-file [this path-str]
    (.add segment-forms [:load path-str])
    this)

  (process-init-form [this fctx form]
    (let [ef (ExprFactoryStub. segment-forms)
          scope (form/mk-scope ef this {})]
      (.add segment-forms (expr-data (context/parse-form scope fctx form)))
      this)))

(defn mk-nmsp-builder ^NamespaceBuilder []
  (let [ns-str "nmsp.expected"
        segment-forms (java.util.ArrayList.)
        globals {"some" (InvocableStub.)
                 "form" (EntityData. 'nmsp.expected/form)}]
    (NmspBuilderStub. ns-str segment-forms globals)))
(defn parse-forms-string ^vector [^String cs]
  (let [nmsp (mk-nmsp-builder)
        fb (reader/mk-form-builder cs nmsp)]
    (-> nmsp
        ^NmspBuilderStub (namespace/parse-top-level-forms 0 fb)
        (.segment-forms)
        (vec))))
(defn parse-forms ^vector [^vector formv]
  (loop [acc (mk-nmsp-builder), forms (seq formv)]
    (if (nil? forms)
      (vec (NmspBuilderStub/.segment-forms acc))
      (recur (namespace/parse-top-level-form acc context/fctx-initial (first forms))
             (next forms)))))

(deftest parse-forms-test
  ;; use parse-forms-string, going through tcljx.parser.reader
  (is (= '[]
         (parse-forms-string "")))
  (is (= '[[:invoke 1 (some form) [:value-of nmsp.expected/form]]]
         (parse-forms-string "(some form)")))
  ;; use parse-forms, relying on the host compiler's form processing
  (is (= '[]
         (parse-forms '[])))
  (is (= '[[:invoke 0 (some form) [:value-of nmsp.expected/form]]]
         (parse-forms '[(some form)]))))

;;; ------------------------------------------------------------------------

(deftest namespace-name-mismatch
  ;; use parse-forms-string, going through tcljx.parser.reader
  (is (thrown-with-msg? WrongInfo #"ns name mismatch"
                        (parse-forms-string "(ns ns.actual)")))
  ;; use parse-forms, relying on the host compiler's form processing
  (is (thrown-with-msg? WrongInfo #"ns name mismatch"
                        (parse-forms '[(ns ns.actual)]))))


(deftest ns-require-default-core-test
  ;; simple name
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]
           [:require "require.full.name" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require require.full.name))])))

  ;; prefix syntax with zero, one, or two names
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full)))])))
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]
           [:require "require.full.name-1" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1)))])))
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]
           [:require "require.full.name-1" :refer [] :rename {}]
           [:require "require.full.name-2" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1 name-2)))]))))

(deftest ns-require-refer-clojure-none-test
  ;; simple name
  (is (= '[[:require "require.full.name" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require require.full.name)
                          (:refer-clojure :none))])))
  (is (= '[[:require "require.full.name" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :none)
                          (:require require.full.name))])))

  ;; prefix syntax with zero, one, or two names
  (is (= '[]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full))
                          (:refer-clojure :none))])))
  (is (= '[[:require "require.full.name-1" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1))
                          (:refer-clojure :none))])))
  (is (= '[[:require "require.full.name-1" :refer [] :rename {}]
           [:require "require.full.name-2" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require (require.full name-1 name-2))
                          (:refer-clojure :none))]))))

(deftest refer-clojure-test
  (is (= '[[:require "tinyclj.core" :refer :all :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure))])))
  
  (is (= '[]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :none))])))
  
  (is (= '[[:require "tinyclj.core" :refer ["fn"] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :only [fn]))])))
  
  (is (= '[[:require "tinyclj.core" :refer :all :rename {} :exclude ["fn"]]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :exclude [fn]))])))
  
  (is (= '[[:require "tinyclj.core" :refer :all :rename {"fn" "ccfn"}]]
         (parse-forms '[(ns nmsp.expected
                          (:refer-clojure :rename {fn ccfn}))]))))


(deftest ns-require-test
  (is (= '[[:require "foo.bar" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require foo.bar)
                          (:refer-clojure :none))])))
  (is (= '[[:require "foo.bar" :as "bar.foo" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :as bar.foo])
                          (:refer-clojure :none))])))
  
  (is (= '[[:require "foo.bar" :refer :all :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :refer :all])
                          (:refer-clojure :none))])))
  (is (= '[[:require "foo.bar" :refer ["a" "b"] :rename {}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :refer [a b]])
                          (:refer-clojure :none))])))
  
  (is (= '[[:require "foo.bar" :refer [] :rename {"a" "b"}]]
         (parse-forms '[(ns nmsp.expected
                          (:require [foo.bar :rename {a b}])
                          (:refer-clojure :none))]))))

(deftest ns-import-test
  ;; imports are processed after all requires
  (is (= [[:require "tinyclj.core" :refer :all :rename {}]
          [:imports "foo.bar"]]
         (parse-forms '[(ns nmsp.expected
                          (:import foo.bar))])))

  (is (= [[:imports "foo.bar"]]
         (parse-forms '[(ns nmsp.expected
                          (:import (foo bar))
                          (:refer-clojure :none))])))
  (is (= []
         (parse-forms '[(ns nmsp.expected
                          (:import (foo))
                          (:refer-clojure :none))])))

  ;; source code order should be preserved
  (is (= [[:imports "foo.first" "foo.second" "bar.first" "bar.second"]]
         (parse-forms '[(ns nmsp.expected
                          (:import (foo first second)
                                   (bar first second))
                          (:refer-clojure :none))]))))

(deftest require-test
  (is (= [[:require "foo" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require foo)])))
  (is (= [[:require "bar" :refer [] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require 'bar)])))
  (is (= [[:require "foo.bar" :refer ["a" "b"] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require (foo [bar :refer [a b]]))])))
  (is (= [[:require "foo.bar" :refer ["a" "b"] :rename {}]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (require '(foo [bar :refer [a b]]))]))))

(deftest load-test
  (is (= []
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (load)])))
  (is (= [[:load "foo"]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (load "foo")])))
  (is (= [[:load "foo"]
          [:load "bar"]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (load "foo" "bar")]))))

(deftest basic-def-test
  ;; new def with init
  (is (= '[[:binding [:entity nmsp.expected/x] [:value-of [:constant 1 Integer]]]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)])))

  ;; new def without init followed by assignment
  (is (= '[[:binding [:entity nmsp.expected/x] [:empty-expr]]
           [:assignment [:entity nmsp.expected/x]
            [:value-of [:constant 1 Integer]]]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x)
                        (def x 1)])))

  ;; new def with init followed by an aliasing def
  (is (= '[[:binding [:entity nmsp.expected/x] [:value-of [:constant 1 Integer]]]
           [:binding [:alias-def nmsp.expected/y [:entity nmsp.expected/x]] nil]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)
                        (def y x)])))
  (is (= '[[:binding [:entity nmsp.expected/x] [:value-of [:constant 1 Integer]]]
           [:binding [:alias-def nmsp.expected/y [:entity nmsp.expected/x]] nil]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)
                        (def y nmsp.expected/x)])))

  ;; new def with init followed by a use of the def-ed name
  (is (= '[[:binding [:entity nmsp.expected/x] [:value-of [:constant 1 Integer]]]
           [:value-of [:entity nmsp.expected/x]]]
         (parse-forms '[(ns nmsp.expected (:refer-clojure :none))
                        (def x 1)
                        x]))))
