;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.nmspgen.invoke-test
  (:require
   [tcljx.nmspgen.bootstrap :refer [asm-expr]]
   [tcljx.alpha.ptest :refer :all])
  (:import (tcljx.data.error WrongInfo)))

(deftest constructor-invoke-test
  (is (= '[(NEW HashMap) (DUP)
           (INVOKESPECIAL HashMap "<init>" "()V")
           (ARETURN)]
         (asm-expr (new java.util.HashMap))))

  (is (= '[(NEW HashMap) (DUP)
           (INVOKESPECIAL HashMap "<init>" "()V")
           (ARETURN)]
         (asm-expr (. java.util.HashMap new)))))

(deftest static-field-test
  (is (= '[(GETSTATIC Math "PI" "D")
           (DRETURN)]
         (asm-expr (. java.lang.Math PI)))))

(deftest static-invoke-test
  (is (= '[(INVOKESTATIC System "getProperties"
                         "()Ljava/util/Properties;")
           (ARETURN)]
         (asm-expr (. java.lang.System getProperties))))
  (is (= '[(LDC "foo")
           (INVOKESTATIC System "getProperty"
                         "(Ljava/lang/String;)Ljava/lang/String;")
           (ARETURN)]
         (asm-expr (. java.lang.System getProperty "foo"))))
  (is (= '[(ACONST_NULL)
           (INVOKESTATIC System "getProperty"
                         "(Ljava/lang/String;)Ljava/lang/String;")
           (ARETURN)]
         (asm-expr (. java.lang.System getProperty nil))))

  (is (= '[(INVOKESTATIC MethodHandles "lookup"
                         "()Ljava/lang/invoke/MethodHandles$Lookup;")
           (ARETURN)]
         (asm-expr (. java.lang.invoke.MethodHandles lookup))))
  (is (= '[["LOCAL 0: MethodHandles$Lookup l"]
           (ALOAD_0)
           (INVOKESTATIC RT "setCoreLookup"
                         "(Ljava/lang/invoke/MethodHandles$Lookup;)V")
           (ACONST_NULL)
           (ARETURN)]
         (asm-expr [^java.lang.invoke.MethodHandles$Lookup l]
                   (. tinyclj.lang.RT setCoreLookup l))))

  ;; Math/log takes a double and requires implicit conversion from int
  (is (= '[[LDC2_W 123.0]
           (INVOKESTATIC Math "log" "(D)D")
           (DRETURN)]
         (asm-expr (. java.lang.Math log 123))))
  (is (thrown-with-msg? WrongInfo #"no static method matching"
                        (asm-expr (. java.lang.Math log true))))
  (is (thrown-with-msg? WrongInfo #"no static method matching"
                        (asm-expr (. java.lang.Math log \newline))))
  
  ;; Math/max has four paired overloads
  (is (= '[(ICONST_1) (ICONST_2)
           (INVOKESTATIC Math "max" "(II)I")
           (IRETURN)]
         (asm-expr (. java.lang.Math max 1 2))))
  (is (= '[(LCONST_1) (LDC2_W 2l)
           (INVOKESTATIC Math "max" "(JJ)J")
           (LRETURN)]
         (asm-expr (. java.lang.Math max 1l 2l))))
  (is (= '[(FCONST_1) (FCONST_2)
           (INVOKESTATIC Math "max" "(FF)F")
           (FRETURN)]
         (asm-expr (. java.lang.Math max 1.0f 2.0f))))
  (is (= '[(DCONST_1) (LDC2_W 2.0)
           (INVOKESTATIC Math "max" "(DD)D")
           (DRETURN)]
         (asm-expr (. java.lang.Math max 1.0 2.0))))

  ;; varargs call with box of primitive int passed via the `args`
  ;; array of type `Object...`
  (is (= '[(LDC "%d")
           (ICONST_1)
           (ANEWARRAY "Object[]")
           (DUP)
           (ICONST_0) (BIPUSH 123)
           (INVOKESTATIC Integer "valueOf" "(I)Ljava/lang/Integer;")
           (AASTORE)
           (INVOKESTATIC String "format"
                         "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;")
           (ARETURN)]
         (asm-expr (. String format "%d" 123)))))


(deftest virtual-field-test
  (is (= '[["LOCAL 0: Point obj"]
           (ALOAD_0)
           (GETFIELD Point "x" "I")
           (IRETURN)]
         (asm-expr [^java.awt.Point obj] (. obj x)))))

;;; Note: In general, the owner of an invoke instruction is the class
;;; from which the resolve process started, *not* the class that
;;; defines the invoked method.  The same is true for field
;;; instructions, when e.g. a static final field of a base class is
;;; resolved using one of its extending classes.
(deftest virtual-invoke-test
  (is (= '[(LDC "foo")
           (INVOKEVIRTUAL String "toUpperCase" "()Ljava/lang/String;")
           (ARETURN)]
         (asm-expr (. "foo" toUpperCase))))
  (is (= '[(LDC Class)
           (INVOKEVIRTUAL Class "getName" "()Ljava/lang/String;")
           (ARETURN)]
         (asm-expr (. (identity Class) getName))))

  ;; varargs call: no `parameterTypes` and three `parameterTypes`
  (is (= '[(LDC Class)
           (LDC "foo")
           (ICONST_0) (ANEWARRAY "Class[]")
           (INVOKEVIRTUAL Class "getMethod"
                          "(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;")
           (ARETURN)]
         (asm-expr (. (identity Class) getMethod "foo"))))
  (is (= '[(LDC Class)
           (ICONST_3) (ANEWARRAY "Class[]")
           (DUP) (ICONST_0) (LDC String) (AASTORE)
           (DUP) (ICONST_1) (LDC String) (AASTORE)
           (DUP) (ICONST_2) (LDC String) (AASTORE)
           (INVOKEVIRTUAL Class "getConstructor"
                          "([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;")
           (ARETURN)]
         (asm-expr (. (identity Class) getConstructor String String String))))

  ;; `withInterfaceSymbols` with an `Object` argument is ambiguous in
  ;; Clojure (but not in Java!), and resolved to a single method with
  ;; `List`, `ClassDesc`, or an empty argument list
  (is (thrown-with-msg? WrongInfo #"multiple virtual methods match"
                        (asm-expr [^java.lang.classfile.ClassBuilder xb]
                                  (. xb withInterfaceSymbols (new Object)))))
  (is (= '[["LOCAL 0: ClassBuilder obj"]
           ["LOCAL 1: List arg1"]
           (ALOAD_0)
           (ALOAD_1)
           (INVOKEINTERFACE ClassBuilder "withInterfaceSymbols"
                            "(Ljava/util/List;)Ljava/lang/classfile/ClassBuilder;"
                            :itf)
           (ARETURN)]
         (asm-expr [^java.lang.classfile.ClassBuilder obj
                    ^java.util.List arg1]
                   (. obj withInterfaceSymbols arg1))))
  (is (= '[["LOCAL 0: ClassBuilder obj"]
           ["LOCAL 1: ClassDesc[] arg1"]
           (ALOAD_0)
           (ALOAD_1)
           (INVOKEINTERFACE ClassBuilder "withInterfaceSymbols"
                            "([Ljava/lang/constant/ClassDesc;)Ljava/lang/classfile/ClassBuilder;"
                            :itf)
           (ARETURN)]
         (asm-expr [^java.lang.classfile.ClassBuilder obj
                    ^java.lang.constant.ClassDesc/1 arg1]
                   (. obj withInterfaceSymbols arg1))))
  (is (= '[["LOCAL 0: ClassBuilder xb"]
           (ALOAD_0)
           (ICONST_0) (ANEWARRAY "ClassDesc[]")
           (INVOKEINTERFACE ClassBuilder "withInterfaceSymbols"
                            "([Ljava/lang/constant/ClassDesc;)Ljava/lang/classfile/ClassBuilder;"
                            :itf)
           (ARETURN)]
         (asm-expr [^java.lang.classfile.ClassBuilder xb]
                   (. xb withInterfaceSymbols)))))

(deftest interface-varargs-clash-test
  ;; this should resolve to the varargs method
  ;; static MethodTypeDesc of(ClassDesc returnDesc, ClassDesc... paramDescs)
  (is (= '[(GETSTATIC ConstantDescs "CD_String"
                      "Ljava/lang/constant/ClassDesc;")
           (ICONST_1)
           (ANEWARRAY "ClassDesc[]") (DUP) (ICONST_0)
           (GETSTATIC ConstantDescs "CD_String"
                      "Ljava/lang/constant/ClassDesc;")
           (AASTORE)
           (INVOKESTATIC MethodTypeDesc "of"
                         "(Ljava/lang/constant/ClassDesc;[Ljava/lang/constant/ClassDesc;)Ljava/lang/constant/MethodTypeDesc;"
                         :itf)
           (ARETURN)]
         (asm-expr (. java.lang.constant.MethodTypeDesc of
                      java.lang.constant.ConstantDescs/CD_String
                      java.lang.constant.ConstantDescs/CD_String))))
  
  ;; this should resolve to the List method
  ;; static MethodTypeDesc of(ClassDesc returnDesc, List<ClassDesc> paramDescs)
  (is (= '[(GETSTATIC ConstantDescs "CD_String"
                      "Ljava/lang/constant/ClassDesc;")
           (INVOKESTATIC List "of" "()Ljava/util/List;" :itf)
           (INVOKESTATIC MethodTypeDesc "of"
                         "(Ljava/lang/constant/ClassDesc;Ljava/util/List;)Ljava/lang/constant/MethodTypeDesc;"
                         :itf)
           (ARETURN)]
         (asm-expr (. java.lang.constant.MethodTypeDesc of
                      java.lang.constant.ConstantDescs/CD_String
                      (java.util.List/of))))))

(deftest compatible-args-test
  ;; the "dominate" checks must establish any precondition required by
  ;; `alignment` before calling it
  (is (= '[["LOCAL 0: PosixFilePermission perm"]
           (ALOAD_0)
           (ALOAD_0)
           (ALOAD_0)
           (INVOKESTATIC Set "of"
                         "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Set;"
                         :itf)
           (ARETURN)]
         (asm-expr [^java.nio.file.attribute.PosixFilePermission perm]
                   (. java.util.Set of perm perm perm)))))

(deftest one-arg-vs-one-plus-varargs-test
  (is (= '[["LOCAL 0: Path path"]
           (ALOAD_0)
           (LDC "foo")
           (INVOKEINTERFACE Path "resolve"
                            "(Ljava/lang/String;)Ljava/nio/file/Path;"
                            :itf)
           (ARETURN)]
         (asm-expr [^java.nio.file.Path path]
                   (. path resolve "foo"))))
  (is (= '[["LOCAL 0: Path path"]
           (ALOAD_0)
           (LDC "foo")
           (ICONST_1) (ANEWARRAY "String[]")
           (DUP) (ICONST_0) (LDC "bar") (AASTORE)
           (INVOKEINTERFACE Path "resolve"
                            "(Ljava/lang/String;[Ljava/lang/String;)Ljava/nio/file/Path;"
                            :itf)
           (ARETURN)]
         (asm-expr [^java.nio.file.Path path]
                   (. path resolve "foo" "bar")))))

(deftest void-argument-test
  (is (= '[(INVOKESTATIC System "gc" "()V")
           (DCONST_0)
           (INVOKESTATIC Math "log" "(D)D")
           (DRETURN)]
         (asm-expr (. java.lang.Math log (System/gc)))))
  (is (= '[(INVOKESTATIC System "gc" "()V")
           (ACONST_NULL)
           (INVOKESTATIC Objects "toString"
                         "(Ljava/lang/Object;)Ljava/lang/String;")
           (ARETURN)]
         (asm-expr (. java.util.Objects toString (System/gc))))))

;;; Argument nil is treated specially when looking for matching
;;; methods.  Instead of satisfying a primitive parameter by unboxing
;;; nil (which must fail at runtime), treat such a constellation as a
;;; mismatch similar to incompatible types.
(deftest nil-argument-to-primitive-parameter-test
  ;; direct unboxing: Integer to int
  (is (= '[["LOCAL 0: Integer x"]
           (ALOAD_0)
           (INVOKEVIRTUAL Integer "intValue" "()I")
           (INVOKESTATIC Integer "bitCount" "(I)I")
           (IRETURN)]
         (asm-expr [^Integer x] (. java.lang.Integer bitCount x))))
  ;; indirect unboxing: Object to int
  (is (= '[["LOCAL 0: Object x"]
           (ALOAD_0)
           (CHECKCAST Integer)
           (INVOKEVIRTUAL Integer "intValue" "()I")
           (INVOKESTATIC Integer "bitCount" "(I)I")
           (IRETURN)]
         (asm-expr [^Object x] (. java.lang.Integer bitCount x))))
  
  ;; single candidate: argument is of type int
  (is (thrown-with-msg? WrongInfo #"no static method matching"
                          (asm-expr (. java.lang.Integer bitCount nil))))
  ;; overloaded: argument is either int, long, float, or double
  (is (thrown-with-msg? WrongInfo #"no static method matching"
                        (asm-expr (. java.lang.Math abs nil)))))

;;; Clojure 1.12.0-alpha6 has this to say: "Note: Static fields are
;;; values and should be referenced without parens unless they are
;;; intended as function calls, e.g (System/out) should be
;;; System/out. Future Clojure releases will treat the fieldâ€™s value
;;; as something invokable and invoke it."
;;;
;;; Dot form translation is unchanged, but the interpretation of
;;; `Classname/member` is adjusted accordingly.
(deftest invoke-static-field-test
  (is (thrown-with-msg? AssertionError #"Assert failed: not yet implemented"
                        (asm-expr (System/out))))
  #_(is (thrown-with-msg? WrongInfo #"does not implement `IFn`"
                          (asm-expr (System/out)))))
