;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.alpha.pp.ansi
  (:require (tcljx.alpha.pp [style :as style] [styled :as styled]))
  (:import (tcljx.alpha.pp.styled StyledWriter)
           (java.io Writer)))

;;; A writer that translates style directives into ANSI escape codes.
;;; Every call to append compares the given style with the one active
;;; for the downstream terminal.  If the two differ, the delta is
;;; computed and additional text is emitted that changes the current
;;; output style to the one used by the new text.

;;; https://en.wikipedia.org/wiki/ANSI_escape_code#Select_Graphic_Rendition_parameters
(defn- apply-style ^long [^Writer w ^long active-style ^long style]
  (letfn [(sep ^void []
            (.append w \;))
          (arg
            (^void [^int n]
             (.append w (Integer/toString n)))
            (^void [^int n ^int arg-1 ^int arg-2]
             (arg n) (sep) (arg arg-1) (sep) (arg arg-2))
            (^void [^int n ^int arg-1 ^int arg-2 ^int arg-3 ^int arg-4]
             (arg n) (sep) (arg arg-1) (sep) (arg arg-2)
             (sep) (arg arg-3) (sep) (arg arg-4)))
          (apply-intensity ^long []
            (arg (if (zero? (style/extract-bold style))
                   (case (style/extract-intensity style)
                     (#_intensity-normal 0) 22
                     (#_intensity-bright 1) 1
                     (#_intensity-faint 2) 2)
                   1))
            (bit-or style/mask-intensity style/mask-bold))
          (apply-flag ^long [^long mask ^int n-on ^int n-off]
            (arg (if (zero? (style/extract style mask)) n-off n-on))
            mask)
          (apply-color ^long [^int offset ^int style-color]
            (let [v (style/color-value style-color)
                  map-bright (fn ^int [^int palette-id]
                               (+ (bit-and 2r111 palette-id)
                                  (-> (bit-shift-right palette-id 3)
                                      (bit-and 2r1)
                                      (* 60))))]
              (case (style/color-mode style-color)
                (#_color-mode-default 0)
                (arg (+ offset 9))
                (#_color-mode-palette-4bit 1)
                (arg (+ offset (map-bright v)))
                (#_color-mode-palette-8bit 2)
                (arg (+ offset 8) 5 v)
                (#_color-mode-rgb -1)
                (arg (+ offset 8) 2 (style/rgb-red v) (style/rgb-green v)
                     (style/rgb-blue v)))))
          (applied-mask ^long [^int diff-lsb]
            (case diff-lsb
              (#_intensity 0 1 #_bold 2) (apply-intensity)
              (#_italic 3) (apply-flag style/mask-italic 3 23)
              (#_underline 4) (apply-flag style/mask-underline 4 24)
              (#_strikethrough 5) (apply-flag style/mask-strikethrough 9 29)
              (#_overline 6) (apply-flag style/mask-overline 53 55)
              (#_conceal 7) (apply-flag style/mask-conceal 8 28)
              (#_reversed 13) (apply-flag style/mask-reversed 7 27)
              #_else
              (cond
                (>= diff-lsb #_(Long/numberOfTrailingZeros mask-foreground) 39)
                (do (apply-color 30 (style/extract-fg style))
                    style/mask-foreground)
                (>= diff-lsb #_(Long/numberOfTrailingZeros mask-background) 14)
                (do (apply-color 40 (style/extract-bg style))
                    style/mask-background)
                :else
                (throw (IllegalArgumentException.)))))]
    (.append w \u001b)                  ;aka escape
    (.append w \[)
    (when-not (= style style/default) ;no arg aka 0 is "reset to default"
      (loop [diff (bit-xor active-style style)]
        (when-not (zero? diff)
          (let [diff-lsb (Long/numberOfTrailingZeros diff)
                diff' (bit-and-not diff (applied-mask diff-lsb))]
            (when-not (zero? diff')
              (sep))
            (recur diff')))))
    (.append w \m)
    style))

(def ^:private clear-before-nl (bit-or style/mask-background
                                       style/mask-reversed))
(deftype AnsiWriter [^:unsynchronized-mutable ^long active-style ;of terminal
                     ^:unsynchronized-mutable ^int nl-count
                     ^:unsynchronized-mutable ^int cp-count ;counts since nl
                     ^Writer w]
  StyledWriter
  (nl [this]
    (let [active-bg (bit-and clear-before-nl active-style)]
      (when-not (zero? active-bg)
        (set! active-style     ;clear any non-default background color
              (apply-style w active-style (bit-xor active-style active-bg))))
      (.append w \newline)
      (set! nl-count (inc nl-count))
      (set! cp-count 0)
      this))
  (append [this style cs start end]
    (when-not (= active-style style)
      (set! active-style (apply-style w active-style style)))
    (.append w cs start end)
    (set! cp-count (+ cp-count (styled/code-point-count cs start end)))
    this)
  (nl-count [_]
    nl-count)
  (code-points-in-line [_]
    cp-count)
  (close [this]
    (styled/write this "")
    (when (not= cp-count 0) (.nl this))))

(defn styled-writer ^StyledWriter [^Writer w]
  (AnsiWriter. style/default 0 0 w))
