;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.alpha.pp.paragraph
  (:require (tcljx.alpha.pp [style :as style] [styled :as styled]
                            [buffer :as buffer]))
  (:import (tcljx.alpha.pp.styled StyledWriter)
           (tcljx.alpha.pp.buffer BufferWriter StyledText)))

;;; A paragraph writer imposes a soft limit on the width of emitted
;;; text.  If a line of text would exceed the limit, it replaces a
;;; single space character with a call to `nl`.

(def ^:private nl \newline)
(def ^:private sep \space)
(defn- sep?
  (^boolean [^char ch]
   (or (= ch sep) (= ch nl)))
  (^boolean [^CharSequence cs ^int i]
   (sep? (.charAt cs i))))

(letfn [(offset-upto ^int [^int i ^String cs ^int offset]
          (try
            (Character/offsetByCodePoints cs i offset)
            (catch IndexOutOfBoundsException _
              (.length cs))))
        (backward-to-break ^int [^int i ^String cs ^int start]
          (loop [i i, then-word? (and (< (inc i) (.length cs))
                                      (not (sep? cs (inc i))))]
            (cond
              (< i start) i
              (sep? cs i) (if then-word? i (recur (dec i) false))
              :else (recur (dec i) true))))
        (forward-to-break ^int [^int i ^String cs]
          (let [end (.length cs)]
            (loop [sep-then? (and (>= i 0) (sep? cs i)), i (inc i)]
              (cond
                (= i end) Integer/MAX_VALUE
                (sep? cs i) (recur true (inc i))
                sep-then? (dec i)
                :else (recur false (inc i))))))
        (end-of-line ^int [^int i ^String cs ^int start]
          (if (= i (.length cs))
            Integer/MAX_VALUE
            (let [j (backward-to-break i cs start)]
              (if (<= j start)
                (forward-to-break i cs)
                j))))]
  
  (defn- flush-paragraph ^void [^StyledWriter w ^int width ^StyledText txt]
    (let [remain (max 0 (- width (.code-points-in-line w)))
          eol (-> (.pos txt)
                  (offset-upto (.text txt) remain)
                  (end-of-line (.text txt) (.pos txt)))
          txt' (buffer/transfer-prefix-to txt eol w)]
      (when (< eol Integer/MAX_VALUE)
        (.nl w)
        (recur w width (buffer/skip-chars txt' 1))))))

(deftype ParagraphWriter [^StyledWriter w ^BufferWriter wb ^int width]
  StyledWriter
  (nl [this]          ;ends the current paragraph and begins a new one
    (flush-paragraph w width (buffer/to-text wb))
    (buffer/clear-buffer wb)
    (.nl w)                             ;prepare for next paragraph
    this)
  (append [this style cs start end]
    (let [j (styled/end-of-line cs start end)]
      (styled/write wb style cs start j)
      (if (< j end)
        (do (.nl this)
            (recur style cs (inc j) end))
        this)))
  (nl-count [_]
    (throw (UnsupportedOperationException.)))
  (code-points-in-line [_]
    (throw (UnsupportedOperationException.)))
  (close [this]
    (flush-paragraph w width (buffer/to-text wb))
    (buffer/clear-buffer wb)))

;;; Prints out paragraphs separated(!) by a newline, either denoted by
;;; a call to method `nl` or by the character \newline.  Tries to
;;; impose `width` as a soft limit for the paragraph lines' length.
;;; Within a paragraph, line breaks are created by converting the
;;; rightmost space just before a word.  By only replacing a space
;;; with a newline character, the total number of characters written
;;; remains unchanged.
(defn writer
  (^StyledWriter [^StyledWriter w]
   (writer w 80))
  (^StyledWriter [^StyledWriter w ^int width]
   (ParagraphWriter. w (buffer/buffer-writer) width)))
