;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.alpha.pp.recording
  (:require (tcljx.alpha.pp [style :as style] [styled :as styled]))
  (:import (tcljx.alpha.pp.styled StyledWriter)))

;;; FIXME... value type?
(deftype Interval [^long style, ^int end-of-style, ^Interval next])
(defn- cons-interval ^Interval [^long style ^StringBuilder tb ^Interval tail]
  (cond->> tail
    (not= style/invalid style)
    (Interval. style (.length tb))))
(defn- reverse-intervals ^Interval [^Interval acc ^Interval head]
  (if (nil? head)
    acc
    (recur (Interval. (.style head) (.end-of-style head) acc)
           (.next head))))

;;; FIXME... non-null value type?
(deftype Recording [^String text, ^int start, ^Interval intervals])

(definterface RecordingWriter
  :extends [StyledWriter]
  (take-recording! ^Recording []))

(deftype Recorder [^StringBuilder text-builder
                   ^:unsynchronized-mutable ^Interval rev-intervals
                   ^:unsynchronized-mutable ^int beginning-of-line
                   ^:unsynchronized-mutable ^long active-style]
  RecordingWriter
  (nl [this]
    (.append text-builder \newline)
    (set! beginning-of-line (.length text-builder))
    this)
  (append [this style cs start end]
    (when-not (= style active-style)
      (set! rev-intervals (cons-interval active-style text-builder rev-intervals))
      (set! active-style style))
    (.append text-builder cs start end)
    this)
  (code-points-in-line [_]
    (styled/code-point-count text-builder beginning-of-line))
  (close [this]
    nil)
  
  (take-recording! [_]
    (let [rec (->> (cons-interval active-style text-builder rev-intervals)
                   (reverse-intervals nil)
                   (Recording. (.toString text-builder) 0))]
      (.setLength text-builder 0)
      (set! rev-intervals nil)
      (set! beginning-of-line 0)
      (set! active-style style/invalid)
      rec)))

(defn raw-recorder ^Recorder []
  (Recorder. (StringBuilder.) nil 0 style/invalid))

(defn write-raw-to
  (^Recording [^Recording rec ^StyledWriter w]
   ;; write all intervals, including an empty ones at the end
   (write-raw-to rec w Integer/MAX_VALUE))
  (^Recording [^Recording rec ^StyledWriter w ^int end]
   (let [cs (.text rec)]
     (loop [int (.intervals rec), s (.start rec)]
       (if (and (< s end) (some? int))
         (let [e (min end (.end-of-style int))]
           (styled/write w (.style int) cs s e)
           (recur (cond-> int (= e (.end-of-style int)) (.next)) e))
         (Recording. cs s int))))))

(defn- forward-to ^Recording [^Recording rec ^int pos] ;(<= (.start rec) pos)
  (loop [int (.intervals rec)]
    (if (and (some? int) (<= (.end-of-style int) pos))
      (recur (.next int))
      (Recording. (.text rec) pos int))))

(defn skip-chars ^Recording [^Recording rec ^int n] ;pre: (>= n 0)
  (forward-to rec (+ (.start rec) n)))
#_(defn skip-code-points ^Recording [^Recording rec ^int n] ;pre: (>= n 0)
    (forward-to rec (Character/offsetByCodePoints (.text rec) (.start rec) n)))
