;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.data.wrong
  (:require (tcljx.data [meta :as meta] [type :as type])
            [tcljx.alpha.ptest__style :as style])
  (:import (clojure.lang Symbol Named)))

;;; Compilation errors raise an exception of type WrongInfo.  It
;;; mirrors ExceptionInfo, but does not implement IExceptionInfo.  The
;;; compiler turns such an exception into a readable error message,
;;; without confronting the user with its long and confusing stack
;;; trace.
(deftype WrongInfo [^String message ^map data]
  RuntimeException
  (getMessage [_] ;problem: cannot set message after RuntimeException()
    message)
  (toString [this]
    ;; For some reason, "make test" crashes in prn or println
    ;; with "IllegalStateException: failed to resolve runtime fn
    ;; clojure.core/isa?" in some scenarios, where "make
    ;; watch-and-test" works as expected.  This happens in
    ;; the (.toString data), or later when trying to print the summary
    ;; report.  Running single tests via TEST=... avoids this problem.
    (str "tcljx.data.wrong.WrongInfo: " (.getMessage this) " " (.toString data))))

(defn wr-info
  (^WrongInfo [^String msg]
   (wr-info msg nil))
  (^WrongInfo [^String msg ^map map]
   (wr-info msg map nil))
  (^WrongInfo [^String msg ^map map ^Throwable cause]
   #_(prn :error msg map)
   #_(.printStackTrace (or cause (Throwable.)) (java.io.PrintWriter. *out*))
   (let [ex (WrongInfo. msg (or map clojure.lang.PersistentArrayMap/EMPTY))]
     (.initCause ex cause)              ;can be called only once
     ex)))

(defn wr-data ^map [ex]
  (when (instance? WrongInfo ex)
    (.data ^WrongInfo ex)))
(defn wr-line-number ^int [ex]      ;zero if no line number is present
  (let [data (wr-data ex)]
    (when-some [x (or (:form/line-of data) (:reader/line data))]
      ^int x)))

;;; Note: core's `ex-message` and `ex-cause` work on any Throwable, so
;;; there is no need to duplicate the functions here.

;;; ------------------------------------------------------------------------

(defn update-wr-data ^WrongInfo [^WrongInfo ex f & args]
  (let [ex* (wr-info (ex-message ex) (apply f (wr-data ex) args) (ex-cause ex))]
    (when-some [t (.getStackTrace ex)]
      (.setStackTrace ex* t))
    ex*))

;;; The compiler reports errors by throwing an WrongInfo instance.
;;; Its data map encodes information about the context of the error,
;;; while the exception's message is a free form error message.
;;;
;;; If it exists, then :form/line-of is the line number of the
;;; innermost list form "around" the point of error.
;;;
;;; If a `WrongInfo` is decorated with a ex-cause value, then it
;;; is assumed that this Throwable originates outside of the control
;;; of the compiler (e.g. during macro expansion).
(defn push-line-number* ^WrongInfo [^WrongInfo ex ^int line]
  (cond-> ex
    (and (pos? line) (not (contains? (wr-data ex) :form/line-of)))
    (update-wr-data assoc :form/line-of line)))
(defn push-line-number ^WrongInfo [^WrongInfo ex seq-form-or-line]
  (let [ln (if (seq? seq-form-or-line)
             (meta/line-of seq-form-or-line)
             ^Integer seq-form-or-line)]
    (cond-> ex (some? ln) (push-line-number* ^int ln))))

;; (defn rethrow-with-line-number ^void [^WrongInfo e ^Integer ln]
;;   (throw (push-line-number e ln)))

(defn wr-info-line-number ^WrongInfo [msg form]
  (push-line-number (wr-info msg) (meta/line-of form)))

;;; Only assoc `k` to the exception's data if this key is not defined
;;; yet.  With exceptions decorated from the most to the least
;;; specific context, this is used to preserve the most specific
;;; information available.
(defn assoc-if-new ^WrongInfo [^WrongInfo e k v]
  (cond-> e
    (not (contains? (wr-data e) k))
    (update-wr-data assoc k v)))

(defn assoc-dep-map ^WrongInfo [^Throwable t ^map dep-map]
  #_(.printStackTrace t)
  (-> (if (instance? WrongInfo t)
        ^WrongInfo t
        (do (.printStackTrace t)
            (wr-info "unhandled exception" {} t)))
      (update-wr-data assoc :emitter/namespaces dep-map)))

;;; If `t` has a compiler error as one of its causes, then return the
;;; WrongInfo instance.  Otherwise, return nil.
(defn first-wrong-info ^WrongInfo [^Throwable t]
  (cond (nil? t) nil
        (instance? tcljx.data.wrong.WrongInfo t) ^WrongInfo t
        :else (recur (.getCause t))))

;;; ------------------------------------------------------------------------

(defn str* ^String [x]
  (cond
    (nil? x) "nil"
    (class? x) (str (type/type-symbol x))
    (string? x) (pr-str x)
    :else (str x)))

(defn q ^String [x]                    ;quoting a source code fragment
  (let [s (str* x), s' (style/quote-str s)]
    (if (identical? s s')
      (str "`" s "`")                 ;fallback if styles are disabled
      s')))
(defn q-as-symbol
  (^String [x]
   (q (if (symbol? x) x (symbol nil x))))
  (^String [^Class cl ^String member-name]
   (q (symbol (.getName cl) member-name))))
(defn q-namespace ^String [^Named x]
  (q (symbol nil (namespace x))))
(defn q-type [tp]
  (symbol nil (if tp (q tp) "<none>")))
;; (defn q-symbol ^String [x]
;;   (if (symbol? x)
;;     (q x)
;;     (str x)))

(defn got ^String [x] (str " (got: " (str* x) ")"))
(defn got-int ^String [^int i] (got (object i)))
(defn got-q ^String [x] (str " (got: " (q x) ")"))

(defn got-type ^String [^Class tp]
  (str " (got: " (q-type tp) ")"))
(defn got-types
  (^String [tps]
   (str " (got: " (mapv q-type tps) ")"))
  (^String [^Class/1 tps ^int start ^int end]
   (got-types (->> tps (take end) (drop start)))))

;; (defn got-classes ^String [cls]
;;   (str " (got: " (->> (map #(.getName ^Class %) cls)
;;                       (sort)
;;                       (str/join " ")) ")"))



;; (defn ensure-sym
;;   (^Symbol [form]
;;    (if (symbol? form)
;;      form
;;      (syntax "expect symbol" form)))
;;   (^Symbol [form ^Symbol exp]
;;    (if (= form exp)
;;      exp
;;      (syntax (str "expected symbol " (q exp)) form))))


(defn info-unresolved
  (^Throwable [sym-or-str]
   (info-unresolved "undefined symbol " sym-or-str))
  (^Throwable [^String msg-prefix sym-or-str]
   (wr-info (str msg-prefix (q sym-or-str)))))
(defn unresolved-nmsp-sym [^String nmsp ^String nm]
  (throw (wr-info (str "no public var " (q-as-symbol nm) " in namespace "
                       (q-as-symbol nmsp)))))
;; (defn unresolved-interop [^String msg-prefix ^String nm ^Class opt-owner
;;                           ^map data]
;;   (throw (wr-info (cond-> (str msg-prefix (q (symbol nil nm)))
;;                     (some? opt-owner) (str " in " (type/type-symbol opt-owner)))
;;                   data)))

(defn info-class-not-found ^Throwable [x]
  (if (instance? NoClassDefFoundError x)
    (recur (ex-message ^NoClassDefFoundError x))
    (let [sym (symbol x)]               ;idempotent
      (info-unresolved "class not found: " sym))))


;; (defn file [^java.nio.file.Path rpath]
;;   (throw (wr-info (str "failed to locate resource file " (q (str rpath))))))

;; ;;; This indicates an error regarding a type expression, i.e. an
;; ;;; expression of type Class.
;; (defn type-expr [^String msg-prefix
;;                  ^java.lang.invoke.TypeDescriptor$OfField tp]
;;   (throw (wr-info (str msg-prefix (got tp)))))

(defn other
  ([^String msg]
   (throw (wr-info msg)))
  ([^String msg form]
   (throw (wr-info-line-number msg form))))
