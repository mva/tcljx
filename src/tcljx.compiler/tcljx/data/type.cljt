(ns tcljx.data.type
  (:require [tinyclj.core :as cc])
  (:import (java.lang.classfile CodeBuilder TypeKind)
           (java.lang.constant ConstantDesc)
           (java.lang.invoke MethodHandles$Lookup))
  (:refer-clojure :exclude [symbol keyword vector map set list
                            byte short int long float double char boolean void]))

(defn same? ^boolean [^Class a ^Class b]
  (identical? a b))
(defn same-name? ^boolean [^Class a ^Class b] ;if from different loaders
  (identical? (.getName a) (.getName b)))
(defn void? ^boolean [^Class tp]
  (identical? Void/TYPE tp))

;;; From the point of view of Clojure there are no statements, only
;;; expressions producing some value.  Accordingly, the Java type
;;; `void` has no equivalent in Clojure.  Any expression "returning
;;; void" is interpreted as returning one of nil, zero, false, or
;;; \u0000 depending on context.
;;; 
;;; For this reason, reinterpret for an expression the primitive type
;;; `void` as "can produce a value of arbitrary type depending on the
;;; context of use".  On the JVM level, these arbitrary types include
;;; the logical JVM type `void` and the type `nil` denoting an
;;; instruction that does not return.
(def polymorphic Void/TYPE)
(def polymorphic? void?) ;on the level of Clojure code, `void` means polymorphic

(defn monomorphic-primitive? ^boolean [^Class expr-type]
  ;; FIXME... is the "primitive" in the name implied and should be dropped?
  (and (.isPrimitive expr-type) (not (polymorphic? expr-type))))

;;; The type of the special reference `nil`.  Also known as nullptr.
(def poly-reference Void)
(defn poly-reference? ^boolean [^Class expr-type]
  (identical? Void expr-type))

;;; Maps a Clojure expression type to the logical Java type to be used
;;; in a class file element.  The returned value is never `void`.
(defn expr-to-logical ^Class [^Class expr-type]
  (if (or (polymorphic? expr-type) (poly-reference? expr-type))
    Object
    expr-type))

;;; ------------------------------------------------------------------------

(defn any-primitive? ^boolean [^Class/1 types]
  (loop [i (dec (alength types))]
    (cond (neg? i) false
          (.isPrimitive (aget types i)) true
          :else (recur (dec i)))))
(defn any-monomorphic-primitive? ^boolean [^Class/1 types ^int start ^int end]
  (loop [i (dec end)]
    (cond (< i start) false
          (monomorphic-primitive? (aget types i)) true
          :else (recur (dec i)))))
(defn all-monomorphic-primitive? ^boolean [^Class/1 types]
  (loop [i (dec (alength types))]
    (cond (< i 0) true
          (monomorphic-primitive? (aget types i)) (recur (dec i))
          :else false)))

;;; ------------------------------------------------------------------------

(defn type-dimensions ^int [^Class tp]
  (loop [n 0, tp tp]
    (if (.isArray tp)
      (recur (inc n) (.componentType tp))
      n)))

(defn component-type ^Class [^Class tp ^int i]
  (loop [tp tp, i i]
    (if (zero? i)
      tp
      (recur (.componentType tp) (dec i)))))

(defn array-type-of-class ^Class [^Class cl ^int array-rank]
  (if (zero? array-rank)
    cl
    (recur (.arrayType cl) (dec array-rank))))

(defn type-symbol ^symbol [^Class tp]
  (let [n (type-dimensions tp)]
    (if (zero? n)
      (cc/symbol nil (.getName tp))
      (cc/symbol (loop [cl tp]
                   (if (.isArray cl)
                     (recur (.componentType cl))
                     (.getName cl)))
                 (str n)))))

;;; ------------------------------------------------------------------------

(definterface AutoReturnMarker)         ;interface implies abstract
(def auto-return-marker AutoReturnMarker)
(defn auto-return-marker? ^boolean [^Class tp] (same? AutoReturnMarker tp))

;;; ------------------------------------------------------------------------

(defn- primitive-id ^byte [^Class tp]   ;pre: (.isPrimitive tp)
  ;; numbering follows xa(load|store), with the exception of boolean and void
  (-> (condp identical? tp 
        Integer/TYPE #_int 0            ;iaload and iastore
        Long/TYPE #_long 1              ;laload and lastore
        Float/TYPE #_float 2            ;faload and fastore
        Double/TYPE #_double 3          ;daload and dastore
        Boolean/TYPE #_boolean 4        ;takes place of aaload/aastore
        Byte/TYPE #_byte 5              ;baload and bastore
        Character/TYPE #_char 6         ;caload and castore
        Short/TYPE #_short 7            ;saload and sastore
        Void/TYPE #_void 8              ;arbitrary
        #_else (throw (IllegalArgumentException.)))
      (cc/byte)))

;;; Like the primitive equivalent, the reference class of a box type
;;; is final.  This means, that an `isAssignableFrom` check reduces to
;;; an identity test.
;;; 
;;; Note: `convert-from` does not get any line number information.
;;; Therefore the conversion functions must only emit bytecodes that
;;; cannot throw.  Conversion from void produces the zero value of the
;;; target type.
(deftype Wrapper [^Class class-primitive
                  ^Class class-reference
                  ^TypeKind type-kind   ;of class-primitive
                  ^boolean numeric?
                  ^short mask-assignable-from
                  ^byte primitive-id      ;4 for boolean, 8 for void
                  ^byte computational-id] ;0 to 3, except -1 for void
  java.lang.Record)

(defn computational-int? ^boolean [^Wrapper wtp]
  (zero? (.computational-id wtp)))

(letfn [(wrapper ^Wrapper [^Class class-primitive
                           ^Class class-reference
                           ^Wrapper assignable-from]
          (let [prim-id (primitive-id class-primitive)]
            (Wrapper. class-primitive class-reference
                      (TypeKind/from class-primitive)
                      (.isAssignableFrom Number class-reference)
                      (cc/short
                       ;; can assign from itself and from void
                       (cond-> (-> 0 (bit-set prim-id) (bit-set 8))
                         (some? assignable-from)
                         (bit-or (.mask-assignable-from assignable-from))))
                      prim-id
                      (if (> prim-id 3) (cc/byte 0) prim-id))))]
  (def byte (wrapper Byte/TYPE Byte nil))
  (def short (wrapper Short/TYPE Short byte))
  (def int (wrapper Integer/TYPE Integer short))
  (def long (wrapper Long/TYPE Long int))
  (def float (wrapper Float/TYPE Float long))
  (def double (wrapper Double/TYPE Double float))
  (def boolean (wrapper Boolean/TYPE Boolean nil))
  (def char (wrapper Character/TYPE Character nil)) ;not numeric in Clojure
  (def void (Wrapper. Void/TYPE Void (TypeKind/from Void/TYPE)
                      false (cc/short -1) (primitive-id Void/TYPE)
                      (cc/byte -1))))

(def primitive-types [int long float double boolean byte char short void])

(defn primitive-assignable-from? ^boolean [^Wrapper ptype ^Wrapper atype]
  (bit-test (.mask-assignable-from ptype) (.primitive-id atype)))

(defn of ^Wrapper [^Class cl]           ;pre: `cl` is primitive
  (condp identical? cl
    Integer/TYPE int
    Long/TYPE long
    Boolean/TYPE boolean
    Short/TYPE short
    Byte/TYPE byte
    Character/TYPE char
    Float/TYPE float
    Double/TYPE double
    Void/TYPE void))

(defn of-all ^Wrapper [^Class/1 types]
  (when (pos? (alength types))
    (let [tp (aget types (dec (alength types)))]
      (loop [i (- (alength types) 2)]
        (cond (neg? i) (of tp)
              (same? tp (aget types i)) (recur (dec i))
              :else nil)))))

(defn primitive-convert-from ^void [^CodeBuilder xb ^Wrapper wto ^Wrapper wfrom]
  (letfn [(convert-to-int ^void [^int from]
            (case from
              (#_int 0 #_byte 5 #_char 6 #_short 7 #_boolean 4) nil
              #_long 1 (-> xb .l2i)
              #_float 2 (-> xb .f2i)
              #_double 3 (-> xb .d2i)
              #_else_void (-> xb .iconst_0)))
          (convert-to-long ^void [^int from]
            (case from
              (#_int 0 #_byte 5 #_char 6 #_short 7 #_boolean 4) (-> xb .i2l)
              #_long 1 nil
              #_float 2 (-> xb .f2l)
              #_double 3 (-> xb .d2l)
              #_else_void (-> xb .lconst_0)))
          (convert-to-float ^void [^int from]
            (case from
              #_long 1 (-> xb .l2f)
              #_float 2 nil
              #_double 3 (-> xb .d2f)
              (#_int 0 #_byte 5 #_char 6 #_short 7 #_boolean 4) (-> xb .i2f)
              #_else_void (-> xb .fconst_0)))
          (convert-to-double ^void [^int from]
            (case from
              (#_int 0 #_byte 5 #_char 6 #_short 7 #_boolean 4) (-> xb .i2d)
              #_long 1 (-> xb .l2d)
              #_float 2 (-> xb .f2d)
              #_double 3 nil
              #_else_void (-> xb .dconst_0)))
          (convert-to-boolean ^void [^int from]
            (case from
              #_boolean 4 nil
              #_void 8 (-> xb .iconst_0)
              #_else (throw (IllegalStateException.))))
          (convert-to-byte ^void [^int from]
            (case from
              (#_int 0 #_char 6 #_short 7) (-> xb .i2b)
              #_long 1 (-> xb .l2i .i2b)
              #_float 2 (-> xb .f2i .i2b)
              #_double 3 (-> xb .d2i .i2b)
              (#_byte 5 #_boolean 4) nil
              #_else_void (-> xb .iconst_0)))
          (convert-to-char ^void [^int from]
            (case from
              (#_int 0 #_byte 5 #_short 7 #_boolean 4) (-> xb .i2c)
              #_long 1 (-> xb .l2i .i2c)
              #_float 2 (-> xb .f2i .i2c)
              #_double 3 (-> xb .d2i .i2c)
              #_char 6 nil
              #_else_void (-> xb .iconst_0)))
          (convert-to-short ^void [^int from]
            (case from
              (#_int 0 #_char 6) (-> xb .i2s)
              #_long 1 (-> xb .l2i .i2s)
              #_float 2 (-> xb .f2i .i2s)
              #_double 3 (-> xb .d2i .i2s)
              (#_byte 5 #_short 7 #_boolean 4) nil
              #_else_void (-> xb .iconst_0)))]
    (let [from (.primitive-id wfrom)]
      (case (.primitive-id wto)
        #_int 0 (convert-to-int from)
        #_long 1 (convert-to-long from)
        #_float 2 (convert-to-float from)
        #_double 3 (convert-to-double from)
        #_boolean 4 (convert-to-boolean from)
        #_byte 5 (convert-to-byte from)
        #_char 6 (convert-to-char from)
        #_short 7 (convert-to-short from)))))

(defn convert-from-constant ^ConstantDesc [^Class target-type ^Number n]
  ;; pre: `target-type` is monomorphic primitive type
  (let [prim-id (primitive-id target-type)]
    (case prim-id
      #_int 0 (object (.intValue n))
      #_long 1 (object (.longValue n))
      #_float 2 (object (.floatValue n))
      #_double 3 (object (.doubleValue n))
      #_else
      (-> (case prim-id        ;conversion to computationally int type
            #_boolean 4 (cc/int (not= (.intValue n) 0))
            #_byte 5 (cc/int (.byteValue n))
            #_char 6 (cc/int (cc/char (.intValue n)))
            #_short 7 (cc/int (.shortValue n)))
          (object)))))

#_(defn of-descriptor ^Wrapper [^TypeDescriptor$OfField tpd]
    (case (.charAt (.descriptorString tpd) 0)
      \L generic-reference
      \I int
      \J long
      \Z boolean
      \S short
      \B byte
      \C char
      \F float
      \D double
      \V void))

#_(defn primitive? ^boolean [^Wrapper tp]
    (not (identical? generic-reference tp)))

#_(defn default-value-of ^Expr [^Class tp]
    (if (jb/reference? tp)
      (x/const tp nil)
      (.default-value (of* tp nil))))

;;; Is an argument of type `atype` assignable to a parameter of type
;;; `ptype`?  This predicate works on the level Clojure expression
;;; types, whose semantics differ from the Java and JVM type system.
;;; The other part of the equation is implemented by `emit/opnd`.  If
;;; an expression of `atype` is classified as assignable, then the
;;; emit function must adjust its JVM level operand type on the stack
;;; to match `ptype`.
(defn assignable-from? ^boolean [^Class ptype ^Class atype]
  #_(prn :assignable-from? ptype atype)
  (letfn [(from-primitive? ^boolean [^Wrapper awrapper]
            ;; pre: `awrapper` denotes a non-void primitive type
            (if (.isPrimitive ptype)
              ;; widening numeric type conversion?
              (primitive-assignable-from? (of ptype) awrapper)
              ;; auto-boxing the argument
              (.isAssignableFrom ptype (.class-reference awrapper))))
          (primitive-from-reference? ^boolean [^Wrapper pwrapper]
            ;; pre: `pwrapper` denotes a primitive type
            (and
             ;; cannot unbox the reference value nil
             (not (poly-reference? atype))
             ;; can assign atype to ptype's box type?
             (assignable-from? (.class-reference pwrapper) atype)))]
    (or (.isAssignableFrom ptype atype) ;by the JVM's rules
        ;; here holds: (not (identical? ptype atype))

        (polymorphic? ptype)   ;can turn any expression into statement
        ;; here holds: (not (void? ptype))
        
        (if (.isPrimitive atype)
          (or (polymorphic? atype) (from-primitive? (of atype)))

          ;; here holds: atype is a reference type and ptype is not
          ;; "isAssignableFrom" atype
          (or (.isAssignableFrom atype ptype)
              (if (.isPrimitive ptype)
                ;; auto-unboxing the non-Void reference argument
                (primitive-from-reference? (of ptype))
                ;; parameter is of reference type and argument is nil
                (poly-reference? atype)))))))

(defn jvm-assignable-from? ^boolean [^Class ptype ^Class atype]
  #_(prn :jvm-assignable-from? ptype atype)
  ;; FIXME... used for lambda expression matching; too conservative?
  (.isAssignableFrom ptype atype))

;;; ------------------------------------------------------------------------

;;; These remain unbound until `fixup-runtime-types!` is called:
(def ^:redef ^Class symbol)
(def ^:redef ^Class keyword)
(def ^:redef ^Class vector)
(def ^:redef ^Class map)
(def ^:redef ^Class set)
(def ^:redef ^Class list)
(def ^:redef ^Class seq)
(def ^:redef ^Class ifn)
(def ^:redef ^Class iobj)
(def ^:redef ^Class ClojureRT)
(def ^:redef ^Class Var)
(def ^:redef ^Class Namespace)
(def ^:redef ^Class Agent)
(def ^:redef ^Class Literal)
(def ^:redef ^Class AFnMh)
(def ^:redef ^Class StaticFn)

(defn fixup-runtime-types! [^MethodHandles$Lookup rt-lookup]
  (letfn [(find-class ^Class [^Class compiler-type]
            (.findClass rt-lookup (.getName compiler-type)))]
    (when (some? symbol)
      (throw (IllegalStateException.)))
    (def symbol (find-class clojure.lang.Symbol))
    (def keyword (find-class clojure.lang.Keyword))
    (def vector (find-class clojure.lang.IPersistentVector))
    (def map (find-class clojure.lang.IPersistentMap))
    (def set (find-class clojure.lang.IPersistentSet))
    (def list (find-class clojure.lang.IPersistentList))
    (def seq (find-class clojure.lang.ISeq))
    (def ifn (find-class clojure.lang.IFn))
    (def iobj (find-class clojure.lang.IObj))
    
    (def ClojureRT (find-class clojure.lang.RT))
    (def Var (find-class clojure.lang.Var))
    (def Namespace (find-class clojure.lang.Namespace))
    (def Agent (find-class clojure.lang.Agent))
    
    (def Literal (find-class tinyclj.lang.Literal))
    (def AFnMh (find-class tinyclj.lang.AFnMh))
    (def StaticFn (find-class tinyclj.lang.StaticFn))))
