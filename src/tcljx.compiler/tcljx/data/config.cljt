;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.data.config
  (:require
   [tinyclj.string :as str])
  (:import
   (java.lang.classfile ClassFile ClassBuilder)
   (java.lang.constant ClassDesc)))

;;; If true, the both the compilation and the emit thread are free to
;;; fork of work to other threads.  Set this to false to force them to
;;; compile namespaces sequentially and emit class files in order.
(def fork-work? #_false true)

;; ;; Emit ClassFile attribute SourceFile & Code attribute LineNumberTable?
;; (def enable-line-numbers true)

;; ;; Emit Code attribute LocalVariableTable?  This adds constant pool
;; ;; entries for parameter and bindings names plus their type
;; ;; descriptors, increasing the pressure on the constant pool.
;; (def enable-local-variables true)

(defn with-class-version ^ClassBuilder [^ClassBuilder cb]
  (let [major ClassFile/JAVA_17_VERSION
        minor 0 #_ClassFile/PREVIEW_MINOR_VERSION]
    (.withVersion cb major minor)))

(def core-lib "clojure.core")
;; (def core-lib-sym (symbol nil core-lib))
(defn core-lib? ^boolean [^String ns-str] (= core-lib ns-str))

(def sym-quote 'quote)

;;; note: a copy of this lives in clojure.core/specials
(def specials '#{def loop* recur if case* let* letfn*
                 do fn* quote var import* . set! deftype* reify* try throw
                 monitor-enter monitor-exit catch finally new &
                 ;; special forms that are not special in Clojure:
                 definterface* instanceof*})

(def primitive-ns-str "clojure.core.primitive")

(defn capstone-class ^ClassDesc [^String ns-str]
  (ClassDesc/of ns-str "___"))

;;; ------------------------------------------------------------------------

;;; Because application and compiler can live in different class
;;; loaders with a different runtime (e.g. when bootstrapping
;;; tclj-in-tclj), it is easier to duplicate munge/demunge code.  See
;;; tinyclj/lang/Compiler.java

;;; see OpenJDK classFileParser.cpp, verify_unqualified_name
(defn nm-repl ^String [^char c]
  (case c
    ;; \; nil                             ;invalid in symbol & class name
    ;; \[ nil                             ;invalid in symbol & class name
    \/ "_SLASH_"                        ;"/"
    \\ "_BSLASH_"                       ;"\\"
    \< "_LT_"                           ;"<"
    \> "_GT_"                           ;">"
    \. "_DOT_"                          ;"."
    nil))                              ;accept char

(def ^:private ^java.util.Map de-repl
  (java.util.Map/of "_SLASH_" "/"
                    "_BSLASH_" "\\"
                    "_LT_" "<"
                    "_GT_" ">"
                    "_DOT_" "."))

(defn munge-name ^String [nm-sym]   ;pre: `nm-sym` is symbol or string
  (let [nm (name nm-sym)]
    (letfn [(up-to-replacement ^int [^int s]
              (loop [i s]
                (if (and (< i (.length nm))
                         (nil? (nm-repl (.charAt nm i))))
                  (recur (inc i))
                  i)))
            (replace-all ^String [^int s ^StringBuilder b]
              (let [e (up-to-replacement s)]
                (if (= e (.length nm))
                  (str (.append b (subs nm s)))
                  (recur (inc e)
                         (doto b
                           (.append (subs nm s e))
                           (.append (nm-repl (.charAt nm e))))))))]
      (let [i (up-to-replacement 0)]
        (if (= i (.length nm))
          nm               ;common fast path: return existing instance
          (replace-all 0 (StringBuilder.)))))))

(defn demunge-name ^String [^String s]
  (if (neg? (.indexOf s "_"))
    s                      ;common fast path: return existing instance
    (str/replace s #"_(?:DOT|[LG]T|B?SLASH)_"
                 (fn [^String m] (.getOrDefault de-repl m m)))))
