;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.main.tclj1
  (:require
   #_[tcljx.config :as cfg]
   #_[tcljx.wrong :as wrong]
   #_[tcljx.emitter :as em]
   (tcljx.main [options :as options] [invoke :as invoke] [tclj0 :as tclj0]
               [watcher :as watcher])
   #_[tcljx.main.efmt :as efmt]
   #_[tcljx.main.builder :as builder])
  (:import
   (tcljx.main.options Options)
   (java.util Optional)
   (java.util.function Consumer)))

;; ;;; Transitively remove all namespaces from `dep-map` for which
;; ;;; `pred-good` returns false, and delete all of their associated
;; ;;; class files.
;; (defn- drop-bad-namespaces! ^map [^map dep-map ^Options opts pred-good]
;;   (let [!known-good (java.util.HashMap.)]
;;     (letfn [(known-good? [ns-str]
;;               (if-some [x (.get !known-good ns-str)] ;do not use `or` here
;;                 x                        
;;                 (let [dep-info (get dep-map ns-str)
;;                       good? (object (and ^boolean (pred-good dep-info)
;;                                          (every? known-good?
;;                                                  (:req-strs dep-info))))]
;;                   ;; note: imported class files have no req-strs and
;;                   ;; are implicitly "good"
;;                   (.put !known-good ns-str good?)
;;                   good?)))
;;             (concurrent-delete-error ^void [^Exception e]
;;               (println)
;;               (println "Is a second `--watch` process running for this project?")
;;               (println "Failed to delete" (.getMessage e)) ;assumes NoSuchFileException
;;               (println "Exiting...")
;;               (System/exit 1))]
;;       (reduce-kv (fn [acc ns-str _]
;;                    (if (known-good? ns-str)
;;                      acc
;;                      (try 
;;                        (cfg/delete-package-classes (.dest-dir opts) ns-str)
;;                        (dissoc acc ns-str)
;;                        (catch java.io.UncheckedIOException e
;;                          (concurrent-delete-error (.getCause e)))
;;                        (catch java.nio.file.NoSuchFileException e
;;                          (concurrent-delete-error e)))))
;;                  dep-map dep-map))))

;; ;; Returns the dependency map of all completed(!) namespaces.  On
;; ;; return, there is no class file output from namespaces that were not
;; ;; compiled successfully.
;; (defn build-pass ^map [^Options opts ^Consumer on-completion
;;                                   ^map prior-completed-map]
;;   (letfn [(report-success ^map [^map nmsp-map]
;;             ;; returns `dep-map` or throws an WrongInfo with
;;             ;; embedded `dep-map`
;;             (let [dep-map (builder/dependency-map ^java.util.Map nmsp-map)]
;;               (try
;;                 (.accept on-completion (Optional/of nmsp-map)) ;not dep-map!
;;                 dep-map
;;                 (catch Throwable t
;;                   (throw (wrong/assoc-dep-map t dep-map))))))
;;           (report-failure ^void []
;;             (.accept on-completion (Optional/empty)))
;;           (try-build-and-report ^map []
;;             (try
;;               (-> (tclj0/build-all opts true)
;;                   (time)
;;                   (report-success))
;;               (catch tcljx.wrong.WrongInfo e
;;                 (report-failure)
;;                 (efmt/print-emap e)
;;                 (:emitter/namespaces (wrong/wr-data e)))
;;               (catch Throwable t
;;                 (report-failure)
;;                 (throw t))
;;               (finally                 ;use finally to preserve result
;;                 (println))))
;;           (keep-across-import [prior build]
;;             ;; preserve old rpaths and req-strs info if this namespace
;;             ;; was imported from class files instead of being compiled
;;             (if (builder/imported-namespace? build)
;;               (or prior {})  ;we may already know about this namespace
;;               build))]
;;     (let [dep-map (try-build-and-report)]
;;       (-> (merge-with keep-across-import prior-completed-map dep-map)
;;           (drop-bad-namespaces! opts builder/completed-namespace?)))))

(defn run
  (^boolean [^Options opts]
   (run opts
     (^Consumer fn [opt-nmsp-map]
      (when (.isPresent ^Optional opt-nmsp-map)
        (let [nmsp-map (.get ^Optional opt-nmsp-map)
              resultv (invoke/invoke-until-failure nmsp-map opts true)]
          (println (invoke/completion-report opts resultv)))))))
  (^boolean [^Options opts ^Consumer on-completion]
   (options/print-options opts)
   (when (nil? (.dest-dir opts))
     (options/abort "error: mode `--watch` requires a destination directory"))
   (tclj0/prepare-destination (.dest-dir opts) false) ;wipe destination dir
   (assert false)
   #_
   (loop [w (watcher/new-watcher (.sourcev opts))
          dep-map (build-pass opts on-completion {})]
     (let [w (watcher/wait-for-changes w (.wait-after-change-ms opts))
           pred-modified (watcher/mk-modified? w)
           dep-map (->> (fn ^boolean [dep-info]
                          (not (some pred-modified (:rpaths dep-info))))
                        (drop-bad-namespaces! dep-map opts))]
       (recur w (build-pass opts on-completion dep-map))))
   false))                                ;unreachable
