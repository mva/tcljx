;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.main.invoke
  (:require
   (tcljx.data [config :as cfg][wrong :as wrong] [type :as type] ir)
   (tcljx.nmspgen [runtime :as rt] [pkggen :as pkggen])
   (tcljx.main [options :as options])
   [tcljx.alpha.ptest__style :as style])
  (:import
   (tcljx.data.ir Entity Resolver ProvidedNamespace)
   (tcljx.nmspgen.pkggen PackageBuilder CodePromise)
   (tcljx.main.options Options)
   (java.lang.invoke MethodType MethodHandle MethodHandles MethodHandles$Lookup)))

(defn namespace-of ^ProvidedNamespace [^map known-ns ^symbol var-name]
  (or ^ProvidedNamespace (get known-ns (namespace var-name))
      (wrong/other (str "[namespace] no such namespace: "
                        (wrong/q (namespace var-name))))))

(defn def-value ^Object [^ProvidedNamespace pn ^symbol var-name]
  (if-some [def (-> (get (.globals pn) (namespace var-name))
                    ^CodePromise (get (name var-name)))]
    (.runtime-value def pkggen/pkg-build-public)
    (wrong/other (str "[var-value] no public def " (wrong/q var-name)))))

(defn- applicable ^MethodHandle [^map known-ns ^symbol fn-spec]
  (let [pn (namespace-of known-ns fn-spec)
        value (def-value pn fn-spec)
        l (MethodHandles/publicLookup)]
    (.bindTo (.resolveConstantDesc rt/mhd-apply l) value)))

(defn- result-style [^keyword res]
  (case res
    (:error :fail) :error
    :success :success
    :other :other
    nil :no-result))

(defn invoke-until-failure [^map known-ns ^Options opts
                            ^boolean print-var?]
  (letfn [(target-invoke-fnv [^Options opts]
            (letfn [(target-invoke-fn? ^boolean [^String s]
                      ;; note: don't produce empty namespace for "/..."
                      (not (neg? (.indexOf s (int \/) 1))))]
              (->> (filter target-invoke-fn? (.targets opts))
                   (mapv symbol))))
          (encode-result ^keyword [res]
            (if (and (some? res)
                     (type/same-name? clojure.lang.Keyword (.getClass res)))
              (case (str res)
                ":error" :error         ;non-zero error count
                ":fail" :fail           ;non-zero fail count
                ":success" :success
                #_else :other)          ;none of the above
              :other))]
    (let [fn-specv (target-invoke-fnv opts)
          n (count fn-specv)
          applicablev (mapv #(applicable known-ns %) fn-specv)
          resultv (vec (repeat n nil))]
      (loop [acc (vec (repeat n nil)), i 0]
        (if (= i n)
          acc
          (let [res (try
                      (when print-var?
                        (println)
                        (println (style/highlight-str "###")
                                 (str "calling " (nth fn-specv i))))
                      (-> (.invoke ^MethodHandle (nth applicablev i) nil)
                          (encode-result))
                      (catch Throwable t
                        (.printStackTrace t)
                        :error))
                acc (assoc acc (object i) res)]
            (if (identical? :error (result-style res))
              acc
              (recur acc (inc i)))))))))

(defn- invokes-successful? ^boolean [resultv]
  (or (nil? (seq resultv))
      (not (identical? :error (result-style (peek resultv))))))

(defn invoke-and-report ^boolean [^map known-ns ^Options opts]
  (let [resultv (invoke-until-failure known-ns opts false)]
    (invokes-successful? resultv)))

(defn completion-report ^String [^Options opts resultv]
  (letfn [(style ^String [^String s res]
            (case (result-style res)
              :error (style/error-str s)
              :success (style/success-str s)
              :other (style/highlight-str s)
              :no-result (style/dim-str s)))]
    (loop [acc (str (if (invokes-successful? resultv)
                      (style/success-str "###")
                      (style/error-str "###"))
                    " Completed:")
           [^String t :as targets] (seq (.targets opts))
           i 0]
      (if (nil? targets)
        acc
        (let [ns-str (options/target-ns-str t)]
          (if (options/target-invoke-fn? t)
            (recur (str acc " " (style/highlight-str ns-str)
                        (style (.substring t (.length ns-str)) (nth resultv i)))
                   (next targets)
                   (inc i))
            (recur (str acc " " (style/highlight-str ns-str))
                   (next targets)
                   i)))))))
