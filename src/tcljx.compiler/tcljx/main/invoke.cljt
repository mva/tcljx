;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.main.invoke
  (:require
   (tcljx.data [config :as cfg] [error :as error] [type :as type] ir)
   (tcljx.nmspgen [runtime :as rt] [pkggen :as pkggen])
   (tcljx.main [options :as options])
   (tcljx.alpha.pp [style :as style] [styled :as styled] [ansi :as ansi]))
  (:import
   (tcljx.data.ir Entity Resolver ProvidedNamespace)
   (tcljx.nmspgen.pkggen PackageBuilder CodePromise)
   (tcljx.main.options Options)
   (java.lang.invoke MethodType MethodHandle MethodHandles MethodHandles$Lookup)))

(defn- styled-str ^String [^long style ^String plain]
  (let [s (with-out-str
            (with-open [w (ansi/styled-writer *out*)]
              (styled/write w style plain)))]
    (.substring s 0 (dec (.length s)))))
(def ^:private highlight-str
  (partial styled-str (style/intensity style/intensity-bright)))
(def ^:private dim-str
  (partial styled-str (style/intensity style/intensity-faint)))
(def ^:private success-str
  (partial styled-str (style/fg style/green)))
(def ^:private error-str
  (partial styled-str (style/fg style/red)))


(defn namespace-of ^ProvidedNamespace [^map known-ns ^symbol var-name]
  (or ^ProvidedNamespace (get known-ns (namespace var-name))
      (error/throw "[namespace] no such namespace:" (sym (namespace var-name)))))

(defn def-value
  (^Object [^ProvidedNamespace pn ^symbol var-name]
   (def-value (pkggen/mk-pkg-importer (.capstone pn)) pn var-name))
  (^Object [^PackageBuilder pkg-build ^ProvidedNamespace pn ^symbol var-name]
   (if-some [def ^CodePromise (get (.globals pn) (name var-name))]
     (.runtime-value def pkg-build)
     (error/throw "[var-value] no public def" (sym var-name)))))

(defn- applicable ^MethodHandle [^map known-ns ^symbol fn-spec]
  (let [pn (namespace-of known-ns fn-spec)
        pkg-build (pkggen/mk-pkg-importer (.capstone pn))
        value (def-value pkg-build pn fn-spec)]
    (.bindTo (.resolveConstantDesc rt/mhd-apply (.lookup pkg-build)) value)))

(defn- result-style [^keyword res]
  (case res
    (:error :fail) :error
    :success :success
    :other :other
    nil :no-result))

(defn invoke-until-failure [^map known-ns ^Options opts
                            ^boolean print-var?]
  (letfn [(target-invoke-fnv [^Options opts]
            (letfn [(target-invoke-fn? ^boolean [^String s]
                      ;; note: don't produce empty namespace for "/..."
                      (not (neg? (.indexOf s (int \/) 1))))]
              (->> (filter target-invoke-fn? (.targets opts))
                   (mapv symbol))))
          (encode-result ^keyword [res]
            (if (and (some? res)
                     (type/same-name? clojure.lang.Keyword (.getClass res)))
              (case (str res)
                ":error" :error         ;non-zero error count
                ":fail" :fail           ;non-zero fail count
                ":success" :success
                #_else :other)          ;none of the above
              :other))]
    (let [fn-specv (target-invoke-fnv opts)
          n (count fn-specv)
          applicablev (mapv #(applicable known-ns %) fn-specv)
          resultv (vec (repeat n nil))]
      (loop [acc (vec (repeat n nil)), i 0]
        (if (= i n)
          acc
          (let [res (try
                      (when print-var?
                        (println)
                        (println (highlight-str "###")
                                 (str "calling " (nth fn-specv i))))
                      (-> (.invoke ^MethodHandle (nth applicablev i) nil)
                          (encode-result))
                      (catch Throwable t
                        (.printStackTrace t)
                        :error))
                acc (assoc acc (object i) res)]
            (if (identical? :error (result-style res))
              acc
              (recur acc (inc i)))))))))

(defn- invokes-successful? ^boolean [resultv]
  (or (nil? (seq resultv))
      (not (identical? :error (result-style (peek resultv))))))

(defn invoke-and-report ^boolean [^map known-ns ^Options opts]
  (let [resultv (invoke-until-failure known-ns opts false)]
    (invokes-successful? resultv)))

(defn completion-report ^String [^Options opts resultv]
  (letfn [(style ^String [^String s res]
            (case (result-style res)
              :error (error-str s)
              :success (success-str s)
              :other (highlight-str s)
              :no-result (dim-str s)))]
    (loop [acc (str (if (invokes-successful? resultv)
                      (success-str "###")
                      (error-str "###"))
                    " Completed:")
           [^String t :as targets] (seq (.targets opts))
           i 0]
      (if (nil? targets)
        acc
        (let [ns-str (options/target-ns-str t)]
          (if (options/target-invoke-fn? t)
            (recur (str acc " " (highlight-str ns-str)
                        (style (.substring t (.length ns-str)) (nth resultv i)))
                   (next targets)
                   (inc i))
            (recur (str acc " " (highlight-str ns-str))
                   (next targets)
                   i)))))))
