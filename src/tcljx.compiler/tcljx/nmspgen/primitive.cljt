(ns tcljx.nmspgen.primitive
  (:require
   (tcljx.data [config :as cfg] [type :as type] [resolve :as resolve]
               [reflect :as reflect] [ir :as ir] [code :as code]
               [wrong :as wrong])
   (tcljx.nmspgen [pkggen :as pkggen] [constgen :as constgen] [emit :as emit]
                  [insn :as insn] [runtime :as rt] [condgen :as condgen]
                  [opgen :as opgen] [junctgen :as junctgen])
   [tinyclj.string :as str])
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.ir CodeEmitter Loadable Entity ImmediateEntity Constant)
   (tcljx.nmspgen.insn Insn Insns)
   (tcljx.nmspgen.opgen Op2 OpSpec)
   (java.lang.classfile Opcode CodeBuilder TypeKind)
   (java.lang.classfile.constantpool ConstantPoolBuilder)
   (java.lang.constant ConstantDescs MethodTypeDesc)))

(deftype PrimitiveFnEntity []
  :abstract true
  ImmediateEntity
  (emit-insn* [_ _ _ _]
    (throw (IllegalStateException.)))
  (value-type [_]
    nil)
  (entity-id [_]
    ir/entity-id-def-primitive)
  (invoke-methods [ _]
    ir/invoke-methods-primitive-fn)
  (namespace-if-def [_]
    nil))
(defmacro with-primitive-invoke [^vector paramv & body]
  `(reify PrimitiveFnEntity (~'invoke* ~paramv ~@body)))

(deftype PrimitiveFnRecurEntity []
  :abstract true
  ImmediateEntity
  (emit-insn* [_ _ _ _]
    (throw (IllegalStateException.)))
  (value-type [_]
    nil)
  (entity-id [_]
    ir/entity-id-def-primitive)
  (invoke-methods [ _]
    ir/invoke-methods-primitive-recur)
  (namespace-if-def [_]
    nil))
(defmacro with-primitive-invoke-recur [^vector paramv & body]
  `(reify PrimitiveFnRecurEntity (~'invoke* ~paramv ~@body)))

(defn take-args
  (^Insns [^seq form ^Insns xs ^int n]
   (if (= (.length xs) n)
     xs
     (throw (wrong/wr-info (str (wrong/q (first form)) " takes " n
                                " argument" (when-not (= 1 n) "s")
                                (wrong/got-int (.length xs)))))))
  (^Insns [^seq form ^Insns xs ^int n-min ^int n-max]
   (cond
     (= n-min n-max) (take-args form xs n-max)
     (<= n-min (.length xs) n-max) xs
     :else (throw (wrong/wr-info (str (wrong/q (first form)) " takes " n-min
                                      " to " n-max " arguments"
                                      (wrong/got-int (.length xs))))))))
(defn take-arg ^Insn [^seq form ^Insns xs]
  (.get (take-args form xs 1) 0))

(letfn [(fold-cast-from ^Insn [^Class target-type c]
          ;; pre: `target-type` is primitive
          ;; pre: expression type of constant `c` is primitive
          (if (type/polymorphic? target-type)
            insn/insn-empty             ;casting some constant to void
            (-> (type/convert-from-constant target-type c)
                (insn/constant target-type))))]

  (defn- convert-to-primitive ^Insn [^Insn arg ^Class target-type ^long fctx]
    (or (when-some [c (insn/const-value arg)]
          (fold-cast-from target-type c))
        (insn/cast-to arg target-type fctx)))
  
  (defn- mk-convert-to-primitive ^Entity [^Wrapper target]
    (let [target-type (.class-primitive target)
          numeric? (.numeric? target)]
      (with-primitive-invoke [_ fctx form _ _ args]
        (let [arg (-> (take-arg form args) (insn/cast-to-logical))
              arg-type (insn/expr-type arg)]
          (cond
            (type/same? target-type arg-type)
            arg     ;elide conversion from primitive to same primitive
           
            (.isPrimitive arg-type)
            (convert-to-primitive arg target-type fctx)
           
            :else          ;here holds: `arg-type` is a reference type
            (insn/cast-to (cond-> arg
                            (and numeric?
                                 (not (.isAssignableFrom Number arg-type)))
                            (insn/cast-to Number fctx))
                          target-type fctx))))))

  (def ^:private convert-to-logical-truth
    (with-primitive-invoke [_ fctx form _ _ args]
      (-> (take-arg form args)
          (insn/cast-to-logical)
          (condgen/logical-truth fctx))))

  (def ^:private convert-to-object
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [arg (-> (take-arg form args) (insn/cast-to-logical))
            arg-tp (insn/expr-type arg)]
        (cond-> arg
          (.isPrimitive arg-tp)
          (insn/cast-to (.class-reference (type/of arg-tp)) fctx))))))

;;; ------------------------------------------------------------------------

(def ^:private no-iinc Integer/MIN_VALUE) ;outside range of IINC instruction
(defn iinc-delta ^int [^CodeEmitter entity ^CodeEmitter ce]
  (letfn [(delta ^int [^CodeEmitter arg]
            (if-some [c (constgen/const-value arg)]
              (.intValue ^Number c)  ;accept any number representation
              no-iinc))]
    (cond
      (identical? entity ce)      ;is entity passed through unchanged?
      0                  ;note: entity can be of any type in this case
      
      (instance? Op2 ce)
      (let [op2 ^Op2 ce]
        (case (.bytecode op2)
          #_iadd 96 (cond
                      (identical? entity (.ce0 op2)) (delta (.ce1 op2))
                      (identical? entity (.ce1 op2)) (delta (.ce0 op2))
                      :else no-iinc)
          #_isub 100 (if (identical? entity (.ce0 op2))
                       (- (delta (.ce1 op2))) ;ignore overflow: outside of short
                       no-iinc)
          #_else no-iinc))
      
      :else no-iinc)))
(defn valid-iinc-const? ^boolean [^int c]
  (= (short c) c))

(letfn [(consumed-as-numeric ^Wrapper [^Wrapper target ^Insns args ^int i]
          ;; pre: `target` is numeric type
          (let [tp (insn/expr-type args i)]
            (when (.isPrimitive tp)
              (let [wtp (type/of tp)]
                (when (type/primitive-assignable-from? target wtp)
                  (if (type/computational-int? wtp)
                    type/int   ;byte and short are computationally int
                    wtp))))))  ;int, long, float, or double
        (integral-type ^Wrapper [form ^Insns args ^int i]
          (or (consumed-as-numeric type/long args i)
              (throw (opgen/info-type-mismatch form args i "integral"))))
        (integer-type ^Wrapper [form ^Insns args ^int i]
          (or (consumed-as-numeric type/int args i)
              (throw (opgen/info-type-mismatch form args i "integer"))))
        (array-type-at-0 ^Class [form ^Insns args]
          (if (zero? (.length args))
            (throw (wrong/wr-info "expect array argument"))
            (let [tp (insn/expr-type args 0)]
              (if (.isArray tp)
                tp
                (throw (opgen/info-type-mismatch form args 0 "array"))))))
        (info-two-reference-args ^Throwable [form ^Insns args]
          (-> (str (wrong/q (first form)) " expects two reference arguments"
                   (wrong/got-types (insn/expr-types args)))
              (wrong/wr-info)))
        
        (unary ^CodeEmitter [^OpSpec op ^int opcd ^CodeEmitter ce ^long fctx]
          (condp identical? (.base-opcode op)
            Opcode/ISUB
            (if-some [c (constgen/const-value ce)]
              (opgen/folded-constant op opcd (.right-identity op) c)
              (Op2. (+ (.bytecode Opcode/INEG) opcd) opcd opcd ce nil fctx))
            Opcode/IDIV
            (if-some [c (constgen/const-value ce)]
              (opgen/folded-constant op opcd (.right-identity op) c)
              (opgen/op-2 op opcd opcd (.emitter insn/insn-int-one) ce fctx))
            #_else ce))
        (binary-numeric-insn ^Insn [^OpSpec op form ^Insns args ^long fctx]
          (let [args (take-args form args 2)
                wop-type (opgen/top-numeric-of form args)
                opcd (.computational-id wop-type)]
            (-> (opgen/op-2 op opcd opcd
                            (insn/emitter args 0) (insn/emitter args 1) fctx)
                (insn/mk-insn (.class-primitive wop-type)))))

        (emit-array-gets ^Class [^CodeBuilder xb ^long fctx ^Insns args ^int n]
          (let [atp (insn/expr-type args 0)]
            (when (emit/insn? xb fctx atp (insn/emitter args 0))
              (loop [tp atp, i 1]
                (if (<= i n)
                  (when (emit/insn? xb fctx Integer/TYPE (insn/emitter args i))
                    (let [ctp (.componentType tp)]
                      (emit/with-line-number xb fctx)
                      (.arrayLoad xb (TypeKind/from ctp))
                      (recur ctp (inc i))))
                  tp)))))]
  
  (defn mk-nary-numeric ^Entity [^OpSpec op]
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [args ^Insns args
            wop-type (opgen/top-type-of (.bottom-type op) (.top-type op)
                                           form args)
            op-type (.class-primitive wop-type)]
        (-> (case (.length args)
              0 (constgen/constant (.right-identity op) op-type)
              1 (unary op (.computational-id wop-type) (insn/emitter args 0) fctx)
              #_else (opgen/op-n op (.computational-id wop-type) (.emitters args) fctx))
            (insn/mk-insn op-type)))))

  (defn mk-binary-numeric ^Entity [^OpSpec op]
    (with-primitive-invoke [_ fctx form _ _ args]
      (binary-numeric-insn op form args fctx)))
  
  (defn mk-binary-xdiv-integral [^OpSpec op] ;aka 'quot
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [insn (binary-numeric-insn op form args fctx)
            op-type (.expr-type insn)]
        ;; FIXME... this does not work if the result is out of range of
        ;; long; maybe better: truncate with something along the line of
        ;; `(if (neg? x) (Math/ceil x) (Math/floor x))` (or put this
        ;; into a static method that first checks if the division
        ;; result is in range for long, and only falls back to the
        ;; ceil/floor variant if out of range)
        (cond-> insn
          (or (identical? Float/TYPE op-type) (identical? Double/TYPE op-type))
          (-> (convert-to-primitive Long/TYPE fctx)
              (convert-to-primitive op-type fctx))))))

  (def unary-bit-not
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [arg (take-arg form args)
            wop-type (integral-type form args 0)
            opcd (.computational-id wop-type)]
        (-> (opgen/op-2 opgen/op-xxor opcd opcd
                        (.emitter arg) (.emitter insn/insn-int-m1) fctx)
            (insn/mk-insn (.class-primitive wop-type))))))

  ;; FIXME... Only used for shifted-one.  Better alternative: add
  ;; primitive implementations of bit-set, bit-clear, bit-flip, and
  ;; bit-test.  Then get rid of shifted-one and xdefault.
  (def unary-xdefault 
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [arg (take-arg form args)
            tp (.expr-type arg)]
        (cond
          (type/void? tp) insn/insn-empty
          (.isPrimitive tp) (-> 0 (constgen/constant tp) (insn/mk-insn tp))
          :else insn/insn-null))))
  
  (defn mk-binary-shift ^Entity [^Opcode base-opc]
    (let [op (OpSpec. type/int type/long base-opc nil 0)]
      (with-primitive-invoke [_ fctx form _ _ args]
        (let [args (take-args form args 2)
              warg0 (integral-type form args 0)
              warg1 (integer-type form args 1)]
          (-> (opgen/op-2 op (.computational-id warg0) (.computational-id warg1)
                          (insn/emitter args 0) (insn/emitter args 1) fctx)
              (insn/mk-insn (.class-primitive warg0)))))))
  
  (defn mk-nary-compare ^Entity [^int cmp-opcd]
    (with-primitive-invoke [_ fctx form _ _ args]
      (junctgen/nary-compare cmp-opcd fctx args form)))

  (def nary-equiv
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [args ^Insns args]
        (if (type/all-monomorphic-primitive? (.expr-types args))
          ;; all arguments are non-void primitive: fall back to number compare
          (.invoke* (mk-nary-compare condgen/cmp-eq) fctx form nil -1 args)
          (junctgen/nary-compare -1 fctx args form)))))
  
  (def binary-identical
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [args (take-args form args 2)]
        (if (type/any-primitive? (.expr-types args))
          (throw (info-two-reference-args form args))
          (condgen/acmp (.get args 0) (.get args 1) condgen/cmp-eq fctx)))))

  (def array-length
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [atp (array-type-at-0 form args)
            arg (take-arg form args)]
        (-> (^CodeEmitter fn [xb _ _]
             (when (emit/insn? xb fctx atp (.emitter arg))
               (.arraylength xb)
               Integer/TYPE))
            (insn/mk-insn Integer/TYPE)))))
  (def nary-array-load
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [atp (array-type-at-0 form args)
            args (take-args form args 2 (inc (type/type-dimensions atp)))
            n (dec (.length args))]
        (dotimes [i n]
          (integer-type form args (inc i)))
        (-> (^CodeEmitter fn [xb _ _]
             (emit-array-gets xb fctx args n))
            (insn/mk-insn (type/component-type atp n))))))
  (def nary-array-store
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [atp (array-type-at-0 form args)
            args (take-args form args 3 (+ (type/type-dimensions atp) 2))
            n-gets (- (.length args) 3)
            tp-set (type/component-type atp (inc n-gets))
            ce-set (insn/emitter args (dec (.length args)))]
        (dotimes [i (inc n-gets)]
          (integer-type form args (inc i)))
        (insn/ensure-assignable tp-set args (dec (.length args)))
        (-> (^CodeEmitter fn [xb consumed-type _]
             (when-some [atp (emit-array-gets xb fctx args n-gets)]
               (when (emit/insn? xb fctx Integer/TYPE
                                 (insn/emitter args (inc n-gets)))
                 (when (emit/insn? xb fctx tp-set ce-set)
                   (let [void? (type/void? consumed-type)
                         tk (TypeKind/from tp-set)]
                     (emit/with-line-number xb fctx)
                     (when-not void?
                       (if (= (.slotSize tk) 1) (.dup_x2 xb) (.dup2_x2 xb)))
                     (.arrayStore xb tk)
                     (if void? Void/TYPE tp-set))))))
            (insn/mk-insn tp-set)))))
  (def array-clone
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [atp (array-type-at-0 form args)
            arg (take-arg form args)]
        (-> (^CodeEmitter fn [xb _ _]
             (when (emit/insn? xb fctx atp (.emitter arg))
               (let [cld (reflect/describe-class atp)]
                 (.invokevirtual xb cld "clone"
                                 (MethodTypeDesc/of ConstantDescs/CD_Object))
                 (.checkcast xb cld)
                 atp)))
            (insn/mk-insn atp)))))

  (def unary-not
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [arg (take-arg form args)]
        (-> (.emitter (condgen/logical-truth arg fctx))
            (condgen/negation fctx)
            (insn/mk-insn Boolean/TYPE)))))
  (def nary-and
    (with-primitive-invoke-recur [_ fctx form _ _ args]
      (junctgen/nary-and fctx args)))
  (def nary-or
    (with-primitive-invoke-recur [_ fctx form _ _ args]
      (junctgen/nary-or fctx args))))

;;; ------------------------------------------------------------------------

(def ^:private dyn-mark "\u0001")
(def ^:private const-mark "\u0002")
(def ^:private re-marks #"[\u0001\u0002]") ;note: hash of Pattern is not stable
(def ^:private cd-Objects (reflect/describe-class java.util.Objects))
(def ^:private mtd-String-Object-String
  (MethodTypeDesc/of ConstantDescs/CD_String
                     ConstantDescs/CD_Object ConstantDescs/CD_String))
(letfn [(prepare-concat-args ^Insns [^Insns args ^long fctx]
          ;; arguments are converted to their logical types and, if
          ;; they are of reference type, are then passed through
          ;; a "nil to empty string" filter
          (let [args' (insn/copy-of-insns args)]
            (loop [i (dec (.length args'))]
              (when-not (neg? i)
                (let [insn (insn/cast-to-logical args' i)
                      ce (.emitter insn)
                      tp (insn/expr-type insn)]
                  (.set args' i
                        (if (or (.isPrimitive tp) (ir/loadable? ce))
                          insn ;note: *all* constants are passed through
                          (-> (^CodeEmitter fn [xb _ _]
                               (when (emit/insn? xb fctx tp ce)
                                 (-> (.ldc xb "")
                                     (.invokestatic cd-Objects "toString"
                                                    mtd-String-Object-String))
                                 String))
                              (insn/mk-insn String))))
                  (recur (dec i)))))
            args'))
        (consts-to-lces ^java.util.List [^ConstantPoolBuilder cpb insns]
          (for [^Insn insn insns]
            (Constant/.loadable-entry (.emitter insn) cpb true)))
        (insn-str ^Insn [^String rstr ^Insns inv-args ^seq const-args
                         ^long fctx]
          (let [recipe (insn/constant rstr String)]
            (cond
              (and (empty? const-args) (.empty? inv-args))
              recipe
               
              (and (= rstr dyn-mark)
                   (type/same? String (insn/expr-type inv-args 0)))
              (.get inv-args 0)   ;output of mhd-Objects-toString call
               
              (= rstr const-mark)
              (first const-args)

              :else
              (-> (^CodeEmitter fn [xb _ _]
                   (let [cpb (.constantPool xb)
                         atypes (insn/logical-types inv-args)
                         mhe (.methodHandleEntry cpb rt/bsm-concat)
                         bsm (.bsmEntry cpb mhe (->> (cons recipe const-args)
                                                     (consts-to-lces cpb)))
                         mtd (insn/mtd-of-poly String atypes)
                         nat (.nameAndTypeEntry cpb ConstantDescs/DEFAULT_NAME
                                                mtd)]
                     (when (emit/typed-insns? xb fctx atypes
                                              (.emitters inv-args))
                       (-> (emit/with-line-number xb fctx)
                           (.invokedynamic (.invokeDynamicEntry cpb bsm nat)))
                       String)))
                  (insn/mk-insn String)))))]
  
  (def string-concat
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [args (prepare-concat-args args fctx)]
        (loop [rparts nil, dyn-args nil, const-args nil, i 0]
          (if (= i (.length args))
            (insn-str (str/join "" (reverse rparts))
                      (insn/insns-of* (reverse dyn-args))
                      (reverse const-args) fctx)
           
            (let [x ^Insn (.get args i), ce (.emitter x)]
              (if (ir/loadable? ce)
                (let [s (str (Loadable/.datafy ce))
                      x-str (insn/constant s String)]
                  (if (re-find re-marks s)
                    (recur (cons const-mark rparts) dyn-args
                           (cons x-str const-args) (inc i))
                    (recur (cons s rparts) dyn-args const-args (inc i))))
                (recur (cons dyn-mark rparts) (cons x dyn-args)
                       const-args (inc i))))))))))

  (def list-primitive   ;matches InsnFactory.new-collection() for list
    (with-primitive-invoke [_ fctx form _ _ args]
      (let [args ^Insns args]
        (if (insn/loadables? args)
          (-> (constgen/collection (.emitters args) type/list false)
              (insn/mk-insn type/list))
          (insn/invoke-runtime (resolve/literal-factory type/list) args)))))

;;; ------------------------------------------------------------------------

(def primitive-nmsp-globals
  (letfn [(primitive ^map [^map acc ^String nm ^Entity inv]
            (assoc acc nm inv))
          (nary-numeric ^map [^map acc ^String nm ^OpSpec op]
            (primitive acc nm (mk-nary-numeric op)))
          (conversions ^map [^map acc]
            (-> (reduce (fn ^map [^map acc ^Wrapper wtp]
                          (let [tp (.class-primitive wtp)
                                nm (.getSimpleName tp)]
                            (primitive acc nm (mk-convert-to-primitive wtp))))
                        acc type/primitive-types)
                ;; provide Clojure rules for (boolean ...)
                (primitive "boolean" convert-to-logical-truth)
                (primitive "object" convert-to-object)))]
    (-> {}
        (conversions)
        (nary-numeric "+" (opgen/numeric-op type/int Opcode/IADD
                                            insn/insn-int-zero
                                            insn/insn-int-zero))
        (nary-numeric "-" (opgen/numeric-op type/int Opcode/ISUB
                                            nil insn/insn-int-zero))
        (nary-numeric "*" (opgen/numeric-op type/int Opcode/IMUL
                                            insn/insn-int-one
                                            insn/insn-int-one))
        (nary-numeric "/" (opgen/numeric-op type/float Opcode/IDIV
                                            nil insn/insn-float-one))
        (primitive "quot" (-> (opgen/numeric-op type/int Opcode/IDIV
                                                nil insn/insn-int-one)
                              (mk-binary-xdiv-integral)))
        (primitive "rem" (-> (opgen/numeric-op type/int Opcode/IREM
                                               nil insn/insn-int-one)
                             (mk-binary-numeric)))

        (nary-numeric "bit-and" opgen/op-xand)
        (nary-numeric "bit-or" opgen/op-xor)
        (nary-numeric "bit-xor" opgen/op-xxor)
        (primitive "bit-not" unary-bit-not)
        (primitive "xdefault" unary-xdefault)
        (primitive "bit-shift-left" (mk-binary-shift Opcode/ISHL))
        (primitive "bit-shift-right" (mk-binary-shift Opcode/ISHR))
        (primitive "unsigned-bit-shift-right" (mk-binary-shift Opcode/IUSHR))
        
        (primitive "=" nary-equiv)
        (primitive "==" (mk-nary-compare condgen/cmp-eq))
        (primitive "<" (mk-nary-compare condgen/cmp-lt))
        (primitive ">=" (mk-nary-compare condgen/cmp-ge))
        (primitive ">" (mk-nary-compare condgen/cmp-gt))
        (primitive "<=" (mk-nary-compare condgen/cmp-le))

        (primitive "alength" array-length)
        (primitive "aget" nary-array-load)
        (primitive "aset" nary-array-store)
        (primitive "aclone" array-clone)

        ;; FIXME... Tune implementations of "and"/"or" further.
        ;; The "all boolean" variant should be able to encode the
        ;; result via simpler control flow.
        ;;
        ;; The control flow of "and" seems to fit the branch-if-false
        ;; setup nicely.  For the boolean case, replacing "(or ...)"
        ;; with "(not (not (and ...))" and using De Morgan is an
        ;; option.  But not for the general case, because it produces
        ;; values of arbitrary types.  Which unfortunately means 2*2
        ;; different code paths in total.
        (primitive "not" unary-not)
        (primitive "and" nary-and)
        (primitive "or" nary-or)
        (primitive "identical?" binary-identical)
        (primitive "list" list-primitive)
        (primitive "str" string-concat))))
