(ns tcljx.nmspgen.defgen
  (:require
   (tcljx.data
    [config :as cfg] [reflect :as reflect] [resolve :as resolve] [type :as type]
    [member :as member] [context :as context] [wrong :as wrong] [ir :as ir])
   (tcljx.nmspgen
    [classfile :as classfile] [util :as util] segment [runtime :as rt]
    [constgen :as constgen] [insn :as insn] [emit :as emit]))
  (:import
   (tcljx.data.ir CodeEmitter Entity FnPromise BindableEntity ImmediateEntity
                  Assignable Binding)
   (tcljx.nmspgen.segment CodePromise)
   (tcljx.nmspgen.insn Insn)
   (java.lang.classfile ClassBuilder ClassFileBuilder FieldBuilder MethodBuilder
                        CodeBuilder ClassFileElement AnnotationElement
                        Annotation Signature)
   (java.lang.classfile.attribute RuntimeVisibleAnnotationsAttribute
                                  SignatureAttribute)   
   (java.lang.constant MethodTypeDesc ClassDesc ConstantDescs)
   (java.util.function Consumer)))

(defn apply-private ^int [^int flags ^boolean private?]
  (cond-> flags private? (bit-and-not (ir/acc* public))))

(deftype DefField [^int entity-id ^int flags ^ClassDesc owner ^String mnm
                   ^Class tp ^CodeEmitter init-ce]
  CodeEmitter
  (emit-insn* [this xb consumed-type _]
    (util/with-void-empty-if-requested consumed-type
      (.getstatic xb owner mnm (.value-type-exact this))
      tp))
  ImmediateEntity
  (value-type [this]
    tp)
  (value-type-exact [_]
    (ir/value-type-exact init-ce tp))
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    (if (member/acc-final? flags)
      (ir/invoke-methods-of init-ce)
      ir/invoke-methods-dynamic))
  (invoke* [this fctx form _ m-idx xs]
    (.invoke* ^Entity init-ce fctx form this m-idx xs))
  (namespace-if-def [_]
    (if (identical? rt/ClojureRT owner)
      cfg/core-lib ;predefined core def introduced by publics/initial-globals
      (.packageName owner)))
  BindableEntity
  (binding-mode-let [_]
    (if (member/acc-final? flags)
      ir/bound-as-alias
      ir/bound-by-copy-to-local))
  (emit-setup-code? [this xb _ _]
    (or (constgen/emitter-empty? init-ce)
        (when (emit/insn? xb context/fctx-none tp init-ce)
          (.putstatic xb owner mnm (.value-type-exact this))
          true)))
  Assignable
  (set-expr* [_ fctx value]
    nil)
  (redef-expr* [this fctx value]
    (when-not (member/acc-final? flags)
      (insn/ensure-assignable (.value-type this) value)
      (-> (^CodeEmitter fn [xb consumed-type _]
           (when (emit/insn? xb fctx tp (.emitter value))
             (util/with-dup-unless-void-> xb consumed-type tp
               (.putstatic owner mnm (.value-type-exact this)))))
          (insn/mk-insn tp))))
  
  CodePromise
  (expr-of [this]
    (insn/mk-insn this (.value-type this)))
  (child-methods [_]
    nil)
  (!nested-parts [_]
    nil)
  (generate-and-deliver [this sb _ ann-elem]
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (->> (^Consumer fn ^void [^FieldBuilder fb]
                (.withFlags fb flags)
                (when (some? ann-elem) (.with fb ann-elem)))
               (.withField cb mnm (.value-type-exact this))))
         (.add-elements sb)))
  (runtime-value [this pkg-build]
    (.get-static-field pkg-build owner mnm (.value-type-exact this))))
(defn- promise-field ^CodePromise [^int entity-id ^int flags ^ClassDesc owner
                                   ^String nm ^Class tp ^CodeEmitter init-ce]
  (assert (some? init-ce))
  (DefField. entity-id flags owner (cfg/munge-name nm) tp init-ce))

(deftype DefMethod [^int entity-id ^int flags ^ClassDesc owner ^String mnm
                    ^Class tp ^Entity init-ce]
  CodeEmitter
  (emit-insn* [this xb consumed-type _]
    (util/with-void-empty-if-requested consumed-type
      (let [tpd (.value-type-exact this)]
        (.invokestatic xb owner mnm (MethodTypeDesc/of tpd))
        tp)))
  ImmediateEntity
  (value-type [this]
    tp)
  (value-type-exact [_]
    (ir/value-type-exact init-ce tp))
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    (.invoke-methods init-ce))
  (invoke* [this fctx form _ m-idx xs]
    (.invoke* init-ce fctx form this m-idx xs))
  (namespace-if-def [_]
    (.packageName owner))
  BindableEntity
  (binding-mode-let [_]
    ir/bound-as-alias)
  (emit-setup-code? [_ xb _ _]
    true)
  CodePromise
  (expr-of [this]
    (insn/mk-insn this (.value-type this)))
  (child-methods [_]
    nil)
  (!nested-parts [_]
    nil)
  (generate-and-deliver [this sb _ ann-elem]
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (->> (^Consumer fn ^void [^MethodBuilder mb]
                (when (some? ann-elem) (.with mb ann-elem))
                (->> (^Consumer fn ^void [^CodeBuilder xb]
                      (emit/then-leave? xb context/fctx-none tp init-ce true))
                     (.withCode mb)))
               (.withMethod cb mnm (MethodTypeDesc/of (.value-type-exact this))
                            flags)))
         (.add-elements sb)))
  (runtime-value [this pkg-build]
    (.get-static-method pkg-build owner mnm (.value-type-exact this))))
(defn- promise-method ^CodePromise [^int entity-id ^boolean private?
                                    ^ClassDesc owner ^String nm ^Class tp
                                    ^Entity init-ce]
  (let [flags (apply-private classfile/acc-method-static private?)]
    (DefMethod. entity-id flags owner (cfg/munge-name nm) tp init-ce)))
(defn- wrap-loadable-as-method? ^boolean [^CodeEmitter ce]
  (when (instance? ImmediateEntity ce) ;want JvmConstant or FnStatic only
    ;; Note: Exposing FnStatic as an on-demand LDC of a dynamic
    ;; constant avoids materializing lots and lots of fn
    ;; instances (and method handles!) that are never used as a value.
    (not= (ir/closure-level ce) ir/closure-level-def)))

(deftype DefOfPromise [^int entity-id ^boolean private? ^ClassDesc owner
                       ^String nm ^Class tp ^FnPromise init-ce
                       ^:unsynchronized-mutable ^BindableEntity __entity]
  CodeEmitter
  (emit-insn* [_ xb consumed-type then-leave?]
    (.emit-insn* __entity xb consumed-type then-leave?))
  ImmediateEntity
  (value-type [this]
    tp)
  (value-type-exact [_]
    (.value-type-exact __entity))
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    (.invoke-methods init-ce))
  (invoke* [this fctx form opt-f m-idx xs]
    (.invoke* init-ce fctx form this m-idx xs))
  (namespace-if-def [_]
    (.packageName owner))
  BindableEntity
  (binding-mode-let [_]
    ir/bound-as-alias)
  (emit-setup-code? [_ xb param-no name]
    (.emit-setup-code? __entity xb param-no name))
  CodePromise
  (expr-of [this]
    (insn/mk-insn this tp))
  (child-methods [_]
    nil)
  (!nested-parts [_]
    nil)
  (generate-and-deliver [_ sb env-factory ann-elem]
    (let [ce* (.get-emit-entity init-ce)
          p (if (wrap-loadable-as-method? ce*)
              (promise-method entity-id private? owner nm tp ce*)
              (let [flags (apply-private (ir/acc* public static final) private?)]
                (promise-field entity-id flags owner nm tp ce*)))]
      (set! __entity (-> p .expr-of .emitter))
      (.generate-and-deliver p sb env-factory ann-elem)))
  (runtime-value [_ pkg-build]
    (if (some? __entity)
      (.runtime-value ^CodePromise __entity pkg-build)
      (throw (tcljx.data.ir.ImplementationUnavailableException.)))))

(defn promise-def-mutable ^CodePromise [^int entity-id ^boolean private?
                                        ^ClassDesc owner ^String nm ^Insn init]
  (let [tp (insn/logical-type init), init-ce (insn/emitter init)
        flags (apply-private (ir/acc* public static volatile) private?)]
    (promise-field entity-id flags owner nm tp init-ce)))

(defn promise-def-immutable ^CodePromise [^int entity-id ^boolean private?
                                          ^ClassDesc owner ^String nm ^Insn init]
  (let [tp (insn/logical-type init), init-ce (insn/emitter init)]
    (cond
      (wrap-loadable-as-method? init-ce)
      (promise-method entity-id private? owner nm tp init-ce)
      (instance? FnPromise init-ce)
      (DefOfPromise. entity-id private? owner nm tp init-ce nil)
      :else
      (let [flags (apply-private (ir/acc* public static final) private?)]
        (promise-field entity-id flags owner nm tp init-ce)))))

(defn promise-def-alias ^CodePromise [^boolean private? ^String nm
                                      ^Entity other-ent ^String other-qname]
  (let [mnm (cfg/munge-name nm)]
    (reify CodePromise
      (expr-of [_]
        (insn/mk-insn other-ent (.value-type other-ent)))
      (child-methods [_]
        nil)
      (!nested-parts [_]
        nil)
      (generate-and-deliver [_ sb _ _]
        (->> (^Consumer fn ^void [^ClassBuilder cb]
              (->> (^Consumer fn ^void [^FieldBuilder fb]
                    (let [ae (AnnotationElement/ofString "of" other-qname)
                          flags (apply-private (ir/acc* public static final)
                                               private?)]
                      (-> (.withFlags fb flags)
                          (.with (RuntimeVisibleAnnotationsAttribute/of
                                  (Annotation/of rt/Alias ae))))))
                   (.withField cb mnm ConstantDescs/CD_Object)))
             (.add-elements sb))))))

;;; ------------------------------------------------------------------------

(defn- annotation-macro ^ClassFileElement [^String fq-value]
  (let [ae (if (some? fq-value)
             (doto (new AnnotationElement/1 1)
               (aset 0 (AnnotationElement/ofString "macroValue" fq-value)))
             (new AnnotationElement/1 0))
        ann (doto (new Annotation/1 1)
              (aset 0 (Annotation/of rt/Macro ae)))]
    (RuntimeVisibleAnnotationsAttribute/of ann)))

(deftype DefMacro [^ImmediateEntity dimm ^String fq-value ^CodeEmitter ce-value
                   ^:volatile-mutable ^Object __runtime-value]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (if (some? ce-value)
      (.emit-insn* ce-value xb consumed-type then-leave?)
      Void/TYPE))
  ImmediateEntity
  (value-type [this]
    (when (some? ce-value)
      type/AFnMh))
  (value-type-exact [_]
    (.value-type-exact dimm))
  (entity-id [_]
    ir/entity-id-def-macro)
  (invoke-methods [_]
    ir/invoke-methods-dynamic)
  (namespace-if-def [_]
    (.namespace-if-def dimm))
  
  BindableEntity
  (binding-mode-let [_]
    ir/bound-as-alias)
  
  CodePromise
  (expr-of [this]
    (insn/mk-insn this (.value-type this)))
  (child-methods [_]
    nil)
  (!nested-parts [_]
    nil)
  (generate-and-deliver [this sb env-factory _]
    (.generate-and-deliver ^CodePromise dimm sb env-factory
                           (annotation-macro fq-value)))
  (runtime-value [this pkg-build]
    (if (some? __runtime-value)         ;only caches non-nil values
      __runtime-value
      (let [x (try ;use let to have an empty operand stack for the try
                (.runtime-value ^CodePromise dimm pkg-build)
                (catch java.lang.ReflectiveOperationException _
                  (throw (tcljx.data.ir.ImplementationUnavailableException.))))]
        (set! __runtime-value x)))))

(defn promise-def-macro ^CodePromise [^boolean private? ^ClassDesc owner
                                      ^String nm ^Insn init
                                      ^String fq-value ^CodeEmitter ce-value]
  (let [dimm (promise-def-immutable ir/entity-id-def-macro private?
                                    owner nm init)]
    (DefMacro. ^ImmediateEntity dimm fq-value ce-value nil)))

;;; ------------------------------------------------------------------------

(deftype DefVarDeref [^DefField df ^Class deref-tp]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (when (.emit-insn* df xb type/Var then-leave?)
      (.invokevirtual xb rt/Var "deref" rt/mtd-Object-void)
      Object))
  ImmediateEntity
  (value-type [this]
    deref-tp)
  (value-type-exact [_]
    (reflect/describe-class deref-tp))
  (entity-id [_]
    ir/entity-id-def-var)
  (invoke-methods [_]
    ir/invoke-methods-dynamic)
  (namespace-if-def [_]
    (.namespace-if-def df))
  BindableEntity
  (binding-mode-let [_]
    ir/bound-by-copy-to-local)
  (emit-setup-code? [this xb param-no name]
    (.emit-setup-code? df xb param-no name))
  Assignable
  (set-expr* [_ fctx value]
    (-> (^CodeEmitter fn [xb consumed-type _]
         (.emit-insn* df xb type/Var false)
         (when (emit/insn? xb fctx deref-tp (.emitter value))
           (.invokevirtual xb rt/Var "set" rt/mtd-Object-Object)
           Object))
        (insn/mk-insn deref-tp)))
  (redef-expr* [_ fctx value]
    (insn/ensure-assignable deref-tp value)
    (-> (^CodeEmitter fn [xb consumed-type _]
         (when (emit/insn? xb fctx type/Var df)
           (when (emit/insn? xb fctx Object (.emitter value))
             (util/with-dup-unless-void-> xb consumed-type Object
               (.invokevirtual rt/Var "bindRoot" rt/mtd-void-Object)))))
        (insn/mk-insn deref-tp)))
         
  CodePromise
  (expr-of [this]
    (insn/mk-insn this (.value-type this)))
  (child-methods [_]
    nil)
  (!nested-parts [_]
    nil)
  (generate-and-deliver [this sb env-factory _]
    (let [signature (-> (str "Lclojure/lang/Var<"
                             (.descriptorString deref-tp) ">;")
                        (Signature/parseFrom)
                        (SignatureAttribute/of))]
      (.generate-and-deliver df sb env-factory signature)))
  (runtime-value [this pkg-build]
    (throw (IllegalStateException.))))

(defn promise-def-var ^DefVarDeref [^boolean private?
                                    ^ClassDesc owner ^String nm
                                    ^Insn init-var ^Class tp-var
                                    ^boolean dynamic? ^Insn x-meta]
  (letfn [(create-var ^Insn []
            (let [x-nmsp (insn/constant (.packageName owner) String)
                  x-nm (insn/constant nm String)]
              (if (constgen/emitter-empty? (.emitter init-var))
                (-> (resolve/static-method type/ClojureRT "var" String String)
                    (insn/invoke-member nil (insn/insns-of x-nmsp x-nm)))
                (-> (resolve/static-method type/ClojureRT "var" String String Object)
                    (insn/invoke-member nil (insn/insns-of x-nmsp x-nm init-var))))))
          (set-meta ^Insn [^Insn x]
            ;; resolve "setMeta" late to pick up runtime type/map
            (-> (resolve/virtual-method type/Var "setMeta" type/map)
                (insn/invoke-member x (insn/insns-of x-meta))))
          (set-dynamic ^Insn [^Insn x]
            (-> (resolve/virtual-method type/Var "setDynamic")
                (insn/invoke-member x (insn/insns-of))))]
    (let [init (cond-> (create-var)
                 (some? x-meta) (set-meta)
                 dynamic? (set-dynamic))
          flags (apply-private (ir/acc* public static final) private?)]
      (-> (promise-field ir/entity-id-def flags owner nm (.expr-type init)
                         (.emitter init))
          (DefVarDeref. tp-var)))))
