(ns tcljx.nmspgen.junctgen
  (:require
   (tcljx.data [type :as type] [wrong :as wrong] [ir :as ir])
   (tcljx.nmspgen [util :as util] [emit :as emit] [insn :as insn]
                  [constgen :as constgen] [condgen :as condgen] [opgen :as opgen]))
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.ir CodeEmitter Entity Binding)
   (tcljx.nmspgen.insn Insn Insns)
   (tcljx.nmspgen.condgen Branching)
   (java.lang.classfile CodeBuilder Label)
   (java.util.function Consumer)))

(defn- binding-of ^Binding [^Class tp ^Insns xs ^int i]
  ;; pre: `x` is non-environment value
  (let [ce (insn/emitter xs i)]
    (if (= (ir/binding-mode-let ce) ir/bound-as-alias)
      (ir/mk-binding ce "temp-alias" true)
      (-> (util/entity-local tp 0 ce)
          (ir/mk-binding "temp" false)))))

(defn- bound-value ^Insn [^Class tp ^Binding bnd ^Insns args ^int i]
  (if (.alias? bnd)
    ^Insn (.get args i)
    (insn/mk-insn (.bound-to bnd) tp)))

;;; Simplified version of `block-bindings` from tcljx.nmspgen.codegen:
(defn- block-bindings [^long fctx ^Binding/1 bnds ^Insn body]
  (if (ir/every-binding-alias? bnds)
    body
    (-> (^CodeEmitter fn [xb consumed-type then-leave?]
         (.block xb (^Consumer fn ^void [^CodeBuilder xb]
                     (when (emit/statms? xb bnds)
                       (emit/then-leave? xb fctx consumed-type (.emitter body)
                                         then-leave?))))
         (when-not then-leave?
           consumed-type))
        (insn/mk-insn (insn/expr-type body)))))
(defn- block-binding ^Insn [^long fctx ^Binding bnd ^Insn body]
  (block-bindings fctx (doto (new Binding/1 1) (aset 0 bnd)) body))

(defn- logical-join-type ^Class [^Insns args]
  (-> (condgen/join-type (.expr-types args) 0 (.length args))
      (type/expr-to-logical)))

(defn- boolean-temp? ^boolean [^Insns args ^int i]
  (type/same? Boolean/TYPE (insn/expr-type args i)))

(defn- strict-boolean? ^boolean [^Class join-type ^Class/1 expr-types]
  (when (type/same? Boolean/TYPE join-type) ;cheap test does not reject recur
    (loop [i (dec (alength expr-types))]
      (cond (< i 0) true
            (type/same? Boolean/TYPE (aget expr-types i)) (recur (dec i))
            :else false))))


(defn- branch-on-false? ^boolean [^CodeBuilder xb ^long fctx ^CodeEmitter/1 ces
                                  ^Label target-f]
  (loop [i 0]
    (if (< i (alength ces))
      (let [ce (aget ces i)]
        (if (identical? constgen/entity-false ce)
          (do (.goto_ xb target-f) false)
          (when (if (instance? Branching ce)
                  (.emit-branch-on? ^Branching ce xb false target-f)
                  (or (identical? constgen/entity-true ce)
                      (when (emit/insn? xb fctx Boolean/TYPE ce)
                        (.ifeq xb target-f) true)))
            (recur (inc i)))))
      true)))
(defn- branching-and ^Branching [^long fctx ^Insns args] ;pre: 2+ boolean args
  (reify Branching
    (emit-insn* [this xb consumed-type then-leave?]
      (.emit-insn* (condgen/predicate this fctx) xb consumed-type then-leave?))
    (emit-branch-on? [_ xb outcome? target-o]
      (if outcome?
        (let [target-f (.newLabel xb)]
          (when (branch-on-false? xb fctx (.emitters args) target-f)
            (.goto_ xb target-o))
          (.labelBinding xb target-f)
          true)             ;dead code if there is no jump to target-f
        (branch-on-false? xb fctx (.emitters args) target-o)))))
(defn nary-and* ^Insn [^long fctx ^Insns args] ;pre: 2+ args
  (let [tp (logical-join-type args)]
    ;; straightforward translation of macro clojure.core/and
    (letfn [(test-for-and ^Insn [^int i ^Insn x-test ^CodeEmitter on-false]
              (-> (.emitter (condgen/logical-truth x-test fctx))
                  (condgen/mk-if tp (.emitter (expand (inc i))) on-false fctx)
                  (insn/mk-insn tp)))
            (expand ^Insn [^int i]
              (cond (>= i (dec (.length args)))
                    (.get args i)
                    
                    (boolean-temp? args i)
                    (test-for-and i (.get args i) constgen/entity-false)
                    
                    :else (let [bnd (binding-of tp args i)
                                x-temp (bound-value tp bnd args i)]
                            (->> (test-for-and i x-temp (.emitter x-temp))
                                 (block-binding fctx bnd)))))]
      (if (strict-boolean? tp (.expr-types args))
        (insn/mk-insn (branching-and fctx args) Boolean/TYPE)
        (expand 0)))))

(defn- branch-on-true? ^boolean [^CodeBuilder xb ^long fctx ^CodeEmitter/1 ces
                                 ^Label target-t]
  (loop [i 0]
    (if (< i (alength ces))
      (let [ce (aget ces i)]
        (if (identical? constgen/entity-true ce)
          (do (.goto_ xb target-t) false)
          (when (if (instance? Branching ce)
                  (.emit-branch-on? ^Branching ce xb true target-t)
                  (or (identical? constgen/entity-false ce)
                      (when (emit/insn? xb fctx Boolean/TYPE ce)
                        (.ifne xb target-t) true)))
            (recur (inc i)))))
      true)))
(defn- branching-or ^Branching [^long fctx ^Insns args] ;pre: 2+ boolean args
  (reify Branching
    (emit-insn* [this xb consumed-type then-leave?]
      (.emit-insn* (condgen/predicate this fctx) xb consumed-type then-leave?))
    (emit-branch-on? [_ xb outcome? target-o]
      (if outcome?
        (branch-on-true? xb fctx (.emitters args) target-o)
        (let [target-t (.newLabel xb)]
          (when (branch-on-true? xb fctx (.emitters args) target-t)
            (.goto_ xb target-o))
          (.labelBinding xb target-t)
          true)))))         ;dead code if there is no jump to target-t
(defn nary-or* ^Insn [^long fctx ^Insns args] ;pre: 2+ args
  (let [tp (logical-join-type args)]
    ;; straightforward translation of macro clojure.core/or
    (letfn [(test-for-or ^Insn [^int i ^Insn x-test ^CodeEmitter on-true]
              (-> (.emitter (condgen/logical-truth x-test fctx))
                  (condgen/mk-if tp on-true (.emitter (expand (inc i))) fctx)
                  (insn/mk-insn tp)))
            (expand ^Insn [^int i]
              (cond (>= i (dec (.length args)))
                    (.get args i)

                    (boolean-temp? args i)
                    (test-for-or i (.get args i) constgen/entity-true)

                    :else (let [bnd (binding-of tp args i)
                                x-temp (bound-value tp bnd args i)]
                            (->> (test-for-or i x-temp (.emitter x-temp))
                                 (block-binding fctx bnd)))))]
      (if (strict-boolean? tp (.expr-types args))
        (insn/mk-insn (branching-or fctx args) Boolean/TYPE)
        (expand 0)))))


(defn nary-compare ^Insn [^int cmp-opcd ^long fctx ^Insns args form]
  (let [wtop (when-not (neg? cmp-opcd)  ;`wtop` of equiv is nil
               (or (when (= cmp-opcd condgen/cmp-eq)
                     (type/of-all (.expr-types args)))
                   (opgen/top-numeric-of form args)))]
    (case (.length args)
      0 (throw (wrong/wr-info "missing argument"))
      1 (insn/progn args insn/insn-true)
      2 (condgen/xcmp-2 wtop (.get args 0) (.get args 1) cmp-opcd fctx)
      #_else (let [tp (.class-primitive wtop)
                   n (.length args)
                   bnds (new Binding/1 n)
                   xs (insn/mk-insns* n)
                   cmps (insn/mk-insns* (dec n))] ;length is at least two
               (dotimes [i n]
                 (let [bnd (binding-of tp args i)]
                   (aset bnds i bnd)
                   (.set xs i (bound-value tp bnd args i))))
               (dotimes [i (dec n)]
                 (.set cmps i (condgen/xcmp-2 wtop (.get xs i) (.get xs (inc i))
                                              cmp-opcd fctx)))
               (block-bindings fctx bnds (nary-and* fctx cmps))))))
