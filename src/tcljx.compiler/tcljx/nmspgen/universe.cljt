;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.nmspgen.universe
  (:require
   (tcljx.data
    [config :as cfg] [files :as files] [resolve :as resolve] [reflect :as reflect]
    [meta :as meta] [error :as error] [context :as context] [ir :as ir])
   (tcljx.parser
    [reader :as reader] [form :as form] [parse :as parse]
    [namespace :as namespace])
   (tcljx.nmspgen
    [pkggen :as pkggen] [constgen :as constgen] [emit :as emit] [insn :as insn]
    [macro :as macro] [codegen :as codegen] [entity :as entity]
    [envgen :as envgen] [defgen :as defgen] [fngen :as fngen]
    [primitive :as primitive]
    [publics :as publics]))
  (:import
   (tcljx.data.ir Resolver FormReader NamespaceProvider ProvidedNamespace
                  NmspClass NamespaceBuilder Require
                  Expr Entity ImmediateEntity ExprFactory EntityFactory Parser)
   (tcljx.nmspgen.runtime Runtime)
   (tcljx.nmspgen.destdir Destination)
   (tcljx.nmspgen.pkggen PackageBuilder CodePromise)
   (tcljx.nmspgen.insn Insn)
   (java.lang.invoke MethodHandle)
   (java.util ArrayList HashSet)))

(defn- add-required-globals ^map [^map globals ^Require require ^map other]
  (let [rename (or (.rename-strs require) {})
        assoc-req (fn assoc-req
                    (^map [^map acc ^String nm]
                     (if-some [ent (get other nm)]
                       (assoc-req acc nm ent)
                       (error/throw "no public var" (sym nm) "in namespace"
                                    (sym (.ns-str require)))))
                    (^map [^map acc ^String nm* ^Entity ent]
                     (let [nm (get rename nm* nm*)]
                       (error/when (contains? acc nm)
                         "required name already defined by this namespace:"
                         (sym nm))
                       (assoc acc nm ent))))]
    (let [refer-all? (nil? (.refer-strs require))]
      (if (and (empty? globals) refer-all? (empty? (.rename-strs require)))
        (reduce dissoc other (.exclude-strs require)) ;scenario: core first
        (if (or refer-all? (not (empty? (.exclude-strs require))))
          (let [excl-set (set (.exclude-strs require))]
            (reduce (fn ^map [^map acc [nm ent]]
                      (cond-> acc
                        (not (contains? excl-set nm))
                        (assoc-req nm ent)))
                    globals other))
          (reduce assoc-req globals (.refer-strs require)))))))

(deftype NmspBuilder [^NamespaceProvider universe
                      ^ExprFactory code-gen
                      ^:unsynchronized-mutable ^EntityFactory entity-gen
                      ^PackageBuilder pkg-build
                      ^:unsynchronized-mutable ^map globals
                      ^:unsynchronized-mutable ^map known-ns
                      ^:unsynchronized-mutable ^map ns-alias
                      ^:unsynchronized-mutable ^map imports
                      ^MethodHandle apply-macro-mh
                      ^:unsynchronized-mutable ^MethodHandle ephemeral-of]
  Resolver
  (ns-str [_]
    (.pkg-name pkg-build))
  (expand-macro [this macro form]
    (let [f (.runtime-value ^CodePromise macro pkg-build)]
      (if (some? apply-macro-mh)
        (macro/apply-macro-mapped apply-macro-mh f form nil)
        (macro/apply-macro-direct f form nil))))
  (globals [_]                       ;only call from namespace thread!
    globals)
  (lookup-namespace [this alias]
    (let [ns-str (.ns-str this)]
      (if (or (nil? alias) (= alias ns-str))
        ns-str
        (.valAt ns-alias alias nil))))
  (lookup-global-qname [this nm]
    (when-some [ent (.valAt globals nm nil)]
      (-> (or (.namespace-if-def ^ImmediateEntity ent) (.ns-str this))
          (symbol  nm))))
  (lookup-class [_ nm]
    (or (.valAt imports nm nil)
        (when-some [cl (.class-for-name pkg-build nm)]
          (set! imports (assoc imports nm cl))
          cl)))
  (lookup-def [this nmsp nm]
    (if (or (nil? nmsp) (= nmsp (.ns-str this)))
      (.valAt globals nm nil)
      (when-some [nmsp* (.lookup-namespace this nmsp)]
        (when-some [pn ^ProvidedNamespace (.valAt known-ns nmsp* nil)]
          (.valAt (.globals pn) nm nil)))))
  
  (import-class [_ class]
    (set! imports (-> imports
                      (assoc (resolve/imported-short-name class) class)
                      (assoc (resolve/imported-long-name class) class))))
  (ephemeral-factory [_]
    (or ephemeral-of
        (set! ephemeral-of (.ephemeral-factory pkg-build))))
  
  NamespaceBuilder
  (universe [_]
    universe)
  (require-namespaces [this ns-strs]
    (let [pn-core (when (cfg/core-lib? (.ns-str this))
                    (->> (publics/insn-force-clinit (.last-segment pkg-build))
                         (ProvidedNamespace. cfg/core-lib globals
                                             (new String/1 0) #{} nil)))
          all-ns (.require-namespaces* universe ns-strs pn-core)
          apn (new ProvidedNamespace/1 (alength ns-strs))]

      ;; Note: The `merge-transitive` is *very* conservative, because
      ;; it assumes that any namespace in the transitive chain of
      ;; requires may appear during macro expansion.
      (letfn [(merge-transitive ^map [^map known-ns ^ProvidedNamespace pn]
                (if (or (nil? pn) (contains? known-ns (.ns-str pn)))
                  known-ns ;pn of nil means a cylic require of core-lib
                  (reduce #(merge-transitive %1 (get all-ns ^String %2))
                          (assoc known-ns (.ns-str pn) pn)
                          (.require-strs pn))))]
        (dotimes [i (alength ns-strs)]
          (let [req-str (aget ns-strs i)]
            (if-some [known-pn (.valAt known-ns req-str nil)]
              (aset apn i known-pn) ;retain own provided version of core-lib
              (if-some [req-pn (.valAt all-ns req-str nil)]
                (do (aset apn i req-pn)
                    (set! known-ns (merge-transitive known-ns req-pn)))
                (error/throw "unresolved namespace " (sym req-str)))))))
      apn))
  (process-require [this require provided]
    (let [ns-str (.ns-str provided)]
      (set! globals (add-required-globals globals require (.globals provided)))
      (set! known-ns (assoc known-ns ns-str provided))
      (set! ns-alias (cond-> (assoc ns-alias ns-str ns-str)
                       (some? (.alias-str require))
                       (assoc (.alias-str require) ns-str)))
      (.add (.!require-strs pkg-build) ns-str)
      (.stage-clinit-statement! pkg-build (.force-clinit provided))
      this))
  (process-imports [this import-strs]
    (doseq [^String nm import-strs]
      (if-some [cl (.lookup-class this nm)]
        (.import-class this cl)
        (error/throw "class not found:" (type nm))))
    this)

  (new-def-mutable [_ private? nm init]
    #_(prn :new-def-mutable nm)
    (let [p (defgen/promise-def-mutable ir/entity-id-def private?
              (.staged-segment pkg-build) nm init)
          ent (-> p .expr-of .emitter)
          bnd (ir/mk-binding ent nm false)]
      (.stage-code-promise! pkg-build p)
      (set! globals (assoc globals nm (.bound-to bnd)))
      (insn/bind-then-value bnd ent)))
  (new-def-immutable [_ private? nm init]
    #_(prn :new-def-immutable nm)
    (let [p (defgen/promise-def-immutable ir/entity-id-def private?
              (.staged-segment pkg-build) nm init)
          ent (-> p .expr-of .emitter)
          bnd (ir/mk-binding ent nm false)
          init-ce (.emitter init)]
      (.stage-code-promise! pkg-build p)
      (set! globals (assoc globals nm (if (constgen/const? init-ce)
                                        init-ce
                                        (.bound-to bnd))))
      (insn/bind-then-value bnd ent)))
  (new-def-macro [_ private? nm init fq-value ce-value]
    #_(prn :new-def-macro nm)
    (let [p (defgen/promise-def-macro private? (.staged-segment pkg-build)
              nm init fq-value ce-value)
          ent (-> p .expr-of .emitter)
          bnd (ir/mk-binding ent nm true)]
      (.stage-code-promise! pkg-build p)
      (set! globals (assoc globals nm (.bound-to bnd)))
      (insn/bind-then-value bnd ent)))
  (new-def-var [_ private? nm init tp-var dynamic? meta]
    #_(prn :new-def-var nm)
    (let [p (defgen/promise-def-var private? (.staged-segment pkg-build)
              nm init tp-var dynamic? meta)
          bnd (ir/mk-binding (-> p .expr-of .emitter) nm false)]
      (.stage-code-promise! pkg-build p)
      (set! globals (assoc globals nm (.bound-to bnd)))
      (insn/bind-then-value bnd (.df p))))
  (new-def-alias [_ private? nm other-ent other-qname]
    #_(prn :new-def-alias nm)
    (let [p (defgen/promise-def-alias private? nm other-ent other-qname)]
      (.stage-code-promise! pkg-build p)
      (set! globals (assoc globals nm other-ent))
      insn/insn-empty)) ;alias can refer to macro or primitive function
  
  (process-init-form [this rdr fctx form]
    ;; This method is only called for expression forms that do not
    ;; manipulate `known-ns` or `ns-alias`.  The `globals` at start is
    ;; stored as part of of `scope`.
    (.mark-end-of-segment! pkg-build)
    (let [globals-before globals
          imports-before imports
          expr (try
                 (-> (form/mk-parser code-gen entity-gen this globals-before)
                     (parse/form fctx form))
                 (catch tcljx.data.ir.ImplementationUnavailableException _
                   ;; flush current segment into a class file, revert
                   ;; state, and try again to parse `form`
                   (.flush-segment-and-revert this rdr globals-before
                                              imports-before)
                   (try
                     (-> (form/mk-parser code-gen entity-gen this globals-before)
                         (parse/form fctx form)) ;try again *once*
                     (catch tcljx.data.ir.ImplementationUnavailableException _
                       (error/throw "cannot define and expand macro"
                                    "in same top-level form")))))]
      (.stage-clinit-statement! pkg-build expr)
      this))

  (finish [this rdr]
    (.flush-segment this rdr)
    (.install-capstone pkg-build (.lookup-def this nil "-main")))
  (flush-segment [this rdr]
    (.mark-end-of-segment! pkg-build)
    (.flush-segment-and-revert this rdr globals imports)
    this)
  (flush-segment-and-revert [this rdr then-globals then-imports]
    (let [segment (.extract-segment! pkg-build)
          env-factory (-> (.code-promises segment)
                          (fngen/env-carrying-fns)
                          (envgen/mk-env-factory))]
      (.install-segment pkg-build rdr segment env-factory))
    
    ;; revert back to requested state & move to next segment
    (set! ephemeral-of nil)             ;may contain stale classes
    (set! entity-gen (entity/mk-clinit-etf (.ns-str this)
                                           (.segment-tasks pkg-build)))
    (set! globals then-globals)
    (set! imports then-imports)))

;;; ------------------------------------------------------------------------

(deftype Universe [^Runtime rt ^Destination dest
                   ^map reader-map
                   ^:unsynchronized-mutable ^map all-pns
                   ^map ns-alias]
  NamespaceProvider
  (require-namespaces* [this ns-strs pn-core]
    (letfn [(mk-nmsp-reader ^FormReader [^HashSet all-uris ^String ns-str]
              (let [!source-file-strs (HashSet.)]
                (if (some? reader-map)
                  (get reader-map ns-str)
                  (let [nmsp-path (files/namespace-path ns-str)]
                    (reader/mk-reader all-uris (.app-ld rt) nmsp-path)))))
            (mk-nmsp-builder ^NmspBuilder [^String ns-str ^map known-ns
                                           ^PackageBuilder pkg-build]
              (let [etf (entity/mk-clinit-etf ns-str
                                              (.segment-tasks pkg-build))
                    xf (codegen/mk-factory)
                    globals (if (some? reader-map)
                              primitive/primitive-nmsp-globals
                              (publics/initial-globals ns-str))
                    imports (resolve/predefined-imports (.lookup rt))]
                (NmspBuilder. this xf etf pkg-build
                              globals known-ns ns-alias imports
                              (.apply-macro-mh rt) nil)))
            (emit-nmsp ^vector [^String ns-str ^map provided-ns]
              (let [all-uris (HashSet.)
                    rdr (mk-nmsp-reader all-uris ns-str)
                    pkg-build (pkggen/mk-package-builder rt dest ns-str)]
                (.push-file-context rt ns-str)
                (try
                  (let [cl (-> (mk-nmsp-builder ns-str provided-ns pkg-build)
                               (namespace/parse-all rdr)
                               (.finish rdr))]
                    [(set all-uris) cl])
                  (finally
                    (.pop-file-context rt)))))
            (compile-nmsp ^ProvidedNamespace [^String ns-str ^map provided-ns]
              (let [[all-uris capstone] (emit-nmsp ns-str provided-ns)
                    globals (publics/import-globals rt all-pns capstone)
                    req-strs (publics/require-strings rt capstone)]
                (ProvidedNamespace. ns-str globals req-strs all-uris capstone
                                    (publics/insn-force-clinit capstone))))
            (import-nmsp ^ProvidedNamespace [^String ns-str ^Class capstone]
              (let [req-strs (publics/require-strings rt capstone)]
                (.require-namespaces* this req-strs nil)
                (let [globals (publics/import-globals rt all-pns capstone)]
                  (ProvidedNamespace. ns-str globals req-strs nil capstone
                                      (publics/insn-force-clinit capstone)))))]
      
      (let [provided-ns (cond-> all-pns
                          (some? pn-core) (assoc cfg/core-lib pn-core))]
        (dotimes [i (alength ns-strs)]
          (let [ns-str (aget ns-strs i)]
            (when-not (contains? all-pns ns-str)
              (when (cfg/core-lib? ns-str) ;prevent cyclic import of core lib
                (set! all-pns (assoc all-pns ns-str nil)))
              (let [pn (if-some [cl (.try-load-capstone rt ns-str)]
                         (import-nmsp ns-str cl)
                         (compile-nmsp ns-str provided-ns))]
                (set! all-pns (assoc all-pns ns-str pn)))))))
      all-pns))

  (all-provided-namespaces [_]
    all-pns))

(defn mk-universe ^NamespaceProvider [^map reader-map ^Runtime rt
                                      ^Destination dest ^map provided-ns]
  (let [ns-alias {cfg/primitive-ns-str cfg/primitive-ns-str}]
    (Universe. rt dest reader-map provided-ns ns-alias)))
