;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https:;;www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.nmspgen.universe
  (:require
   (tcljx.data
    [config :as cfg] [files :as files] [resolve :as resolve] [reflect :as reflect]
    [meta :as meta] [wrong :as wrong] [context :as context] [ir :as ir])
   (tcljx.parser
    [reader :as reader] [form :as form] [parse :as parse]
    [namespace :as namespace])
   (tcljx.nmspgen
    [classfile :as classfile] [constgen :as constgen]
    [segment :as segment] [emit :as emit] [insn :as insn] [macro :as macro]
    [codegen :as codegen] [entity :as entity] [fnenv :as fnenv]
    [defgen :as defgen] [primitive :as primitive] [publics :as publics]
    [build :as build]))
  (:import
   (tcljx.data.ir Resolver FormReader NamespaceProvider ProvidedNamespace
                  NmspClass NamespaceBuilder Require
                  Expr Entity ImmediateEntity ExprFactory EntityFactory Parser)
   (tcljx.nmspgen.classfile Loader PackageBuilder)
   (tcljx.nmspgen.segment CodePromise Segment SegmentBuilder)
   (tcljx.nmspgen.insn Insn)
   (java.lang.classfile ClassFile ClassBuilder CodeBuilder)
   (java.lang.invoke MethodHandle)
   (java.nio.file Path)
   (java.util ArrayList HashSet)))

(defn- add-required-globals ^map [^map globals ^Require require ^map other]
  (let [rename (or (.rename-strs require) {})
        assoc-req (fn assoc-req
                    (^map [^map acc ^String nm]
                     (if-some [ent (get other nm)]
                       (assoc-req acc nm ent)
                       (wrong/unresolved-nmsp-sym (.ns-str require) nm)))
                    (^map [^map acc ^String nm* ^Entity ent]
                     (let [nm (get rename nm* nm*)]
                       (if (contains? acc nm)
                         (wrong/other (str "required name already defined by this "
                                           "namespace: " (wrong/q-as-symbol nm)))
                         (assoc acc nm ent)))))]
    (let [refer-all? (nil? (.refer-strs require))]
      (if (and (empty? globals) refer-all? (empty? (.rename-strs require)))
        (reduce dissoc other (.exclude-strs require)) ;scenario: core first
        (if (or refer-all? (not (empty? (.exclude-strs require))))
          (let [excl-set (set (.exclude-strs require))]
            (reduce (fn ^map [^map acc [nm ent]]
                      (cond-> acc
                        (not (contains? excl-set nm))
                        (assoc-req nm ent)))
                    globals other))
          (reduce assoc-req globals (.refer-strs require)))))))

(deftype NmspBuilder [^NamespaceProvider universe
                      ^ExprFactory code-gen
                      ^:unsynchronized-mutable ^EntityFactory entity-gen
                      ^:unsynchronized-mutable ^Segment segment
                      ^PackageBuilder pkg-build
                      ^:unsynchronized-mutable ^map globals
                      ^:unsynchronized-mutable ^map known-ns
                      ^:unsynchronized-mutable ^map ns-alias
                      ^:unsynchronized-mutable ^map imports
                      ^HashSet require-strs ;implicitly mutable
                      ^MethodHandle apply-macro-mh
                      ^:unsynchronized-mutable ^MethodHandle ephemeral-of]
  Resolver
  (ns-str [_]
    (.pkg-name segment))
  (expand-macro [this macro form]
    (let [f (.runtime-value ^CodePromise macro pkg-build)]
      (if (some? apply-macro-mh)
        (macro/apply-macro-mapped apply-macro-mh f form nil)
        (macro/apply-macro-direct f form nil))))
  (globals [_]                       ;only call from namespace thread!
    globals)
  (lookup-namespace [this alias]
    (let [ns-str (.ns-str this)]
      (if (or (nil? alias) (= alias ns-str))
        ns-str
        (.valAt ns-alias alias nil))))
  (lookup-global-qname [this nm]
    (when-some [ent (.valAt globals nm nil)]
      (-> (or (.namespace-if-def ^ImmediateEntity ent) (.ns-str this))
          (symbol  nm))))
  (lookup-class [_ nm]
    (or (.valAt imports nm nil)
        (when-some [cl (.class-for-name pkg-build nm)]
          (set! imports (assoc imports nm cl))
          cl)))
  (lookup-def [this nmsp nm]
    (if (or (nil? nmsp) (= nmsp (.ns-str this)))
      (.valAt globals nm nil)
      (when-some [nmsp* (.lookup-namespace this nmsp)]
        (when-some [pn ^ProvidedNamespace (.valAt known-ns nmsp* nil)]
          (.valAt (.globals pn) nm nil)))))
  
  (import-class [_ class]
    (set! imports (-> imports
                      (assoc (resolve/imported-short-name class) class)
                      (assoc (resolve/imported-long-name class) class))))
  (ephemeral-factory [_]
    (or ephemeral-of
        (set! ephemeral-of (.ephemeral-factory pkg-build))))
  
  NamespaceBuilder
  (universe [_]
    universe)
  (require-namespaces [this ns-strs]
    (let [pn-core (when (cfg/core-lib? (.ns-str this))
                    (let [last-segment (.super-class segment)]
                      (->> (publics/insn-force-clinit last-segment)
                           (ProvidedNamespace. cfg/core-lib globals
                                               (new String/1 0) nil))))
          all-ns (.require-namespaces* universe ns-strs pn-core)
          apn (new ProvidedNamespace/1 (alength ns-strs))]

      ;; Note: The `merge-transitive` is *very* conservative, because
      ;; it assumes that any namespace in the transitive chain of
      ;; requires may appear during macro expansion.
      (letfn [(merge-transitive ^map [^map known-ns ^ProvidedNamespace pn]
                (if (or (nil? pn) (contains? known-ns (.ns-str pn)))
                  known-ns ;pn of nil means a cylic require of core-lib
                  (reduce #(merge-transitive %1 (get all-ns ^String %2))
                          (assoc known-ns (.ns-str pn) pn)
                          (.require-strs pn))))]
        (dotimes [i (alength ns-strs)]
          (let [req-str (aget ns-strs i)]
            (if-some [known-pn (.valAt known-ns req-str nil)]
              (aset apn i known-pn) ;retain own provided version of core-lib
              (if-some [req-pn (.valAt all-ns req-str nil)]
                (do (aset apn i req-pn)
                    (set! known-ns (merge-transitive known-ns req-pn)))
                (wrong/other (str "unresolved namespace "
                                  (wrong/q-as-symbol req-str))))))))
      apn))
  (process-require [this require provided]
    (let [ns-str (.ns-str provided)]
      (set! globals (add-required-globals globals require (.globals provided)))
      (set! known-ns (assoc known-ns ns-str provided))
      (set! ns-alias (cond-> (assoc ns-alias ns-str ns-str)
                       (some? (.alias-str require))
                       (assoc (.alias-str require) ns-str)))
      (.add require-strs ns-str)
      (segment/stage-segment-task! segment (.force-clinit provided))
      this))
  (process-imports [this import-strs]
    (doseq [^String nm import-strs]
      (if-some [cl (.lookup-class this nm)]
        (.import-class this cl)
        (throw (wrong/info-class-not-found nm))))
    this)

  (new-def-mutable [_ private? nm init]
    #_(prn :new-def-mutable nm)
    (let [p (defgen/promise-def-mutable ir/entity-id-def private?
              (.segment-class segment) nm init)
          ent (-> p .expr-of .emitter)
          bnd (ir/mk-binding ent nm false)]
      (segment/stage-segment-task! segment p)
      (set! globals (assoc globals nm (.bound-to bnd)))
      (insn/bind-then-value bnd ent)))
  (new-def-immutable [_ private? nm init]
    #_(prn :new-def-immutable nm)
    (let [p (defgen/promise-def-immutable ir/entity-id-def private?
              (.segment-class segment) nm init)
          ent (-> p .expr-of .emitter)
          bnd (ir/mk-binding ent nm false)
          init-ce (.emitter init)]
      (segment/stage-segment-task! segment p)
      (set! globals (assoc globals nm (if (constgen/const? init-ce)
                                        init-ce
                                        (.bound-to bnd))))
      (insn/bind-then-value bnd ent)))
  (new-def-macro [_ private? nm init fq-value ce-value]
    #_(prn :new-def-macro nm)
    (let [p (defgen/promise-def-macro private? (.segment-class segment) nm init
              fq-value ce-value)
          ent (-> p .expr-of .emitter)
          bnd (ir/mk-binding ent nm true)]
      (segment/stage-segment-task! segment p)
      (set! globals (assoc globals nm (.bound-to bnd)))
      (insn/bind-then-value bnd ent)))
  (new-def-var [_ private? nm init tp-var dynamic? meta]
    #_(prn :new-def-var nm)
    (let [p (defgen/promise-def-var private? (.segment-class segment) nm init
              tp-var dynamic? meta)
          bnd (ir/mk-binding (-> p .expr-of .emitter) nm false)]
      (segment/stage-segment-task! segment p)
      (set! globals (assoc globals nm (.bound-to bnd)))
      (insn/bind-then-value bnd (.df p))))
  (new-def-alias [_ private? nm other-ent other-qname]
    #_(prn :new-def-alias nm)
    (let [p (defgen/promise-def-alias private? nm other-ent other-qname)]
      (segment/stage-segment-task! segment p)
      (set! globals (assoc globals nm other-ent))
      insn/insn-empty)) ;alias can refer to macro or primitive function
  
  (process-init-form [this rdr fctx form]
    ;; This method is only called for expression forms that do not
    ;; manipulate `known-ns` or `ns-alias`.  The `globals` at start is
    ;; stored as part of of `scope`.
    (let [globals-before globals
          imports-before imports
          segm-size-before (segment/size-segment-tasks segment)
          expr (try
                 (-> (form/mk-parser code-gen entity-gen this globals-before)
                     (parse/form fctx form))
                 (catch tcljx.data.ir.ImplementationUnavailableException _
                   ;; flush current segment into a class file, revert
                   ;; state, and try again to parse `form`
                   (.commit-segment-and-revert this rdr segm-size-before
                                               globals-before imports-before)
                   (try
                     (-> (form/mk-parser code-gen entity-gen this globals-before)
                         (parse/form fctx form)) ;try again *once*
                     (catch tcljx.data.ir.ImplementationUnavailableException _
                       (wrong/other (str "cannot define and expand macro "
                                         "in same top-level form"))))))]
      (segment/stage-segment-task! segment expr)
      this))

  (finish [this rdr]
    (.commit-segment this rdr)
    (let [capstone-cld (segment/capstone-class (.pkg-name segment))
          all-requires (-> (.sorted (.stream require-strs))
                           (.collect (java.util.stream.Collectors/joining ",")))
          ncl (->> (build/capstone pkg-build segment all-requires
                                   (.lookup-def this nil "-main"))
                   (ir/mk-nmsp-class capstone-cld (.super-class segment))
                   (classfile/bwdi pkg-build))]
      (.defined-class ncl)))
  (commit-segment [this rdr]
    (.commit-segment-and-revert this rdr (segment/size-segment-tasks segment)
                                globals imports)
    this)
  (commit-segment-and-revert [this rdr end-of-segment
                              then-globals then-imports]
    (let [tasks (-> (.subList (.tasks segment) 0 end-of-segment)
                    (fnenv/transitive-closure!))
          clinit-statms (segment/clinit-statements tasks)
          acp (segment/code-promises tasks)
          class-elements (ArrayList.), other-classes (ArrayList.)
          sb (SegmentBuilder. class-elements other-classes
                              (.segment-class segment))
          env-factory (fnenv/mk-env-factory (build/env-carrying-fns acp))]
      (dotimes [i (alength acp)]
        (.generate-and-deliver (aget acp i) sb env-factory nil))
      (doseq [ncl other-classes]
        (classfile/declare-class pkg-build ncl))
      (doseq [^NmspClass ncl other-classes]
        (->> (ir/with-class-handler ncl
               (^java.util.function.Consumer fn ^void [^ClassBuilder cb]
                (.accept (.class-handler ncl) cb)
                (.with-source-file rdr cb)))
             (classfile/bwdi pkg-build)))
      (->> (build/segment rdr segment class-elements clinit-statms)
           (ir/mk-nmsp-class (.segment-class segment) (.super-class segment))
           (classfile/bwdi pkg-build)))
    
    ;; revert back to requested state & move to next segment
    (set! ephemeral-of nil)             ;may contain stale classes
    (set! segment (segment/next-segment segment))
    (set! entity-gen (entity/mk-clinit-etf (.ns-str this) (.tasks segment)))
    (set! globals then-globals)
    (set! imports then-imports)))

;;; ------------------------------------------------------------------------

(deftype Universe [^Loader loader
                   ^map reader-map
                   ^:unsynchronized-mutable ^map all-pns
                   ^map ns-alias]
  NamespaceProvider
  (require-namespaces* [this ns-strs pn-core]
    (letfn [(mk-nmsp-reader ^FormReader [^String ns-str]
              (let [!source-file-strs (HashSet.)]
                (if (some? reader-map)
                  (get reader-map ns-str)
                  (let [nmsp-path (files/namespace-path ns-str)]
                    (reader/mk-reader (.app-ld loader) nmsp-path)))))
            (mk-nmsp-builder ^NmspBuilder [^String ns-str ^map known-ns
                                           ^PackageBuilder pkg-build]
              (let [segment (segment/mk-first-segment ns-str)
                    etf (entity/mk-clinit-etf ns-str (.tasks segment))
                    xf (codegen/mk-factory)
                    globals (if (some? reader-map)
                              primitive/primitive-nmsp-globals
                              (publics/initial-globals ns-str))
                    imports (resolve/predefined-imports (.rt-lookup loader))
                    require-strs (HashSet.)]
                (NmspBuilder. this xf etf segment pkg-build
                              globals known-ns ns-alias imports
                              require-strs (.apply-macro-mh loader) nil)))
            (emit-nmsp ^Class [^String ns-str ^map provided-ns]
              (let [rdr (mk-nmsp-reader ns-str)
                    pkg-build (classfile/mk-package-builder loader ns-str)]
                (classfile/push-file-context pkg-build ns-str)
                (try
                  (-> (mk-nmsp-builder ns-str provided-ns pkg-build)
                      (namespace/parse-all rdr)
                      (.finish rdr))
                  (finally
                    (classfile/pop-file-context pkg-build)))))
            (compile-nmsp ^ProvidedNamespace [^String ns-str ^map provided-ns]
              (let [capstone (emit-nmsp ns-str provided-ns)
                    globals (publics/import-globals loader all-pns capstone)
                    req-strs (publics/require-strings loader capstone)]
                (ProvidedNamespace. ns-str globals req-strs capstone
                                    (publics/insn-force-clinit capstone))))
            (import-nmsp ^ProvidedNamespace [^String ns-str ^Class capstone]
              (let [req-strs (publics/require-strings loader capstone)]
                (.require-namespaces* this req-strs nil)
                (let [globals (publics/import-globals loader all-pns capstone)]
                  (ProvidedNamespace. ns-str globals req-strs capstone
                                      (publics/insn-force-clinit capstone)))))]
      
      (let [provided-ns (cond-> all-pns
                          (some? pn-core) (assoc cfg/core-lib pn-core))]
        (dotimes [i (alength ns-strs)]
          (let [ns-str (aget ns-strs i)]
            (when-not (contains? all-pns ns-str)
              (when (cfg/core-lib? ns-str) ;prevent cyclic import of core lib
                (set! all-pns (assoc all-pns ns-str nil)))
              (let [pn (if-some [cl (publics/try-load-capstone loader ns-str)]
                         (import-nmsp ns-str cl)
                         (compile-nmsp ns-str provided-ns))]
                (set! all-pns (assoc all-pns ns-str pn)))))))
      all-pns)))

(defn mk-universe ^NamespaceProvider [^map reader-map ^Loader loader
                                      ^map provided-ns]
  (let [ns-alias {cfg/primitive-ns-str cfg/primitive-ns-str}]
    (Universe. loader reader-map provided-ns ns-alias)))
