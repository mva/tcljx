(ns tcljx.nmspgen.entity
  (:require
   (tcljx.data
    [config :as cfg] [error :as error] [type :as type] [member :as member]
    [ir :as ir] [resolve :as resolve] [reflect :as reflect] [code :as code])
   (tcljx.nmspgen
    [util :as util] [constgen :as constgen] [env :as env] pkggen
    [emit :as emit] [insn :as insn] [fngen :as fngen] [typegen :as typegen]))
  (:import
   (tcljx.data.ir CodeEmitter Entity Assignable MethodSpec
                  EntityFactory BindableEntity)
   (tcljx.nmspgen.insn Insn Insns)
   (tcljx.nmspgen.fngen FnPromiseImpl)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant ClassDesc)
   (java.util ArrayList HashMap)
   (java.util.concurrent ConcurrentHashMap)))

(deftype EntityFactoryImpl [^:unsynchronized-mutable ^int curr-entity-id
                            ^HashMap env-to-display ^HashMap parent-e2d
                            ^ConcurrentHashMap private-name-map
                            ^String pkg-name
                            ^String scope-name
                            ^ArrayList !nested-parts]
  EntityFactory
  (scope-name [_]
    scope-name)
  (closure-level [_]
    (unsigned-bit-shift-right curr-entity-id 16))
  (closes-over? [this ent]
    (let [origin (ir/closure-level ent)]
      (and (>= origin ir/closure-level-clinit)
           (not= origin (.closure-level this)))))
  (display-of! [_ origin local-name]
    (env/display-of! env-to-display origin local-name))
  (value-of [this ent form]
    (assert (some? form))
    (if-some [tp (.value-type ent)]
      (-> (if (.closes-over? this ent)
            (.display-of! this ent (name form))
            ent)
          (insn/mk-insn tp))
      (error/throw "entity" (q form) "has no runtime value")))
  (invocation-of [this inv form]
    (if (.closes-over? this inv)
      (.display-of! this inv (name ^symbol (first form)))
      inv))
  
  (expr-constant [_ value type]
    (insn/constant value type))
  (entity-class-member [this m]
    (fngen/class-member-fn m))
  (entity-getstatic [this m]
    (reify
      CodeEmitter
      (emit-insn* [_ xb consumed-type _]
        (util/with-void-empty-if-requested consumed-type
          (.getstatic xb (reflect/describe-class (.owner m))
                      (.getName (.member m))
                      (reflect/describe-class (.return-type m)))
          (.return-type m)))
      Entity
      (value-type [_]
        (.return-type m))
      (value-type-exact [_]
        (reflect/describe-class (.return-type m)))
      (entity-id [_]
        ir/entity-id-def)
      (invoke-methods [_]
        ir/invoke-methods-dynamic)
      BindableEntity
      (binding-mode-let [_]
        ir/bound-by-copy-to-local)))
  (new-loadable [_ value expr-type]
    (-> value (constgen/collection expr-type false) (insn/mk-insn expr-type)))
  (new-collection [this coll-type args]
    (let [args ^Insns args]
      (if (insn/loadables? args)
        (.new-loadable this (.emitters args) coll-type)
        (insn/invoke-runtime (resolve/literal-factory coll-type) args))))
  
  (next-entity-id [_]
    (set! curr-entity-id (inc curr-entity-id)))
  (local-variable [this type init]
    (util/entity-local type (.next-entity-id this) init))
  (parameter [this type]                ;`param-no` provided late
    (util/entity-local type (.next-entity-id this) constgen/emitter-empty))
  (entity-fn [this arity-specs fn-e2d unique-nm !fn-parts]
    (let [method-specs (new MethodSpec/1 (alength arity-specs))]
      (dotimes [i (alength method-specs)]
        (aset method-specs i (-> (.at (aget arity-specs i))
                                 (MethodSpec. nil nil nil i nil))))
      (->> (^java.util.Comparator fn ^int [^MethodSpec o1 ^MethodSpec o2]
            (Integer/compare (-> o1 .at .parameter-count)
                             (-> o2 .at .parameter-count)))
           (java.util.Arrays/sort method-specs))
      (FnPromiseImpl. (.next-entity-id this) method-specs fn-e2d
                      env-to-display unique-nm !fn-parts nil 1)))
  (expr-fn [this fn-entity arity-methods]
    (let [fn-p ^FnPromiseImpl fn-entity
          method-specs (.method-specs fn-p)]
      (dotimes [i (alength method-specs)]
        (let [j (.source-idx (aget method-specs i))]
          (aset method-specs i (aget arity-methods j))))
      (.stage-code-promise! this fn-p)))
  (expr-itf-fn [this method-specs itf-e2d unique-nm itf-class method
                !itf-parts]
    (let [p (fngen/promise-itf-fn (.next-entity-id this) method-specs unique-nm
                                  itf-class method itf-e2d env-to-display
                                  !itf-parts nil)]
      (.stage-code-promise! this p)))
  (deftype-field [_ entity-id spec]
    (reify
      BindableEntity
      (emit-insn* [_ xb _ _]
        (-> (code/load-receiver xb)
            (.getfield (.owner spec) (.field-name spec) (.type-desc spec)))
        (.type spec))
      (value-type [_]
        (.type spec))
      (value-type-exact [_]
        (.type-desc spec))
      (entity-id [_]
        entity-id)
      (binding-mode-let [_]
        ir/bound-by-copy-to-local)      ;required unless final
      
      Assignable
      (set-expr* [_ fctx value]
        (let [nm (.field-name spec), tp (.type spec)]
          (insn/ensure-assignable tp value)
          (error/when (member/acc-final? (.flags spec))
            "field" (sym nm) "is final")
          (-> (^CodeEmitter fn [xb consumed-type _]
               (code/load-receiver xb)
               (when (emit/insn? xb fctx tp (.emitter value))
                 (util/with-dup-x1-unless-void-> xb consumed-type tp
                   (.putfield (.owner spec) nm (.type-desc spec)))))
              (insn/mk-insn tp))))
      (redef-expr* [_ fctx value]
        nil)))
  (expr-deftype [this eph-ncl field-specs java-record? defrecord?
                 !dt-parts method-specs]
    (error/when-not (= (.closure-level this) ir/closure-level-clinit)
      "cannot define class in this position")
    (->> (typegen/promise-deftype eph-ncl field-specs method-specs
                                  java-record? defrecord? !dt-parts)
         (.stage-code-promise! this)))
  (expr-reify [this eph-ncl interfaces meta method-specs reify-e2d !reify-parts]
    (->> (typegen/promise-reify (.next-entity-id this) eph-ncl interfaces meta
                                method-specs reify-e2d env-to-display
                                !reify-parts nil)
         (.stage-code-promise! this)))
  (expr-definterface [this eph-ncl]
    (error/when-not (= (.closure-level this) ir/closure-level-clinit)
      "cannot define class in this position")
    (let [p (typegen/promise-definterface* eph-ncl)]
      (.stage-code-promise! this p)))
  (class-name-for-reify [this]
    (ClassDesc/of pkg-name (.unique-name! this "reify")))
  
  (binding-entity [_ fctx name ent alias?]
    (ir/mk-binding ent name alias?))
  (binding-fresh [this fctx opt-type name init]
    (when opt-type
      (insn/ensure-assignable opt-type init))
    (let [tp (or opt-type (insn/logical-type init))
          ce (-> init (insn/cast-to tp fctx) .emitter)]
      (ir/mk-binding (.local-variable this tp ce) name false)))
  (binding-catching-local [this fctx type name]
    (let [ex-provider (insn/mk-insn (^CodeEmitter fn [_ _ _] type) type)]
      (.binding-fresh this fctx type name ex-provider)))

  (unique-name! [_ name-suffix]
    (util/distinct-name private-name-map
                        (cond->> (cfg/munge-name name-suffix)
                          (some? scope-name) (str scope-name "$"))))
  (method-etf [this unique-nm used-entity-ids owner-e2d nested-parts]
    (-> (ir/entity-id-of (inc (.closure-level this)) used-entity-ids)
        (EntityFactoryImpl. owner-e2d env-to-display
                            private-name-map pkg-name unique-nm nested-parts)))
  (stage-code-promise! [_ cp]
    (.add !nested-parts cp)
    (.expr-of ^tcljx.nmspgen.pkggen.CodePromise cp)))

(defn mk-clinit-etf ^EntityFactory [^String pkg-name ^ArrayList segment-tasks]
  (EntityFactoryImpl. (ir/entity-id-of ir/closure-level-clinit) (HashMap.) nil
                      (ConcurrentHashMap.) pkg-name nil segment-tasks))
