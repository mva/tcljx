;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.nmspgen.envgen   ;supporting functions for fn, itf fn, reify
  (:require
   (tcljx.data [config :as cfg] [member :as member] [ir :as ir] [code :as code])
   (tcljx.nmspgen [util :as util] [env :as env] [constgen :as constgen]))
  (:import
   (tcljx.data.ir CodeEmitter Entity FnPromise FieldSpec)
   (tcljx.nmspgen.env ClosureEntity Display StoredEnv EnvFactory)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant ClassDesc MethodTypeDesc ConstantDescs)
   (java.util Arrays List HashSet HashMap Map$Entry)))

(defn load-env
  (^CodeBuilder [^CodeBuilder xb ^Entity/1 aorigin] ;from own parameters
   (dotimes [i (alength aorigin)]
     (.loadLocal xb (TypeKind/from (.value-type (aget aorigin i)))
                 (.parameterSlot xb i)))
   xb)
  (^CodeBuilder [^CodeBuilder xb ^HashMap parent-e2d ^Entity/1 aorigin]
   (dotimes [i (alength aorigin)]
     (let [origin (aget aorigin i)]
       (-> ^CodeEmitter (.getOrDefault parent-e2d origin origin)
           (.emit-insn* xb (.value-type origin) false))))
   xb))

(letfn [(sorted-idxs ^long/1 [^int n ^Entity/1 ao]
          (let [idxs (new long/1 n)]
            (dotimes [i (alength idxs)]
              (aset idxs i (-> (long (.entity-id (aget ao i)))
                               (bit-shift-left 16)
                               (bit-or i))))
            (Arrays/sort idxs)
            idxs))
        (index-after-sort ^int [^long/1 idxs ^int i]
          (bit-and (int (aget idxs i)) 0xFFFF))
        (sorted-stored-env ^StoredEnv [^int n ^Entity/1 ao ^Display/1 ad]
          (let [idxs (sorted-idxs n ao)
                aorigin (new Entity/1 n), adisplay (new Display/1 n)]
            (dotimes [i n]
              (let [j (index-after-sort idxs i)]
                (aset aorigin i (aget ao j))
                (aset adisplay i (aget ad j))))
            (StoredEnv. aorigin adisplay)))
        (sorted-stored-origin ^Entity/1 [^int n ^Entity/1 ao]
          (let [idxs (sorted-idxs n ao)
                aorigin (new Entity/1 n)]
            (dotimes [i n]
              (aset aorigin i (aget ao (index-after-sort idxs i))))
            aorigin))

        (flyweight-prefix ^CodeEmitter [^Entity/1 fw-env ^HashMap caller-e2d]
          (^CodeEmitter fn [xb consumed-type _]
           (load-env xb caller-e2d fw-env)
           consumed-type))]

  (defn mk-env-factory ^EnvFactory [^HashSet carries-env-set]
    (reify EnvFactory
      (fn-carries-env? [_ fn-p]
        (and (FnPromise/.value-use? fn-p) (.contains carries-env-set fn-p)))
      
      (stored-in-env? [this origin]
        (if (instance? FnPromise origin)
          (.fn-carries-env? this origin)
          true))

      (stored-environment! [this ent this-emit]
        (let [env-to-display (.env-to-display ent)
              n* (-> env-to-display .size)
              it (-> env-to-display .entrySet .iterator)
              ao (new Entity/1 n*), ad (new Display/1 n*)]
          (loop [i 0]
            (if (.hasNext it)
              (let [entry ^Map$Entry (.next it)
                    o ^Entity (.getKey entry), d ^Display (.getValue entry)]
                (cond
                  (identical? o ent)
                  (do (.set-emitter! d this-emit) (recur i))
                  (.stored-in-env? this o)
                  (do (aset ao i o) (aset ad i d) (recur (inc i)))
                  ;; here holds: (instance? FnPromise o)
                  (FnPromise/.value-use? o)
                  (do (.set-emitter! d o) (recur i))
                  :else
                  (let [fw-env (.stored-origin this ^ClosureEntity o)]
                    (.set-emitter! d (flyweight-prefix fw-env env-to-display))
                    (recur i))))
              (if (and (= i n*) (<= n* 1))
                (StoredEnv. ao ad)
                (sorted-stored-env i ao ad))))))

      (stored-origin [this ent]
        (let [n* (-> ent .env-to-display .size)
              it (-> ent .env-to-display .keySet .iterator)
              ao (new Entity/1 n*)]
          (loop [i 0]
            (if (.hasNext it)
              (let [o ^Entity (.next it)]
                (cond
                  (identical? o ent) (recur i)
                  (.stored-in-env? this o) (do (aset ao i o) (recur (inc i)))
                  :else (recur i)))
              (if (and (= i n*) (<= n* 1))
                ao
                (sorted-stored-origin i ao)))))))))

;;; ------------------------------------------------------------------------

(defn as-constants ^void [^HashMap env-to-display]
  (doseq [[o ^Display d] env-to-display]
    (.set-emitter! d o)))

(defn patched-field? ^boolean [^Entity/1 aforward ^int env-idx]
  (identical? constgen/entity-null (aget aforward env-idx)))
(defn mtd-of-patch ^MethodTypeDesc [^FieldSpec/1 fields]
  (letfn [(patched-type-desc ^ClassDesc [^FieldSpec fs]
            (when-not (member/acc-final? (.flags fs)) (.type-desc fs)))]
    (when-some [xs (seq (keep patched-type-desc fields))]
      (MethodTypeDesc/of ConstantDescs/CD_void ^List xs))))
(defn fields-exact ^FieldSpec/1 [^int start ^ClassDesc owner ^StoredEnv env
                                 ^Entity/1 aforward]
  (let [ao (.aorigin env),  ad (.adisplay env)
        a (new FieldSpec/1 (+ (alength ao) start))
        names (HashMap.)]
    (dotimes [i (alength ao)]
      (let [o (aget ao i), d (aget ad i)
            fnm (util/distinct-name names (cfg/munge-name (.local-name d)))
            flags (if (patched-field? aforward i)
                    (code/acc* private)
                    (code/acc* private final))]
        (aset a (+ i start) (FieldSpec. owner fnm nil flags
                                        (.value-type-exact o)
                                        (.value-type o)))))
    a))
(defn as-fields ^void [^int start ^FieldSpec/1 fields ^StoredEnv env]
  (dotimes [i (alength (.adisplay env))]
    (let [fs (aget fields (+ i start))]
      (.set-emitter! (aget (.adisplay env) i) (^CodeEmitter fn [xb _ _]
                                               (code/get-field xb fs)
                                               (.type fs))))))

(defn as-parameters ^int [^CodeBuilder xb ^StoredEnv env]
  (dotimes [i (alength (.aorigin env))]
    (let [o (aget (.aorigin env) i)
          d (aget (.adisplay env) i)
          ent (util/parameter* xb (.local-name d) (.value-type o)
                               (.value-type-exact o) i)]
      (.set-emitter! d ent)))
  (alength (.aorigin env)))
