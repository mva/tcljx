(ns tcljx.nmspgen.codegen
  (:require
   (tcljx.data
    [config :as cfg] [context :as context] [error :as error] [member :as member]
    [type :as type] [ir :as ir] [resolve :as resolve] [reflect :as reflect])
   (tcljx.nmspgen
    [pkggen :as pkggen] [runtime :as rt] [constgen :as constgen]
    [emit :as emit] [insn :as insn]
    [primitive :as primitive] [condgen :as condgen] [switchgen :as switchgen]
    [trygen :as trygen] [fngen :as fngen] defgen))
  (:import
   (tcljx.data.ir Expr Exprs ExprFactory CodeEmitter Binding Entity
                  ArityType MethodSpec FieldSpec NamespaceBuilder
                  NmspClass Parser EntityFactory)
   (tcljx.nmspgen.insn Insn Insns)
   (java.lang.classfile ClassBuilder CodeBuilder Opcode Label TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc MethodHandleDesc
                       ConstantDescs)
   (java.util.function Consumer)))

(defn- invoke-single-match ^Insn [^seq ms ^Insn receiver ^Insns args ^long fctx]
  (when (nil? (next ms))
    (when-some [m (first ms)]
      (insn/invoke-member m receiver args fctx))))

(defn- error-unresolved-member ^Exception [^seq ms ^Class owner ^String mnm
                                           ^Insns args ^String label]
  ;; label is one of "static", "virtual", or "constructor"
  (let [entity (str label (when (not= label "constructor")
                            (if (.empty? args) " member" " method")))
        mnm (cond->> mnm (= label "virtual") (str "."))]
    (if (nil? (seq ms))
      (-> (error/mk-error-msg)
          (.txt "no")
          (.txt entity)
          (.txt "matching")
          (.sym owner mnm)
          (error/to-error))
      (-> (error/mk-error-msg)
          (.txt "multiple")
          (.txt-pl entity 2)
          (.txt "matching")
          (.sym owner mnm)
          (error/to-error)))))

(defn- recur-iinc-deltas ^int/1 [^Entity/1 entities ^CodeEmitter/1 ces]
  (let [a (new int/1 (alength entities))]
    (dotimes [i (alength a)]
      (aset a i (primitive/iinc-delta (aget entities i) (aget ces i))))
    a))

;;; Returns -1 if none of the arities matches `arg-count`.
(defn- method-index ^int [^MethodSpec/1 method-specs ^int arg-count]
  (loop [i (dec (alength method-specs))]
    (cond
      (neg? i) (let [n-m1 (dec (alength method-specs))
                     at* (-> method-specs (aget n-m1) .at)]
                 (if (and (ir/translates-to-varargs? at*)
                          (>= arg-count (dec (.parameter-count at*))))
                   n-m1
                   -1))
      (= (-> method-specs (aget i) .at .parameter-count) arg-count) i
      :else (recur (dec i)))))

;;; Bridge gap between Clojure variadic function and JVM vararg method
;;; by casting the argument that can unintentionally match the
;;; varargs' array parameter to type Object.
(defn- fix-vararg-array! ^Class/1 [^Class/1 atypes]
  (let [i (dec (alength atypes))]
    (when (and (>= i 0) (.isArray (aget atypes i)))
      (aset atypes i Object))
    atypes))

(definterface InsnFactory
  :extends [ExprFactory]
  (get-recur-target ^Label [])
  (set-recur-target! ^void [^Label target])) ;on this copy of InsnFactory!

(deftype InsnFactoryImpl [^Entity/1 recur-variables
                          ^:unsynchronized-mutable ^Label __recur-target]
  InsnFactory
  (empty-expr [_]
    insn/insn-empty)
  (new-exprs [_ n]
    (if (zero? n)
      insn/empty-insns
      (Insns. (new CodeEmitter/1 n) (new Class/1 n))))
  
  (invoke-arity [this fctx form inv f args]
    (let [args ^Insns args
          specs (.invoke-methods inv)
          n (.length args)
          m-idx (method-index specs n)]
      (error/when (neg? m-idx)
        "no function arity for" (txt n) (txt-pl "argument" n))
      (let [at (.at (aget specs m-idx))
            ptypes (.parameter-types at)
            vararg-tp (ir/vararg-type at)
            fixed (- (.parameter-count at) (int (some? vararg-tp)))]
        (insn/ensure-assignables ptypes args fixed)
        (when (< fixed (alength ptypes)) ;any arguments passed as varargs?
          (insn/ensure-assignable* vararg-tp args fixed))
        (.invoke* inv fctx form f m-idx args))))

  (attach-meta-to [this meta arg]
    (if (and (ir/loadable? (.emitter arg)) (ir/loadable? (.emitter meta)))
      (let [tp (insn/expr-type arg)]
        (-> (doto (new CodeEmitter/1 2)
              (aset 0 (.emitter arg))
              (aset 1 (.emitter meta)))
            (constgen/collection tp true)
            (insn/mk-insn tp)))
      (insn/invoke-runtime (resolve/with-meta-factory) (insn/insns-of arg meta))))
  (new-array [_ fctx array-type dims]
    (let [dims ^Insns dims]
      (insn/ensure-assignable* Integer/TYPE dims)
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insns? xb fctx Integer/TYPE (.emitters dims))
             (if (= (.length dims) 1)
               (let [component-type (.getComponentType array-type)]
                 (if (.isPrimitive component-type)
                   (.newarray xb (TypeKind/from component-type))
                   (.anewarray xb (reflect/describe-class component-type))))
               (.multianewarray xb (reflect/describe-class array-type)
                                (.length dims)))
             array-type))
          (insn/mk-insn array-type))))
  (var-expr [_ arg]
    (let [ce (.emitter arg)]
      (if (instance? tcljx.nmspgen.defgen.DefVarDeref ce)
        (.expr-of (.df ^tcljx.nmspgen.defgen.DefVarDeref ce))
        (error/throw "special form `var` only applicable to :var def"))))
  
  (progn-expr [_ xs x]
    (insn/progn xs x))
  (if-expr [_ fctx xs]
    (let [xs ^Insns xs
          ;; FIXME... make empty path logic part of join-type in general?
          tp (cond (identical? constgen/emitter-empty (.emitter xs 1))
                   (insn/expr-type xs 2)
                   (identical? constgen/emitter-empty (.emitter xs 2))
                   (insn/expr-type xs 1)
                   :else
                   (condgen/join-type (.expr-types xs) 1 (.length xs)))]
      (-> (.emitter (condgen/logical-truth (.get xs 0) fctx))
          (condgen/mk-if tp (insn/emitter xs 1) (insn/emitter xs 2) fctx)
          (insn/mk-insn tp))))
  (case-expr [this select guards paths-and-default fctx error-contexts]
    (let [select-tp (switchgen/adjust-numeric-type (insn/expr-type select))
          n-paths (.length paths-and-default)
          join-tp (-> (Insns/.expr-types paths-and-default)
                      (condgen/join-type 0 n-paths))
          default-path (if (= (alength guards) n-paths)
                         ;; Important: This evaluates the select
                         ;; expression a second time!  One possible
                         ;; idea: dup the select, consume it in the
                         ;; error path, and pop it immediately after
                         ;; the end-of-switch label.
                         (->> (switchgen/invoke-no-matching-clause select fctx)
                              (.throw-expr this fctx))
                         (.get paths-and-default (dec n-paths)))]
      (switchgen/validate-guards select-tp guards fctx error-contexts)
      (-> (if (switchgen/switch-on-int? select-tp)
            (switchgen/switch-int (.emitter select) join-tp guards
                                  (.emitters paths-and-default)
                                  (.emitter default-path) fctx)
            (switchgen/switch-map (.emitter select) join-tp guards
                                  (.emitters paths-and-default)
                                  (.emitter default-path) fctx))
          (insn/mk-insn join-tp))))
  (invoke-value [this fctx f args]
    (let [f ^Insn f
          args ^Insns args
          f-tp (insn/logical-type f)]
      (if (or (type/same? Object f-tp) (.isInterface f-tp)
              (.isAssignableFrom type/ifn f-tp))
        (-> (^CodeEmitter fn [xb consumed-type _]
             (let [cpb (.constantPool xb)
                   atypes (fix-vararg-array! (insn/logical-types args))
                   mhe (.methodHandleEntry cpb rt/bsm-invoke-fn)
                   bsm (.bsmEntry cpb mhe (java.util.List/of))
                   mtd (insn/mtd-of-fn-poly Object f-tp atypes)
                   nat (.nameAndTypeEntry cpb ConstantDescs/DEFAULT_NAME mtd)]
               (when (emit/insn? xb fctx f-tp (.emitter f))
                 (when (emit/typed-insns? xb fctx atypes (.emitters args))
                   (-> (emit/with-line-number xb fctx)
                       (.invokedynamic (.invokeDynamicEntry cpb bsm nat)))
                   (if (identical? Boolean/TYPE consumed-type)
                     ;; FIXME... or introduce a marker type to
                     ;; distinguish context "JVM boolean" from
                     ;; context "Clojure logical truth"?
                     (do (.invokestatic xb rt/ClojureRT "booleanCast"
                                        rt/mtd-boolean-Object)
                         Boolean/TYPE)
                     Object)))))
            (insn/mk-insn Object)) ;do not advertise invocation as polymorphic
        (throw (insn/error-type "called function's type does not implement `IFn`" f)))))
  
  (block-bindings [this fctx bindings patch-letfn? recur-to-body? body]
    (if (and (not recur-to-body?) (ir/every-binding-alias? bindings))
      body ;none of the bindings emits any code, nor is there a recur target
      (-> (^CodeEmitter fn [xb consumed-type then-leave?]
           (.block xb (^Consumer fn ^void [^CodeBuilder xb]
                       (when (emit/statms? xb bindings)
                         (when patch-letfn?
                           (dotimes [i (alength bindings)]
                             (.emit-store (.bound-to (aget bindings i)) xb)))
                         (when recur-to-body?
                           (let [start-of-body (.newLabel xb)]
                             (.labelBinding xb start-of-body)
                             (.set-recur-target! this start-of-body)))
                         (emit/then-leave? xb fctx consumed-type (.emitter body)
                                           then-leave?))))
           (when-not then-leave? ;can the then-leave? above return true?
             consumed-type))
          (insn/mk-insn (insn/expr-type body)))))
  (complete-method [this mspec pvars fctx body]
    (let [rt (-> mspec .at .return-type)
          at (if (type/auto-return-marker? rt)
               (let [logical-tp (type/expr-to-logical (insn/expr-type body))]
                 (ir/with-return-type (.at mspec) logical-tp))
               (do (insn/ensure-assignable rt body)
                   (.at mspec)))
          code (^CodeEmitter fn [xb consumed-type then-leave?]
                (emit/with-line-number xb fctx)
                (.set-recur-target! this (.startLabel xb)) ;recur to bci 0
                (when (emit/then-leave? xb fctx consumed-type (.emitter body)
                                        then-leave?)
                  consumed-type))]
      (MethodSpec. at code body pvars (.source-idx mspec) (.name mspec))))

  (set-recur-target! [this target]
    ;; __recur-target already defined if single `finally` is emitted twice
    (set! __recur-target target))
  (get-recur-target [this]
    __recur-target)
  (with-recur-variables [_ variables]
    (InsnFactoryImpl. variables nil))   ;clear __recur-target
  (recur-expr [this fctx args]
    (let [args ^Insns args
          arg-types (.expr-types args)
          ces (.emitters args)
          entities recur-variables]
      
      (error/when-not (= (alength arg-types) (alength entities))
        "recur expects" (txt (alength entities)) "arguments"
        (got-types arg-types))
      (dotimes [i (alength arg-types)]
        (let [exp (.value-type (aget entities i))
              act (aget arg-types i)]
          (error/when-not (type/assignable-from? exp act)
            "recur expects" (type exp) "for argument #"
            (txt (inc i)) (got-types arg-types))))

      (-> (^CodeEmitter fn [xb _ _]
           (let [iinc-deltas (recur-iinc-deltas entities ces)]
             (loop [i 0]
               (if (< i (alength ces))
                 ;; push operand or skip when rewriting as IINC
                 (when (or (primitive/valid-iinc-const? (aget iinc-deltas i))
                           (emit/insn? xb fctx (.value-type (aget entities i))
                                       (aget ces i)))
                   (recur (inc i)))
                 
                 ;; emit all store/iinc instructions
                 (loop [i (dec (alength entities))]
                   (if (neg? i)
                     (do (.goto_ xb (.get-recur-target this))
                         nil) ;operand type reported when emitting code
                     (let [d (aget iinc-deltas i)
                           ent (aget entities i)]
                       (if (primitive/valid-iinc-const? d)
                         (when-not (zero? d) ;elide for unchanged entity 
                           (.emit-iinc ent xb d))
                         (.emit-store ent xb))
                       (recur (dec i)))))))))
          (insn/mk-statm))))        ;`void` is type used while parsing
  
  (try-catch-finally [_ fctx body+catches catch-types finally]
    (let [insns ^Insns body+catches
          tp (condgen/join-type (.expr-types insns) 0 (.length insns))]
      (-> (if (some? finally)
            (trygen/try-catch-finally tp (.emitters insns) catch-types
                                      (.emitter finally) fctx)
            (trygen/try-catch tp (.emitters insns) catch-types fctx))
          (insn/mk-insn tp))))

  (type-cast [this fctx target-type arg]
    (let [arg-tp (insn/expr-type arg)]
      (letfn [(boxed-arg ^Insn [^Class prim-tp]
                (insn/cast-to arg (.class-reference (type/of prim-tp))
                              context/fctx-none))]
        (cond
          (or (type/polymorphic? target-type) ;force void context
              (type/polymorphic? arg-tp))
          (-> arg (insn/cast-to target-type fctx))

          (type/same? target-type arg-tp)
          arg
          
          (.isPrimitive target-type)
          (if (.isPrimitive arg-tp) ;no cast between different primitives
            (throw (insn/error-invalid-cast target-type arg-tp))
            (-> (boxed-arg target-type) (insn/cast-to target-type fctx)))
          
          ;; here holds: `target-type` is reference
          (.isPrimitive arg-tp)
          (-> (boxed-arg arg-tp) (insn/checkcast target-type fctx))
          
          ;; here holds: both `target-type` and `arg-tp` are reference
          :else (-> arg (insn/checkcast target-type fctx))))))
  (invoke-constructor [_ fctx owner args]
    (let [args ^Insns args
          mnm resolve/constructor-name
          ms (resolve/members-by-arg-types false owner mnm (.expr-types args))]
      (or (invoke-single-match ms nil args fctx)
          (throw (error-unresolved-member ms owner mnm args "constructor")))))
  (invoke-static-member [_ fctx invoke-member-if-field? owner mnm args]
    (let [args ^Insns args
          ms (resolve/members-by-arg-types true owner mnm (.expr-types args))]
      ;; (prn :et (seq (.expr-types args)))
      ;; (prn :ms (seq ms))
      ;; (prn :invoke-member-if-field? invoke-member-if-field?)
      (or (when-some [insn (invoke-single-match ms nil args fctx)]
            (if (and invoke-member-if-field? (member/field? (first ms)))
              (assert false "not yet implemented")
              insn))
          (throw (error-unresolved-member ms owner mnm args "static")))))
  (invoke-virtual-member [_ fctx receiver opt-owner mnm args]
    (let [receiver ^Insn receiver
          args ^Insns args
          owner (or opt-owner (insn/expr-type receiver))
          ms (resolve/members-by-arg-types false owner mnm (.expr-types args))]
      (or (invoke-single-match ms receiver args fctx)
          (throw (error-unresolved-member ms owner mnm args "virtual")))))

  (get-static-field [_ fctx owner mnm]
    (let [args insn/empty-insns
          ms (resolve/field-exact nil true owner mnm resolve/empty-class-array)]
      (or (invoke-single-match ms nil args fctx)
          (throw (error-unresolved-member ms owner mnm args "static")))))
  (get-virtual-field [_ fctx receiver mnm]
    (let [receiver ^Insn receiver
          args insn/empty-insns
          owner (insn/expr-type receiver)
          ms (resolve/field-exact nil false owner mnm (.expr-types args))]
      (or (invoke-single-match ms receiver args fctx)
          (error/throw "no virtual field matching" (sym owner mnm)))))

  (throw-expr [_ fctx arg]
    (let [arg ^Insn arg]
      (if (.isAssignableFrom Throwable (insn/logical-type arg))
        (-> (^CodeEmitter fn [xb _ _]
             (when (insn/emit-logical? xb arg)
               (-> xb (emit/with-line-number fctx) (.athrow))
               nil))         ;operand type reported when emitting code
            (insn/mk-insn Void/TYPE))   ;type used while parsing
        (throw (insn/error-type "expect instance of Throwable" arg))))))

(defn mk-factory ^ExprFactory []
  (InsnFactoryImpl. nil nil))
