(ns tcljx.nmspgen.constgen
  (:require
   (tcljx.data [meta :as meta] [reflect :as reflect] [type :as type] [ir :as ir])
   (tcljx.nmspgen [runtime :as rt] [util :as util]))
  (:import
   (tcljx.data.ir CodeEmitter Loadable Entity ImmediateEntity Constant)
   (clojure.lang Named IMeta)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.classfile.constantpool ConstantPoolBuilder LoadableConstantEntry
                                     ConstantDynamicEntry)
   (java.lang.constant ClassDesc ConstantDesc DirectMethodHandleDesc
                       Constable ConstantDescs)
   (java.util List)
   (java.util.regex Pattern)))

;;; Note: Accurate types of non-int but "computationally int" values
;;; must be represented via DynamicConstantDesc entries in `c`.
(defn- loadable-entry ^LoadableConstantEntry [^ConstantPoolBuilder cpb ^Object c]
  (letfn [(type-desc-meta ^ClassDesc [^Object c]
            (cond
              (symbol? c) rt/symbol
              (seq? c) rt/list
              (vector? c) rt/vector
              (map? c) rt/map
              (set? c) rt/set
              :else (throw (IllegalArgumentException. (str (class c))))))
          (cde-quote ^ConstantDynamicEntry [^String fnm ^ClassDesc tp bs-args]
            (let [bsm (.bsmEntry cpb (.methodHandleEntry cpb rt/bsm-quote)
                                 ^java.util.List bs-args)
                  nat (.nameAndTypeEntry cpb fnm tp)]
              (.constantDynamicEntry cpb bsm nat)))
          
          (cde-named ^ConstantDynamicEntry [^String fnm ^ClassDesc tp ^Named c]
            (let [nm-entry (.stringEntry cpb (name c))]
              (cde-quote fnm tp (if-some [nmsp (namespace c)]
                                  [(.stringEntry cpb nmsp) nm-entry]
                                  [nm-entry]))))
          (cde-pattern ^ConstantDynamicEntry [^Pattern c]
            (cde-quote "re-pattern" rt/pattern
                       [(.stringEntry cpb (.pattern c))]))
          (cde-coll ^ConstantDynamicEntry [^DirectMethodHandleDesc mhd ^seq cs]
            (cde-quote (.methodName mhd) (-> mhd .invocationType .returnType)
                       (for [c cs] (loadable-entry cpb c))))
          
          (entry-imeta ^ConstantDynamicEntry [^Object c]
            (cond
              (symbol? c) (cde-named "symbol" rt/symbol c)
              (seq? c) (cde-coll rt/mhd-list c)
              (vector? c) (cde-coll rt/mhd-vector (seq c))
              (map? c) (cde-coll rt/mhd-map (mapcat identity c))
              (set? c) (cde-coll rt/mhd-set (seq c))
              :else (throw (IllegalArgumentException. (str (class c))))))
          (entry-nometa ^LoadableConstantEntry [^Object c]
            ;; describe `c` ignoring its meta value
            (cond
              (nil? c) (recur ConstantDescs/NULL) ;guard against nil in coll
              (instance? ConstantDesc c) (.loadableConstantEntry cpb c)
              (instance? Constable c) (recur (reflect/describe c))
              (keyword? c) (cde-named "keyword" rt/keyword c)
              (instance? IMeta c) (entry-imeta c)
              (instance? Pattern c) (cde-pattern c)
              :else (throw (IllegalArgumentException. (str (class c))))))]
    
    (if-some [m (meta/source-meta c)]
      ;; (instance? IMeta c) is implied by (some? m)
      (let [bs-args ^List [(entry-imeta c) (loadable-entry cpb m)]
            bsm (.bsmEntry cpb (.methodHandleEntry cpb rt/bsm-quote) bs-args)
            nat (.nameAndTypeEntry cpb "with-meta" (type-desc-meta c))]
        (.constantDynamicEntry cpb bsm nat))
      (entry-nometa c))))

(defn- collection-entry ^LoadableConstantEntry [^ConstantPoolBuilder cpb
                                                ^Class tp ^CodeEmitter/1 ldbls]
  (letfn [(cde-coll ^ConstantDynamicEntry [^DirectMethodHandleDesc mhd]
            (let [bs-args (for [^Loadable ldbl ldbls]
                            (.loadable-entry ldbl cpb true))
                  bsm (.bsmEntry cpb (.methodHandleEntry cpb rt/bsm-quote)
                                 ^java.util.List bs-args)
                  nat (.nameAndTypeEntry cpb (.methodName mhd)
                                         (-> mhd .invocationType .returnType))]
              (.constantDynamicEntry cpb bsm nat)))]
    (condp identical? tp
      type/vector (cde-coll rt/mhd-vector)
      type/map (cde-coll rt/mhd-map)
      type/set (cde-coll rt/mhd-set)
      type/list (cde-coll rt/mhd-list))))

(defn- with-meta-entry ^LoadableConstantEntry [^ConstantPoolBuilder cpb
                                               ^Class tp ^CodeEmitter/1 ldbls]
  (let [bsm (.bsmEntry cpb (.methodHandleEntry cpb rt/bsm-quote)
                       ^java.util.List (for [^Loadable ldbl ldbls]
                                         (.loadable-entry ldbl cpb true)))
        nat (.nameAndTypeEntry cpb "with-meta" (reflect/describe-class tp))]
    (.constantDynamicEntry cpb bsm nat)))

;;; Symbol, keyword, pattern, or Clojure collection.  Identity must be
;;; explicitly managed.  Does not participate in constant folding at
;;; compile time.  During bootstrap, application and compiler code
;;; have distinct representations of the entity's type.
(deftype CollectionConstant [^Object loadable-value ^Class opnd-type
                             ^boolean associate-meta?]
  CodeEmitter
  (emit-insn* [this xb consumed-type _]
    (util/with-void-empty-if-requested consumed-type
      (.ldc xb (.loadable-entry this (.constantPool xb) false))
      opnd-type))

  Loadable
  (loadable-entry [_ cpb logical-type?]
    (if (instance? CodeEmitter/1 loadable-value)
      (if associate-meta?
        (with-meta-entry cpb opnd-type loadable-value)
        (collection-entry cpb opnd-type loadable-value))
      (loadable-entry cpb loadable-value)))
  (datafy [_]
    (letfn [(value-seq ^seq [^CodeEmitter/1 a]
              (list* (map Loadable/.datafy a)))] ;wrap LazySeq
      (cond
        (seq? loadable-value) (list* loadable-value) ;wrap LazySeq
        
        (instance? CodeEmitter/1 loadable-value)
        (let [a ^CodeEmitter/1 loadable-value]
          (if associate-meta?
            (with-meta (Loadable/.datafy (aget a 0))
              (Loadable/.datafy (aget a 1)))
            (condp identical? opnd-type
              type/vector (vec (value-seq a))
              type/map (apply array-map (value-seq a))
              type/set (set (value-seq a))
              type/list (value-seq a))))
        
        :else loadable-value))))

(def collection CollectionConstant/new)

;;; ------------------------------------------------------------------------

(defn null? ^boolean [^Object value]
  (identical? ConstantDescs/NULL value))
(defn number-zero? ^boolean [^Object value]
  (and (instance? Number value) (= (.doubleValue ^Number value) 0.0)))

;;; Primitive value, null, String, or Class.  Identity is either value
;;; based (for primitives and null), or preserved by the JVM (String
;;; and Class are interned).  Participates in constant folding at
;;; compile time.  For non-null values the type is provided by the
;;; JVM, and even during bootstrap both application and compiler code
;;; agree on it.
(deftype JvmConstant [^Object computational-value ^Class opnd-type]
  CodeEmitter
  (emit-insn* [this xb consumed-type _]
    (util/with-void-empty-if-requested consumed-type
      (cond
        (null? computational-value)
        (do (.aconst_null xb)          ;elide any additional checkcast
            (if (.isPrimitive consumed-type)
              (.class-reference (type/of consumed-type))
              consumed-type))
        
        (type/same? opnd-type consumed-type)
        (do (if (instance? ConstantDesc computational-value)
              (.loadConstant xb ^ConstantDesc computational-value)
              (.ldc xb (.loadable-entry this (.constantPool xb) false)))
            consumed-type)
        
        (instance? Number computational-value)
        (if (.isPrimitive consumed-type) ;cannot be void
          (do (->> (type/convert-from-constant consumed-type computational-value)
                   (.loadConstant xb))
              consumed-type)
          (do (.loadConstant xb ^ConstantDesc computational-value)
              opnd-type))
        
        :else
        (do (.ldc xb (.loadable-entry this (.constantPool xb) false))
            opnd-type))))
  
  ImmediateEntity
  (value-type [_]
    opnd-type)
  (value-type-exact [this]
    (-> opnd-type (type/expr-to-logical) (reflect/describe-class)))
  (entity-id [_]
    ir/entity-id-constant)
  (namespace-if-def [_]
    nil)

  Constant
  (computational-value [_]
    computational-value)
  (loadable-entry [this cpb logical-type?]
    (->> (if logical-type? (.datafy this) computational-value)
         (loadable-entry cpb)))
  (datafy [_]
    (when-not (null? computational-value)
      (if (instance? Integer computational-value)
        (let [x ^int computational-value]
          (condp identical? opnd-type
            Integer/TYPE computational-value
            Boolean/TYPE (object (not= x 0))
            Character/TYPE (object (char x))
            Byte/TYPE (object (byte x))
            Short/TYPE (object (short x))))
        computational-value))))

(def emitter-empty (^CodeEmitter fn [xb _ _] Void/TYPE))
(defn emitter-empty? ^boolean [^CodeEmitter ce]
  (identical? emitter-empty ce))
(def entity-null (JvmConstant. ConstantDescs/NULL type/poly-reference))
(defn entity-null? ^boolean [^CodeEmitter ce]
  (identical? entity-null ce))

(def entity-false (JvmConstant. 0 Boolean/TYPE))
(def entity-true (JvmConstant. 1 Boolean/TYPE))

(defn constant ^JvmConstant [^Object computational-value ^Class type]
  (cond                   ;enforce singleton for null, false, and true
    (identical? ConstantDescs/NULL computational-value)
    entity-null
    
    (type/same? Boolean/TYPE type)
    (if (zero? ^int computational-value) entity-false entity-true)
    
    :else (JvmConstant. computational-value type)))

(defn const? ^boolean [^CodeEmitter ce]
  (instance? JvmConstant ce))
(defn const-value ^Object [^CodeEmitter ce]
  (when (const? ce)
    (JvmConstant/.computational-value ce)))

(def entity-int-zero (constant 0 Integer/TYPE))
(defn entity-number-zero? ^boolean [^CodeEmitter ce]
  (and (const? ce) (number-zero? (const-value ce))))
