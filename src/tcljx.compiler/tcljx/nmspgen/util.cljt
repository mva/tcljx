(ns tcljx.nmspgen.util
  (:require (tcljx.data [type :as type] [reflect :as reflect] [code :as code]
                        [ir :as ir]))
  (:import (tcljx.data.ir CodeEmitter Entity ArityType MethodSpec)
           (java.lang.classfile CodeBuilder TypeKind)
           (java.lang.constant ClassDesc MethodTypeDesc)
           (java.util Map)
           (java.util.function BiFunction)))

(letfn [(two-slots? ^boolean [^Class tp] ;aka "is of category 2?"
          (or (identical? Long/TYPE tp) (identical? Double/TYPE tp)))]
  (defn pop ^CodeBuilder [^CodeBuilder xb ^Class on-stack-type]
    ;; pre: `on-stack-type` is not Void/TYPE
    (if (two-slots? on-stack-type) (-> xb .pop2) (-> xb .pop)))
  (defn dup ^CodeBuilder [^CodeBuilder xb ^Class on-stack-type]
    ;; pre: `on-stack-type` is not Void/TYPE
    (if (two-slots? on-stack-type) (-> xb .dup2) (-> xb .dup)))
  (defn dup-x1 ^CodeBuilder [^CodeBuilder xb ^Class on-stack-type]
    ;; pre: `on-stack-type` is not Void/TYPE, value2 is of category 1
    (if (two-slots? on-stack-type) (-> xb .dup2_x1) (-> xb .dup_x1))))

(defmacro with-void-empty-if-requested [consumed-type & body]
  (assert (symbol? consumed-type))
  `(if (type/void? ~consumed-type)
     Void/TYPE
     (do ~@body)))

(defmacro with-dup-unless-void-> [xb consumed-type on-stack-type body-expr]
  `(let [xb# ~xb, on-stack-type# ~on-stack-type]
     (if (type/void? ~consumed-type)
       (do (-> xb# ~body-expr) Void/TYPE)
       (do (-> xb# (dup on-stack-type#) ~body-expr) on-stack-type#))))

(defmacro with-dup-x1-unless-void-> [xb consumed-type on-stack-type body-expr]
  `(let [xb# ~xb, on-stack-type# ~on-stack-type]
     (if (type/void? ~consumed-type)
       (do (-> xb# ~body-expr) Void/TYPE)
       (do (-> xb# (dup-x1 on-stack-type#) ~body-expr) on-stack-type#))))

(defn acc-varargs ^int [^int flags ^MethodSpec mspec]
  (cond-> flags
    (-> mspec .at .varargs?) (bit-or (code/acc* varargs))))

(def ^:private ZERO (object 0))
(defn distinct-name ^String [^Map seen ^String nm]
  (let [n ^int (.compute seen nm
                         (^BiFunction fn ^Integer [_ ^Integer v]
                          (if (nil? v) ZERO (object (inc ^int v)))))]
    (cond-> nm (pos? n) (str "^" n))))

(defn mtd-of-arity-type ^MethodTypeDesc [^ArityType at]
  (MethodTypeDesc/of (reflect/describe-class (.return-type at))
                     (reflect/describe-class* (.parameter-types at))))

(defn entity-type-exact* ^ClassDesc/1 [^Entity/1 ents]
  (let [a (new ClassDesc/1 (alength ents))]
    (dotimes [i (alength a)]
      (aset a i (.value-type-exact (aget ents i))))
    a))
(defn mtd-factory ^MethodTypeDesc [^ClassDesc this-class ^Entity/1 ents]
  (MethodTypeDesc/of this-class (entity-type-exact* ents)))

;;; ------------------------------------------------------------------------

(deftype LocalVariable [^Class type ^int entity-id ^CodeEmitter init
                        ^:unsynchronized-mutable ^int slot]
  CodeEmitter
  (emit-insn* [_ xb consumed-type _]
    (with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  
  Entity
  (value-type [_]
    type)
  (value-type-exact [this]
    (reflect/describe-class (.value-type this)))
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    ir/invoke-methods-dynamic)
  (invoke* [this fctx form _ m-idx xs]
    (throw (IllegalStateException.)))
  (emit-store [_ xb]
    (.storeLocal xb (TypeKind/from type) slot))
  (emit-iinc [_ xb const]
    (.iinc xb slot const))
  
  tcljx.data.ir.BindableEntity
  (binding-mode-let [_]
    ir/bound-as-alias)
  (emit-setup-code? [_ xb param-no name]
    (if (= param-no -2) ;let binding if no param-no given, otherwise parameter
      (let [tk (TypeKind/from type), label (.newLabel xb)]
        (when-some [on-stack-type (.emit-insn* init xb type false)]
          (set! slot (.allocateLocal xb tk))
          (-> (.storeLocal xb tk slot)
              (.labelBinding label)
              (.localVariable slot name (reflect/describe-class type)
                              label (.endLabel xb)))
          true))
      (do (set! slot (if (neg? param-no)
                       (.receiverSlot xb)
                       (.parameterSlot xb param-no)))
          (.localVariable xb slot name (reflect/describe-class type)
                          (.startLabel xb) (.endLabel xb))
          true))))
(defn entity-local ^LocalVariable [^Class type ^int entity-id ^CodeEmitter init]
  (LocalVariable. type entity-id init -1))

(defn parameter* ^Entity [^CodeBuilder xb ^String opt-name
                          ^Class type ^ClassDesc type-desc ^int param-no]
  (let [slot (.parameterSlot xb param-no)]
    (when (some? opt-name)
      (.localVariable xb slot opt-name type-desc
                      (.startLabel xb) (.endLabel xb)))
    (LocalVariable. type 0 nil slot)))
