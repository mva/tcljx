(ns tcljx.classgen.fngen
  (:require
   (tcljx.data [config :as cfg] [context :as context] [member :as member]
               [type :as type] [reflect :as reflect] [resolve :as resolve]
               [ir :as ir] [code :as code])
   (tcljx.classgen [classfile :as classfile] [runtime :as rt] segment
                   [util :as util] [emit :as emit] [constgen :as constgen]
                   [insn :as insn] [condgen :as condgen] [fnenv :as fnenv]))
  (:import
   (tcljx.data.ir CodeEmitter Entity BindableEntity ImmediateEntity FnPromise
                  ArityType AritySpec MethodSpec FieldSpec NmspClass
                  Parser ExprFactory EntityFactory)
   (tcljx.data.member MemberHandle)
   (tcljx.classgen.segment CodePromise Display StoredEnv SegmentBuilder)
   (tcljx.classgen.insn Insn Insns PlainInvokeTest)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind Opcode Label
                        BootstrapMethodEntry)
   (java.lang.classfile.instruction SwitchCase)
   (java.lang.constant ClassDesc MethodTypeDesc MethodHandleDesc
                       ConstantDesc DirectMethodHandleDesc ConstantDescs
                       DirectMethodHandleDesc$Kind
                       DynamicConstantDesc DynamicCallSiteDesc)
   (java.lang.invoke MethodHandle)
   (java.lang.reflect Executable Method)
   (java.util ArrayList HashMap)
   (java.util.function Consumer)))

(defn- source-order-idxs ^int/1 [^MethodSpec/1 mspecs]
  (let [source-order (new int/1 (alength mspecs))]
    (dotimes [i (alength mspecs)]
      (aset source-order (.source-idx (aget mspecs i)) i))
    source-order))

(defn- bridge-to-iseq [^ClassBuilder cb ^int flags
                       ^DirectMethodHandleDesc mhd-iseq]
  (let [virtual? (not (member/acc-static? flags))
        mtd-iseq (cond-> (.invocationType mhd-iseq)
                   virtual? (.dropParameterTypes 0 1))
        n (.parameterCount mtd-iseq)
        mtd-varargs (.changeParameterType mtd-iseq (dec n) rt/ObjectArray)]
    (->> (^Consumer fn ^void [^CodeBuilder xb]
          (when virtual?
            (code/load-receiver xb))
          (-> (code/load-all-parameters xb mtd-iseq)
              (.invokestatic rt/ArraySeq "create" rt/mtd-ArraySeq-objects))
          (if virtual?
            (.invokevirtual xb (.owner mhd-iseq) (.methodName mhd-iseq) mtd-iseq)
            (.invokestatic xb (.owner mhd-iseq) (.methodName mhd-iseq) mtd-iseq))
          (.return_ xb (TypeKind/from (.returnType mtd-iseq))))
         (.withMethodBody cb (.methodName mhd-iseq) mtd-varargs
                          (bit-or flags (ir/acc* bridge varargs synthetic))))))

(defn- fn-entry-point
  (^DirectMethodHandleDesc [^DirectMethodHandleDesc mhd] ;pre: mhd is variadic
   (let [ld (.lookupDescriptor mhd)
         tpd-iseq "Lclojure/lang/ISeq;"
         i (.lastIndexOf ld (str tpd-iseq ")"))] ;proper type index by guard
     (->> (str (.substring ld 0 i) "[Ljava/lang/Object;"
               (.substring ld (+ i (.length tpd-iseq))))
          (MethodHandleDesc/of (.kind mhd) (.owner mhd)
                               (.methodName mhd)))))
  (^DirectMethodHandleDesc [^DirectMethodHandleDesc mhd ^MethodSpec mspec]
   (if (-> mspec .at .variadic?)        ;implies ISeq as last type
     (fn-entry-point mhd)
     mhd)))
(defn- fn-entry-points ^DirectMethodHandleDesc/1 [^DirectMethodHandleDesc/1 mhds
                                                  ^MethodSpec/1 mspecs]
  (let [n-m1 (dec (alength mspecs)), mspec (aget mspecs n-m1)]
    (if (-> mspec .at .variadic?) ;implies ISeq as last type
      (doto (aclone mhds) (aset n-m1 (fn-entry-point (aget mhds n-m1))))
      mhds)))

;;; ------------------------------------------------------------------------

(deftype FnStatic [^int entity-id ^MethodSpec/1 method-specs
                   ^DirectMethodHandleDesc/1 entry-mhds]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (-> (DynamicConstantDesc/ofNamed rt/bsm-static-fn ConstantDescs/DEFAULT_NAME
                                     rt/StaticFn entry-mhds)
        (constgen/constant (.value-type this))
        (.emit-insn* xb consumed-type then-leave?)))
  
  ImmediateEntity
  (value-type [_]
    type/StaticFn)
  (value-type-exact [_]
    rt/StaticFn)
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    method-specs)
  (invoke* [this fctx form _ m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (insn/emit-invoke-arity (aget entry-mhds m-idx) at xs fctx xb))
          (insn/mk-insn (.return-type at)))))
  (emit-store [_ xb]                    ;empty letfn patch
    xb)

  BindableEntity
  (binding-mode-let [_]
    ir/bound-as-alias)
  (emit-setup-code? [_ xb param-no name]
    true))

(defn- static-mhds ^DirectMethodHandleDesc/1 [^ClassDesc owner ^String name-prefix
                                              ^MethodSpec/1 specs]
  (let [mhds (new DirectMethodHandleDesc/1 (alength specs))]
    (dotimes [i (alength mhds)]
      (let [spec (aget specs i), at (.at spec)
            nm (str name-prefix "~" (.parameter-count at))
            mhd (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                                           owner nm (util/mtd-of-arity-type at))
            body (-> spec .x-body .emitter)
            redir (when (instance? PlainInvokeTest body)
                    (.redirecting-to ^PlainInvokeTest body (.return-type at)
                                     (ir/translates-to-varargs? at)
                                     (.parameters spec)))]
        (aset mhds i (or redir mhd))))
    mhds))

(defn- class-elements-static ^void [^ClassBuilder cb ^CodePromise fn-p
                                    ^DirectMethodHandleDesc/1 mhds
                                    ^ClassDesc segment-class]
  (let [mspecs (.child-methods fn-p)
        source-order (source-order-idxs mspecs)]
    (fnenv/as-constants (.env-to-display fn-p))
    (dotimes [j (alength mspecs)]
      (let [i (aget source-order j), mspec (aget mspecs i), mhd (aget mhds i)
            flags (util/acc-varargs classfile/acc-method-static mspec)]
        (when (-> mspec .at .variadic?)
          (bridge-to-iseq cb flags mhd))
        (when (identical? segment-class (.owner mhd))
          (->> (^Consumer fn ^void [^CodeBuilder xb]
                (emit/body xb mspec 0))
               (.withMethodBody cb (.methodName mhd) (.invocationType mhd)
                                flags)))))))

(defn- as-fn-static ^Entity [^SegmentBuilder sb ^CodePromise fn-p
                             ^String name-prefix]
  (let [segment-class (.segment-class sb)
        mspecs (.child-methods fn-p)
        mhds (static-mhds segment-class name-prefix mspecs)]
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (class-elements-static cb fn-p mhds segment-class))
         (.add-elements sb))
    (FnStatic. -1 mspecs (fn-entry-points mhds mspecs))))

(letfn [(arity-parameter-types ^Class/1 [^MemberHandle m]
          (let [ptypes (.parameter-types m)]
            (if (reflect/takes-receiver? (.member m))
              (let [a (new Class/1 (inc (alength ptypes)))]
                (aset a 0 (.owner m))
                (System/arraycopy ptypes 0 a 1 (alength ptypes))
                a)
              ptypes)))
        (method-spec-of-match ^MethodSpec [^MemberHandle m]
          (let [varargs? (when (instance? Executable (.member m))
                           (.isVarArgs ^Executable (.member m)))
                ptypes (arity-parameter-types m)]
            (-> (ArityType. (.return-type m) ptypes nil varargs? false)
                (MethodSpec. nil nil nil 0 nil))))]
  
  (defn class-member-fn ^FnStatic [^MemberHandle m]
    (FnStatic. ir/entity-id-constant
               (doto (new MethodSpec/1 1)
                 (aset 0 (method-spec-of-match m)))
               (doto (new DirectMethodHandleDesc/1 1)
                 (aset 0 (reflect/mhd-of-member (.owner m) (.member m)))))))

;;; ------------------------------------------------------------------------

;;; Push back calls to other function's `value-type-exact` until the
;;; emit phase has started.
(definterface FnDesc
  (get-mhd-uncached ^DirectMethodHandleDesc [^int i])
  (get-mhd ^DirectMethodHandleDesc [^int i])
  (get-entry-mhd ^DirectMethodHandleDesc [^int i]))
(deftype FlyweightDesc [^ClassDesc owner ^String name-prefix
                        ^StoredEnv env ^MethodSpec/1 mspecs
                        ^DirectMethodHandleDesc/1 __mhd-cache]
  FnDesc
  (get-mhd-uncached [_ i]
    (let [at (.at (aget mspecs i))
          nm (str name-prefix "~" (.parameter-count at))
          tpd (util/entity-type-exact* (.aorigin env))
          mtd (-> (util/mtd-of-arity-type at)
                  (.insertParameterTypes 0 tpd))]
      (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                                 owner nm mtd)))
  (get-mhd [this i]
    (or (aget __mhd-cache i)
        (aset __mhd-cache i (.get-mhd-uncached this i))))
  (get-entry-mhd [this i]
    (fn-entry-point (.get-mhd this i) (aget mspecs i))))
(defn- fw-desc-of ^FlyweightDesc [^ClassDesc owner ^String name-prefix
                                  ^StoredEnv env ^MethodSpec/1 mspecs]
  (FlyweightDesc. owner name-prefix env mspecs
                  (new DirectMethodHandleDesc/1 (alength mspecs))))

(deftype FnFlyweight [^int entity-id ^MethodSpec/1 method-specs
                      ^FlyweightDesc fw-desc ^Entity/1 aorigin
                      ^HashMap owner-e2d]
  CodeEmitter
  (emit-insn* [_ xb consumed-type _] ;flyweight environment's prefix tuple
    (fnenv/load-env xb owner-e2d aorigin) ;view from outside
    consumed-type)
  
  Entity
  (value-type [_]
    type/StaticFn)
  (value-type-exact [_]
    (throw (IllegalStateException.)))
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    method-specs)
  (invoke* [this fctx form f m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (.emit-insn* f xb nil false) ;call into display
           (insn/emit-invoke-arity (.get-entry-mhd fw-desc m-idx) at xs fctx xb))
          (insn/mk-insn (.return-type at)))))
  (emit-store [_ xb]                    ;empty letfn patch
    xb)

  BindableEntity
  (binding-mode-let [_]
    ir/bound-as-alias)
  (emit-setup-code? [_ xb param-no name]
    true))

(defn- class-elements-flyweight ^void [^ClassBuilder cb ^MethodSpec/1 mspecs
                                       ^FlyweightDesc fw-desc ^StoredEnv env]
  (let [source-order (source-order-idxs mspecs)]
    (dotimes [j (alength mspecs)]
      (let [i (aget source-order j)
            mspec (aget mspecs i), mhd (.get-mhd fw-desc i)
            flags (util/acc-varargs (ir/acc* static final) mspec)]
        (when (-> mspec .at .variadic?)
          (bridge-to-iseq cb flags mhd))
        (->> (^Consumer fn ^void [^CodeBuilder xb]
              (let [first-param-no (fnenv/as-parameters xb env)]
                (emit/body xb mspec first-param-no)))
             (.withMethodBody cb (.methodName mhd) (.invocationType mhd)
                              flags))))))

(defn- as-fn-flyweight ^Entity [^SegmentBuilder sb ^CodePromise fn-p
                                ^String name-prefix ^StoredEnv env
                                ^HashMap parent-e2d ^Display display-this]
  (let [segment-class (.segment-class sb)
        mspecs (.child-methods fn-p)
        fw-desc (fw-desc-of segment-class name-prefix env mspecs)]
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (when (some? display-this) ;provide env prefix for recursive invoke
            (.set-emitter! display-this
                           (^CodeEmitter fn [xb consumed-type _]
                            (fnenv/load-env xb (.aorigin env)) ;view from inside
                            consumed-type)))
          (class-elements-flyweight cb mspecs fw-desc env))
         (.add-elements sb))
    (FnFlyweight. -1 mspecs fw-desc (.aorigin env) parent-e2d)))

;;; ------------------------------------------------------------------------

(letfn [(entity-before? ^boolean [^int fn-id ^int o-id]
          (or (< o-id fn-id)
              (not= (ir/closure-level* o-id) (ir/closure-level* fn-id))))]
  (defn- feed-forward ^Entity/1 [^int fn-id ^Entity/1 aorigin]
    (loop [acc aorigin, i (dec (alength aorigin))]
      (if (neg? i)
        acc
        (let [o-id (.entity-id (aget aorigin i))]
          (if (entity-before? fn-id o-id)
            (recur acc (dec i))
            (let [acc (if (identical? acc aorigin) (aclone aorigin) acc)]
              (aset acc i constgen/entity-null)
              (recur acc (dec i)))))))))

(deftype FnVirtual [^int entity-id ^MethodSpec/1 method-specs
                    ^DirectMethodHandleDesc/1 entry-mhds ^ClassDesc this-class
                    ^Entity/1 aorigin ^Entity/1 aforward ^HashMap parent-e2d
                    ^:unsynchronized-mutable ^int slot]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (if (neg? slot)
      (-> (fnenv/load-env xb parent-e2d (feed-forward entity-id aorigin))
          (.invokestatic this-class rt/name-factory-method
                         (util/mtd-factory this-class aorigin)))
      (.aload xb slot))
    type/AFnMh)
  
  Entity
  (value-type [_]
    type/AFnMh)
  (value-type-exact [_]
    this-class)
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    method-specs)
  (invoke* [this fctx form f m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insn? xb fctx type/AFnMh f)
             (insn/emit-invoke-arity (aget entry-mhds m-idx) at xs fctx xb)))
          (insn/mk-insn (.return-type at)))))
  (emit-store [this xb] ;highjacked to call __patch method with forward refs
    (when-not (identical? aorigin aforward)
      (let [tps (ArrayList.)]
        (.aload xb slot)           ;receiver is this function instance
        (dotimes [i (alength aorigin)]
          (let [o (aget aorigin i)]
            (when-not (identical? o (aget aforward i))
              (.emit-insn* o xb (.value-type o) false)
              (.add tps (.value-type-exact o)))))
        (.invokevirtual xb this-class rt/name-patch-method
                        (MethodTypeDesc/of ConstantDescs/CD_void tps))))
    xb)
  
  BindableEntity
  (binding-mode-let [_]
    ir/bound-with-emit-setup)
  (emit-setup-code? [this xb param-no name]
    (let [label (.newLabel xb)]
      (set! slot -1)                 ;force emit of factory invocation
      (.emit-insn* this xb type/AFnMh false)
      (set! slot (.allocateLocal xb TypeKind/REFERENCE))
      (-> (.storeLocal xb TypeKind/REFERENCE slot)
          (.labelBinding label)
          (.localVariable slot name this-class label (.endLabel xb)))
      true)))

(defn- entity-this ^Entity [^ClassDesc owner]
  (reify Entity
    (emit-insn* [_ xb _ _] (code/load-receiver xb) type/AFnMh)
    (value-type [_] type/AFnMh)
    (value-type-exact [_] owner)
    (entity-id [_] -1)))

(defn- virtual-mhds ^DirectMethodHandleDesc/1 [^ClassDesc owner
                                               ^MethodSpec/1 mspecs]
  (let [mhds (new DirectMethodHandleDesc/1 (alength mspecs))]
    (dotimes [i (alength mhds)]
      (let [at (.at (aget mspecs i))
            mnm (str "fn" (.parameter-count at))]
        (->> (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/VIRTUAL
                                        owner mnm (util/mtd-of-arity-type at))
             (aset mhds i))))
    mhds))

(letfn [(arity-parameter-count ^int [^DirectMethodHandleDesc mhd]
          (dec (.parameterCount (.invocationType mhd))))
        (arity-1 ^void [^CodeBuilder xb ^DirectMethodHandleDesc mhd ^int delta]
          (let [n* (+ (arity-parameter-count mhd) delta)
                test-args (doto (new CodeEmitter/1 2)
                            (aset 0 (util/parameter* xb nil Integer/TYPE
                                                     ConstantDescs/CD_int 0))
                            (aset 1 (constgen/constant n* Integer/TYPE)))
                cmp (if (neg? delta) condgen/cmp-ge condgen/cmp-eq)
                ce (condgen/mk-if
                    (if (and (= cmp condgen/cmp-ge) (zero? n*))
                      constgen/entity-true
                      (condgen/mk-cmp-pred Opcode/IF_ICMPEQ cmp Integer/TYPE
                                           test-args context/fctx-none))
                    MethodHandle
                    (constgen/constant mhd MethodHandle)
                    constgen/emitter-empty context/fctx-none)]
            (emit/then-leave? xb context/fctx-none MethodHandle ce true)))
        (arity-fixed-n ^void [^CodeBuilder xb ^DirectMethodHandleDesc/1 mhds]
          (let [scs (new SwitchCase/1 (alength mhds))
                target-default (.newLabel xb)]
            (dotimes [i (alength scs)]
              (aset scs i (SwitchCase/of (arity-parameter-count (aget mhds i))
                                         (.newLabel xb))))
            (-> (.iload xb (.parameterSlot xb 0))
                (.lookupswitch target-default (java.util.Arrays/asList scs)))
            (dotimes [i (alength scs)]
              (-> (.labelBinding xb (.target (aget scs i)))
                  (.ldc (aget mhds i))
                  (.areturn)))
            (-> (.labelBinding xb target-default)
                (.aconst_null)
                (.areturn))))
        (arity-varargs-n ^void [^CodeBuilder xb ^DirectMethodHandleDesc/1 mhds]
          (let [n-m1 (dec (alength mhds)) ;here holds: (pos? n-m1)
                fixed (-> (aget mhds n-m1) (arity-parameter-count) (dec))
                table (new ConstantDesc/1 (inc fixed))]
            (loop [a 0, i 0]
              (cond
                (= a n-m1)              ;processed all fixed arities
                nil
                (= i (-> (aget mhds a) (arity-parameter-count)))
                (do (aset table i (aget mhds a)) (recur (inc a) (inc i)))
                :else
                (recur a (inc i))))
            (let [n-scs (- (alength table) (int (nil? (aget table fixed))))
                  scs (new SwitchCase/1 n-scs)
                  target-default (.newLabel xb)]
              (dotimes [i n-scs]
                (aset scs i (SwitchCase/of i (.newLabel xb))))
              (-> (.iload xb (.parameterSlot xb 0))
                  (.tableswitch 0 (dec n-scs) target-default
                                (java.util.Arrays/asList scs)))
              (dotimes [i n-scs]
                (-> (.labelBinding xb (.target (aget scs i)))
                    (.loadConstant (or (aget table i) ConstantDescs/NULL))
                    (.areturn)))
              (-> (.labelBinding xb target-default)
                  (.ldc (aget mhds n-m1))
                  (.areturn)))))]
  
  (defn- class-elements-virtual ^void [^ClassBuilder cb ^MethodSpec/1 mspecs
                                       ^DirectMethodHandleDesc/1 mhds
                                       ^ClassDesc this-class
                                       ^MethodTypeDesc factory-mtd
                                       ^FieldSpec/1 fields]
    (let [constr-mtd (-> factory-mtd
                         (.insertParameterTypes 0 rt/map)
                         (.changeReturnType ConstantDescs/CD_void))
          entry-mhds (fn-entry-points mhds mspecs)]
      ;; virtual fields holding the closed over environment
      (code/with-fields cb fields)
      ;; virtual methods implementing the function arities
      (let [source-order (source-order-idxs mspecs)]
        (dotimes [j (alength mspecs)]
          (let [i (aget source-order j), mspec (aget mspecs i)
                mhd (aget mhds i)
                mtd (util/mtd-of-arity-type (.at mspec))
                flags (util/acc-varargs (ir/acc* public final) mspec)]
            (when (-> mspec .at .variadic?)
              (bridge-to-iseq cb flags mhd))
            (->> (^Consumer fn ^void [^CodeBuilder xb]
                  (-> (.localVariable xb (.receiverSlot xb) (.name mspec)
                                      this-class (.startLabel xb)
                                      (.endLabel xb))
                      (emit/body mspec 0)))
                 (.withMethodBody cb (.methodName mhd) mtd flags)))))
      ;; virtual method __arityOrNull
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (let [at-last (.at (aget mspecs (dec (alength mspecs))))]
              (if (ir/translates-to-varargs? at-last)
                (if (= (alength entry-mhds) 1)
                  (arity-1 xb (aget entry-mhds 0) -1)
                  (arity-varargs-n xb entry-mhds))
                (if (= (alength entry-mhds) 1)
                  (arity-1 xb (aget entry-mhds 0) 0)
                  (arity-fixed-n xb entry-mhds)))))
           (.withMethodBody cb rt/name-arity-method
                            rt/mtd-arity-method
                            (ir/acc* public final synthetic)))
      ;; virtual method __directMethodHandles
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.loadConstant xb (alength entry-mhds))
                (.anewarray rt/MethodHandle))
            (dotimes [i (alength entry-mhds)]
              (-> xb (.dup) (.loadConstant i) (.ldc (aget entry-mhds i)) (.aastore)))
            (.areturn xb))
           (.withMethodBody cb rt/name-dmh-method
                            rt/mtd-dmh-method
                            (ir/acc* public final synthetic)))
      ;; private constructor <init>
      (code/constructor cb fields rt/AFn (ir/acc* private synthetic)
                        (doto (new ClassDesc/1 1) (aset 0 rt/map)))
      ;; public static factory method __create
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> xb (.new_ this-class) (.dup) (.aconst_null)
                (code/load-all-parameters factory-mtd)
                (.invokespecial this-class ConstantDescs/INIT_NAME constr-mtd)
                (.areturn)))
           (.withMethodBody cb rt/name-factory-method factory-mtd
                            (ir/acc* public static final synthetic)))
      ;; package-private virtual method __patch
      (when-some [patch-mtd (fnenv/mtd-of-patch fields)]
        (->> (^Consumer fn ^void [^CodeBuilder xb]
              (loop [param-no 0, i 0]
                (when (< i (alength fields))
                  (let [fs (aget fields i)]
                    (recur (if (member/acc-final? (.flags fs))
                             param-no
                             (do (code/put-field xb fs param-no)
                                 (inc param-no)))
                           (inc i)))))
              (.return_ xb))
             (.withMethodBody cb rt/name-patch-method patch-mtd
                              (ir/acc* final synthetic))))
      ;; protected virtual method __withMetaImpl
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.new_ xb this-class) (.dup) (.aload (.parameterSlot xb 0)))
            (dotimes [i (alength fields)]
              (code/get-field xb (aget fields i)))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb rt/name-with-meta-impl
                            (MethodTypeDesc/of this-class rt/map)
                            (ir/acc* protected final synthetic))))))

(defn- as-fn-virtual ^Entity [^SegmentBuilder sb ^int entity-id
                              ^MethodSpec/1 mspecs ^ClassDesc this-class
                              ^StoredEnv env ^HashMap parent-e2d]
  (let [super-class rt/AFn
        mhds (virtual-mhds this-class mspecs)
        aforward (feed-forward entity-id (.aorigin env))]
    
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (let [factory-mtd (util/mtd-factory this-class (.aorigin env))
                constr-mtd (-> (.insertParameterTypes factory-mtd 0 rt/map)
                               (.changeReturnType ConstantDescs/CD_void))
                
                fields (fnenv/fields-exact 0 this-class env aforward)]
            (fnenv/as-fields 0 fields env) ;picked up by all virtual arity methods below
            (-> (cfg/with-class-version cb)
                (.withFlags (ir/acc* public final))
                (.withSuperclass super-class)
                (class-elements-virtual mspecs mhds this-class factory-mtd
                                        fields))))
         (ir/mk-nmsp-class this-class super-class)
         (.add-class-file sb))
    (FnVirtual. entity-id mspecs (fn-entry-points mhds mspecs) this-class
                (.aorigin env) aforward parent-e2d -1)))

;;; ------------------------------------------------------------------------

(deftype FnPromiseImpl [^int entity-id ^MethodSpec/1 method-specs
                        ^HashMap env-to-display ^HashMap parent-e2d
                        ^String unique-nm ^ArrayList !nested-parts
                        ^:unsynchronized-mutable ^BindableEntity __emit
                        ^:unsynchronized-mutable ^int __materialized]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (.emit-insn* __emit xb consumed-type then-leave?))
  
  Entity
  (value-type [_]
    type/AFnMh)
  (value-type-exact [_]
    (.value-type-exact __emit))
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    method-specs)
  (invoke* [this fctx form opt-f m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb consumed-type then-leave?]
           (-> (.get-emit-entity this) ;trampoline to get current entity
               (.invoke* fctx form opt-f m-idx xs)
               (insn/emitter)
               (.emit-insn* xb consumed-type then-leave?)))
          (insn/mk-insn (.return-type at)))))
  (emit-store [_ xb]                ;delegate letfn patching to __emit
    (.emit-store __emit xb))

  BindableEntity
  (binding-mode-let [_]
    ir/bound-with-emit-setup)
  (emit-setup-code? [_ xb param-no name]
    (.emit-setup-code? __emit xb param-no name))
  
  FnPromise
  (get-emit-entity [_]
    __emit)
  (value-use? [_]
    (pos? __materialized))
  (count-value-use! [this delta]
    (locking this
      #_(prn :count-value-use __materialized '-> (+ __materialized delta))
      (set! __materialized (+ __materialized delta))
      (assert (>= __materialized 0))))
  
  CodePromise
  (expr-of [this]
    (insn/value-of* this))
  (child-methods [_]
    method-specs)
  (env-to-display [_]
    env-to-display)
  (!nested-parts [_]
    !nested-parts)
  (generate-and-deliver [this sb env-factory _]
    (set! __emit
          (if (.value-use? this)
            (if (.fn-carries-env? env-factory this)
              (let [this-class (.namespace-class sb unique-nm)
                    this-emit (entity-this this-class)
                    env (.stored-environment! env-factory this this-emit)]
                #_(prn :as-fn-virtual unique-nm)
                (as-fn-virtual sb entity-id method-specs this-class env parent-e2d))
              (do #_(prn :as-fn-static unique-nm)
                  (as-fn-static sb this unique-nm)))
            (let [env (.stored-environment! env-factory this nil)]
              #_(prn :as-fn-flyweight unique-nm)
              (as-fn-flyweight sb this unique-nm env parent-e2d
                               (.get env-to-display this)))))))

;;; ------------------------------------------------------------------------

(deftype ItfFn [^int entity-id ^MethodSpec/1 method-specs ^String unique-nm
                ^Class itf-class ^Method method ^HashMap env-to-display
                ^HashMap parent-e2d ^ArrayList !nested-parts
                ^:unsynchronized-mutable ^Consumer __emit]
  Entity
  (emit-insn* [this xb consumed-type then-leave?]
    (util/with-void-empty-if-requested consumed-type
      (.accept __emit xb)
      itf-class))
  (value-type [_]
    itf-class)
  (value-type-exact [_]
    (reflect/describe-class itf-class))
  (invoke-methods [_]
    ir/invoke-methods-dynamic)
  (entity-id [_]
    entity-id)
  
  CodePromise
  (expr-of [this]
    (insn/mk-insn this itf-class))
  (child-methods [_]
    method-specs)
  (env-to-display [_]
    env-to-display)
  (!nested-parts [_]
    !nested-parts)
  (generate-and-deliver [this sb env-factory _]
    (let [mspec (aget method-specs 0)
          env (.stored-environment! env-factory this nil)
          mhd-itf (reflect/mhd-of-method itf-class method)
          aorigin (.aorigin env)
          fw-desc (fw-desc-of (.segment-class sb) unique-nm env method-specs)]
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (let [inv-type (MethodTypeDesc/of (reflect/describe-class itf-class)
                                              (util/entity-type-exact* aorigin))
                  mtd-lookup (-> (.invocationType mhd-itf) 
                                 (.dropParameterTypes 0 1))
                  d-mtd (util/mtd-of-arity-type (.at mspec))
                  dcd (DynamicCallSiteDesc/of
                       rt/bsm-metafactory (.methodName mhd-itf) inv-type
                       mtd-lookup (.get-mhd fw-desc 0) d-mtd)]
              (-> xb (fnenv/load-env parent-e2d aorigin) (.invokedynamic dcd))))
           (set! __emit))
      (->> (^Consumer fn ^void [^ClassBuilder cb]
            (class-elements-flyweight cb method-specs fw-desc env))
           (.add-elements sb)))))
(def promise-itf-fn ItfFn/new)
