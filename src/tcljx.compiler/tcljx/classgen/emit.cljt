(ns tcljx.classgen.emit
  (:require
   (tcljx.data [context :as context] [type :as type] [ir :as ir]
               [reflect :as reflect])
   (tcljx.classgen [util :as util]))
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.ir CodeEmitter Entity MethodSpec)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind)
   (java.lang.constant MethodTypeDesc ConstantDesc ClassDesc ConstantDescs)))

;;; Line numbers are written to enable accurate stack traces.  Any
;;; instruction that may cause a stack trace (in other words: that may
;;; raise an exception) should have a line number, as well as any
;;; instruction that appears as an ancestor stack trace element (that
;;; is, almost every invoke instruction).
;;;
;;; The form context `fctx` of an instruction of interest refers to
;;; the Clojure list form from which it was compiled.  Its line number
;;; is taken from the opening parenthesis of the list.  Type adaption
;;; instructions take a `consumer-fctx`, which refers to the *parent*
;;; expression that consumes the adapted value, *not* the `fctx` of
;;; the on stack value being adapted.
(defn with-line-number ^CodeBuilder [^CodeBuilder xb ^long fctx]
  ;; Note: Writing only line number of zero triggers output of an
  ;; empty "LineNumberTable" attribute.  For example invocations of
  ;; runtime methods are emitted without any line number.
  (let [line (context/fctx-line fctx)]
    (cond-> xb (pos? line) (.lineNumber (context/fctx-line fctx)))))

;;; Do not push a reference as "consumed type" into a code emitter
;;; that natively produces a primitive value.  The emitter must
;;; materialize the primitive to trigger any NPE, before the known to
;;; be non-nil consumed value is produced.
(defn with-adaption-barrier ^CodeEmitter [^Class produced-type ^CodeEmitter ce]
  (^CodeEmitter fn [xb consumed-type then-leave?]
   (if (or (type/void? consumed-type)
           (type/polymorphic? produced-type)
           (identical? produced-type consumed-type)
           (= (.isPrimitive produced-type) (.isPrimitive consumed-type)))
     (.emit-insn* ce xb consumed-type then-leave?)
     (.emit-insn* ce xb produced-type false))))

(letfn [(unbox-reference ^void [^CodeBuilder xb ^long consumer-fctx
                                ^Class consumed-type ^Class on-stack-type]
          ;; pre: (.isPrimitive consumed-type)
          (let [box-type (.class-reference (type/of consumed-type))
                mtd (MethodTypeDesc/of (reflect/describe-class consumed-type))
                mnm (str (.getSimpleName consumed-type) "Value")]
            (if (type/same? Number on-stack-type) ;not instanceof test!
              ;; type conversion from Number to primitive type
              ;; FIXME... does conversion via Number.xxxValue() make
              ;; RT.longCast(Object) etc. redundant, at least as far
              ;; as tcljx is concerned?
              (-> (with-line-number xb consumer-fctx)
                  (.invokevirtual ConstantDescs/CD_Number mnm mtd))
              ;; type cast from box type to primitive type
              (do (when-not (type/same? box-type on-stack-type)
                    (cast-from-reference* xb consumer-fctx
                                          box-type on-stack-type))
                  (-> (with-line-number xb consumer-fctx)
                      (.invokevirtual (reflect/describe-class box-type) mnm
                                      mtd))))))
        (cast-from-reference* ^void [^CodeBuilder xb ^long consumer-fctx
                                     ^Class consumed-type ^Class on-stack-type]
          ;; pre: `on-stack-type` is reference type
          ;; pre: `on-stack-type` is not Void/TYPE
          ;; pre: `consumed-type` is not void
          (cond
            (.isPrimitive consumed-type)
            (unbox-reference xb consumer-fctx consumed-type on-stack-type)

            (.isAssignableFrom consumed-type on-stack-type)
            nil
                
            :else
            (-> (with-line-number xb consumer-fctx)
                (.checkcast (reflect/describe-class consumed-type)))))

        (box-primitive ^void [^CodeBuilder xb ^Class consumed-type
                              ^Class on-stack-type]
          ;; pre: (.isPrimitive on-stack-type) but it is not void
          (let [box-type (.class-reference (type/of on-stack-type))
                cd-box (reflect/describe-class box-type)
                mtd (MethodTypeDesc/of cd-box
                                       (reflect/describe-class on-stack-type))]
            (.invokestatic xb cd-box "valueOf" mtd)
            ;; there should be no scenario where the additonal cast
            ;; fails, so drop the line number for now
            (cast-from-reference* xb context/fctx-none consumed-type box-type)))

        (convert-from-primitive* ^void [^CodeBuilder xb ^Class consumed-type
                                        ^Class on-stack-type]
          ;; pre: (not (identical? consumed-type on-stack-type))
          ;; pre: `on-stack-type` is primitive type including void
          ;; pre: `consumed-type` is not void
          (cond
            (.isPrimitive consumed-type)
            (type/primitive-convert-from xb (type/of consumed-type)
                                         (type/of on-stack-type))
            ;; here holds: requested type is reference
                
            (type/void? on-stack-type)
            (-> xb .aconst_null)
                
            :else
            (box-primitive xb consumed-type on-stack-type)))]

  (defn convert-from-primitive ^void [^CodeBuilder xb ^Class consumed-type
                                      ^Class on-stack-type]
    (when-not (identical? consumed-type on-stack-type)
      (convert-from-primitive* xb consumed-type on-stack-type)))

  ;; Emits instructions that adapt the top operand stack entry from
  ;; `on-stack-type` to `consumed-type`.
  (defn adapt-stack ^void [^CodeBuilder xb ^long consumer-fctx
                           ^Class consumed-type ^Class on-stack-type]
    ;; pre: (some? on-stack-type)
    #_(prn :skip-adapt (identical? on-stack-type consumed-type)) ;FIXME... 16%?
    (when-not (identical? on-stack-type consumed-type)
      (cond
        (type/void? consumed-type)
        (util/pop xb on-stack-type)
        ;; here holds: this function leaves an operand on the stack
        
        (.isPrimitive on-stack-type)
        (convert-from-primitive* xb consumed-type on-stack-type)
        
        :else
        (cast-from-reference* xb consumer-fctx consumed-type on-stack-type))))

  (defn statm? ^boolean [^CodeBuilder xb ^CodeEmitter ce]
    (when-some [on-stack-type (.emit-insn* ce xb Void/TYPE false)]
      (when-not (type/void? on-stack-type)
        (util/pop xb on-stack-type))
      true))
  
  (defn insn? ^boolean [^CodeBuilder xb ^long consumer-fctx
                        ^Class consumed-type ^CodeEmitter ce]
    (when-some [on-stack-type (.emit-insn* ce xb consumed-type false)]
      (adapt-stack xb (context/fctx-line consumer-fctx) consumed-type
                   on-stack-type)
      true))
  
  (defn then-leave? ^boolean [^CodeBuilder xb ^long consumer-fctx
                              ^Class consumed-type ^CodeEmitter ce
                              ^boolean then-leave?]
    (when-some [on-stack-type (.emit-insn* ce xb consumed-type then-leave?)]
      (adapt-stack xb (context/fctx-line consumer-fctx) consumed-type
                   on-stack-type)
      (when then-leave? (.return_ xb (TypeKind/from consumed-type)))
      (not then-leave?))))

(defn statms? ^boolean [^CodeBuilder xb ^CodeEmitter/1 ces]
  (loop [i 0]
    (or (>= i (alength ces)) (and (statm? xb (aget ces i)) (recur (inc i))))))

(defn insns?
  (^boolean [^CodeBuilder xb ^long consumer-fctx ^Class consumed-type
             ^CodeEmitter/1 ces]
   (insns? xb consumer-fctx consumed-type ces 0 (alength ces)))
  (^boolean [^CodeBuilder xb ^long consumer-fctx ^Class consumed-type
             ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (or (>= i end)
         (and (insn? xb consumer-fctx consumed-type (aget ces i))
              (recur (inc i)))))))

(defn typed-insns?
  (^boolean [^CodeBuilder xb ^long consumer-fctx ^Class/1 consumed-types
             ^CodeEmitter/1 ces]
   (typed-insns? xb consumer-fctx consumed-types ces
                 0 (alength consumed-types)))
  (^boolean [^CodeBuilder xb ^long consumer-fctx ^Class/1 consumed-types
             ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (or (>= i end)
         (and (insn? xb consumer-fctx (aget consumed-types i) (aget ces i))
              (recur (inc i)))))))

(defn body ^void [^CodeBuilder xb ^MethodSpec spec ^int first-param-no]
  (let [return-type (-> spec .at .return-type)
        params (.parameters spec)
        names (-> spec .at .parameter-names)]
    (dotimes [i (alength params)]
      (-> ^tcljx.classgen.util.LocalVariable (aget params i)
          (.emit-setup-code? xb (+ first-param-no i) (aget names i))))
    (then-leave? xb context/fctx-none return-type (.code spec) true)))
