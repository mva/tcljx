(ns tcljx.parser.let
  (:require
   (tcljx.data [wrong :as wrong] [context :as context] [ir :as ir])
   (tcljx.parser [syntax :as syntax] [parse :as parse] [interop :as interop]))
  (:import
   (tcljx.data.ir Expr Entity Binding FnPromise ExprFactory EntityFactory Parser)))

(letfn [(binding-for-entity ^Binding [^EntityFactory etf ^long fctx
                                      ^String name ^Entity ent ^Object ent-form]
          (condp = (ir/binding-mode-let ent)
            ir/bound-as-alias
            (.binding-entity etf fctx name ent true)
            ir/bound-with-emit-setup
            (let [alias? (not= (ir/closure-level ent) (.closure-level etf))]
              (.binding-entity etf fctx name ent alias?))
            #_else
            (let [x (.value-of etf ent ent-form)]
              (assert (not (instance? FnPromise ent)))
              (.binding-fresh etf fctx nil name x))))
        (binding-for-init ^Binding [^EntityFactory etf ^long fctx
                                    ^Class opt-type ^String name ^Expr init]
          (let [ce (.emitter init)]
            (if (and (nil? opt-type)
                     (not= (ir/binding-mode-let ce) ir/bound-by-copy-to-local))
              (do (when (instance? FnPromise ce)
                    (FnPromise/.count-value-use! ce -1))
                  (binding-for-entity etf fctx name ce nil))
              (.binding-fresh etf fctx opt-type name init))))]

  (defn parse-let* ^Expr [^Parser parser ^long fctx [_ bindings & body :as form]]
    (let [bindings (syntax/vector bindings true)
          n (quot (count bindings) 2)
          xf (.expr-factory parser)
          etf (.entity-factory parser)
          bnds (new Binding/1 n)]
      (loop [parser parser, i 0]
        (if (< i n)
          (let [nm-sym (nth bindings (* i 2))
                nm (syntax/simple-symbol-str nm-sym)
                init (nth bindings (inc (* i 2)))
                opt-type (interop/resolve-tag (.resolver parser) nm-sym nil)
                ent (when (and (symbol? init) (nil? (.meta ^symbol init))
                               (nil? opt-type))
                      (or (parse/lookup parser init)
                          (interop/lookup-class-entity parser init)))
                bnd (if (some? ent)
                      (binding-for-entity etf fctx nm ent init)
                      (let [fctx' (context/of-progn-prefix fctx)]
                        (->> (parse/form parser fctx' init)
                             (binding-for-init etf fctx opt-type nm))))]
            (aset bnds i bnd)
            (recur (ir/with-local-binding parser bnd) (inc i)))
          (.block-bindings xf fctx bnds false false
                           (parse/progn parser fctx body)))))))
