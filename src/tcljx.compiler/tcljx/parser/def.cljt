(ns tcljx.parser.def
  (:require
   (tcljx.data [meta :as meta] [error :as error] [context :as context]
               [ir :as ir] [type :as type])
   (tcljx.parser [syntax :as syntax] [interop :as interop] [parse :as parse]))
  (:import
   (tcljx.data.ir CodeEmitter Expr Entity ImmediateEntity Assignable Parser)))

(defn parse-def ^Expr [^Parser parser ^long fctx [_ nm-sym & [init :as args]]]
  (let [nm (syntax/simple-symbol-str nm-sym)
        nm-meta (meta nm-sym)
        private? (boolean (:private nm-meta))
        macro? (boolean (:macro nm-meta))
        redef? (boolean (:redef nm-meta))
        nm-tag (meta/get-tag nm-meta)
        nm-tp (when (some? nm-tag)
                (interop/parse-type-symbol (.resolver parser) nm-tag))
        nmsp (parse/namespace-builder parser)]
    (syntax/empty-tail (next args))
    
    (letfn [(x-init ^Expr []
              (cond-> (if (some? args)
                        (parse/form parser (context/of-progn-prefix fctx) init)
                        (.empty-expr (.expr-factory parser)))
                (some? nm-tag) (interop/cast-to-type parser fctx nm-tp)))
            (of-immutable-def? ^boolean [^Entity ent] ;pre: `init` is symbol
              (and (ir/immediate-entity? ent)
                   (= (ir/binding-mode-let ent) ir/bound-as-alias)
                   (nil? (.meta ^symbol init))
                   (nil? (meta/get-tag nm-meta))
                   (identical? ent (.lookup-def (.resolver parser)
                                                (namespace init) (name init)))))
            (immutable-def ^Entity [^symbol init]
              (let [ent (or (parse/lookup parser init)
                            (interop/lookup-class-entity parser init))]
                (when (of-immutable-def? ent)
                  ent)))
            (prior-definition ^Entity [^String nm]
              (when-some [ent (.lookup-def (.resolver parser) nil nm)]
                (when (ir/def-from-this-namespace? ent parser)
                  (when-not macro? ;clojure.core has two "defmarco let"...
                    ent))))

            (fully-qualified-symbol? ^boolean [form]
              (when (symbol? form)
                (let [nmsp (namespace form)]
                  (= nmsp (.lookup-namespace (.resolver parser) nmsp)))))
            (ce-macro-value ^CodeEmitter [form]
              (if (fully-qualified-symbol? form)
                (.emitter (parse/form parser (context/of-arg fctx) form))
                (error/throw ":macro-value must be fully qualified symbol"
                              (got-q form))))]
      (if-some [prior-def (prior-definition nm)]
        (or (when (instance? Assignable prior-def)
              (.redef-expr* ^Assignable prior-def fctx (x-init)))
            (error/throw "target of redef must be unbound or :redef"))
        
        (do
          (error/when-not (= (-> parser .entity-factory .closure-level)
                             ir/closure-level-clinit)
            "cannot" (sym 'def) "in this context")
          (cond
            (:var nm-meta)
            (let [x-meta (parse/meta parser fctx nm-meta nil)]
              (error/when macro?
                ":var and :macro are mutually exclusive")
              (error/when redef?
                ":var and :redef are mutually exclusive")
              (.new-def-var nmsp private? nm (x-init) (or nm-tp Object)
                            (boolean (:dynamic nm-meta)) x-meta))
            
            (or redef? (nil? args))
            (do (error/when macro?
                  ":macro and :redef are mutually exclusive")
                (.new-def-mutable nmsp private? nm (x-init)))

            :else
            (if-some [ent (when (symbol? init) (immutable-def init))]
              (let [ns (.lookup-namespace (.resolver parser) (namespace init))]
                (.new-def-alias nmsp private? nm ent (str ns "/" (name init))))
              (if macro?
                (if-some [form-mv (get nm-meta :macro-value)]
                  (.new-def-macro nmsp private? nm (x-init)
                                  (str form-mv) (ce-macro-value form-mv))
                  (.new-def-macro nmsp private? nm (x-init) nil nil))
                (.new-def-immutable nmsp private? nm (x-init))))))))))
