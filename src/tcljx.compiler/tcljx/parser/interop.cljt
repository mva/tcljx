(ns tcljx.parser.interop
  (:require
   (tcljx.data [meta :as meta] [member :as member] [type :as type]
               [resolve :as resolve] [wrong :as wrong] [context :as context]
               [ir :as ir])
   (tcljx.parser [syntax :as syntax]))
  (:import
   (tcljx.data.member MemberHandle)
   (tcljx.data.ir Resolver Expr Entity ExprFactory EntityFactory Parser ArityType)
   (clojure.lang IMeta)
   (java.lang.reflect Method)))

(defn array-rank ^int [^String nm] ;returns 0 if not in [1-9]
  (when (= (.length nm) 1)
    (let [ch (int (.charAt nm 0))]
      (when (<= (int \1) ch (int \9))
        (- ch (int \0))))))

;;; Returns nil if lookup fails.  The three argument arity returns an
;;; array type if class `cl` is provided and `nm` is a digit
;;; matching [1-9].
(defn lookup-type
  (^Class [^Resolver rsv ^symbol tp]
   (let [nm (name tp)]
     (if-some [nmsp (namespace tp)]
       (lookup-type rsv (.lookup-class rsv nmsp) nm)
       (.lookup-class rsv nm))))
  (^Class [^Resolver rsv ^Class cl ^String nm] ;nil if `cl` is nil
   (when (some? cl)
     (let [n (array-rank nm)]
       (when (pos? n)
         (type/array-type-of-class cl n))))))

;;; ------------------------------------------------------------------------

(defn resolve-class
  (^Class [^Resolver rsv ^symbol sym]
   (or (lookup-type rsv sym)
       (throw (wrong/info-class-not-found sym))))
  (^Class [^Resolver rsv ^symbol sym ^Class or-else]
   (if (some? sym) (resolve-class rsv sym) or-else)))
(defn resolve-interface ^Class [^Resolver rsv ^symbol sym]
  (let [tp (resolve-class rsv sym)]
    (if (.isInterface tp)
      tp
      (wrong/other "not an interface class" tp))))

(defn untagged? ^boolean [form]
  (nil? (meta/get-tag (meta form))))
(defn tag-of ^symbol [form]
  (when-some [tag (meta/get-tag (meta form))]
    (syntax/symbol tag)))
(defn resolve-tag
  (^Class [^Resolver rsv ^IMeta form]
   (resolve-tag rsv form Object))
  (^Class [^Resolver rsv ^IMeta form ^Class or-else]
   (resolve-class rsv (tag-of form) or-else)))

(defn get-param-tags ^Object [^map form-meta] ;nil if no param tags are given
  (when (some? form-meta)
    (.valAt form-meta :param-tags nil)))
(defn param-tags-of ^vector [form]
  (when-some [ptags (get-param-tags (meta form))]
    (syntax/vector ptags)))

;;; ------------------------------------------------------------------------

(defn parse-type-symbol ^Class [^Resolver resolver form]
  (let [sym (syntax/symbol form)]
    (or (lookup-type resolver sym)
        (throw (syntax/info "expected type expression" form)))))

(defn cast-to-type ^Expr [^Expr x ^Parser parser ^long fctx ^Class tp]
  (.type-cast (.expr-factory parser) fctx tp x))
(defn cast-to-tag ^Expr [^Expr x ^Parser parser ^long fctx tag]
  (cast-to-type x parser fctx (parse-type-symbol (.resolver parser) tag)))

(defn- class-member-match ^MemberHandle [^boolean static? ^Class owner
                                         ^String mnm ^Class/1 ptags]
  (let [ms (resolve/members-by-param-tags static? owner mnm ptags)
        wr-info (fn ^Throwable []
                  (let [sym (wrong/q-as-symbol owner mnm)]
                    (-> (if (and static? (= resolve/constructor-name mnm))
                          (if (seq ms)
                            (str "multiple constructors matching " sym)
                            (str "no constructor matching " sym))
                          (let [label (if static? "static" "virtual")]
                            (if (seq ms)
                              (str "multiple " label " members matching " sym)
                              (str "no " label " member matching " sym))))
                        (wrong/wr-info))))]
    (let [m ^MemberHandle (first ms)]
      (if (and (some? m) (nil? (next ms)))
        m
        (throw (wr-info))))))

(defn lookup-class-entity
  (^Entity [^Parser parser ^symbol sym]
   (lookup-class-entity (.resolver parser) (.entity-factory parser) sym))
  (^Entity [^Resolver rsv ^EntityFactory etf ^symbol sym]
   (letfn [(parse-param-tags ^Class/1 [^Object ptags]
             (when (some? ptags)
               (let [ptags (syntax/vector ptags)
                     a (new Class/1 (count ptags))]
                 (dotimes [i (alength a)]
                   (let [sym (nth ptags i)]
                     (aset a i (if (= sym '_)
                                 type/polymorphic
                                 (parse-type-symbol rsv sym)))))
                 a)))
           (class-constant ^Entity [^Class tp]
             (.emitter (.expr-constant etf tp Class)))]
     (let [nm (name sym)]
       (if-some [nmsp (namespace sym)]
         (when-some [cl (.lookup-class rsv nmsp)]
           (if-some [tp (lookup-type rsv cl nm)]
             (class-constant tp)        ;array type
             (let [ptags (-> (.meta sym) (get-param-tags) (parse-param-tags))
                   m (if (.startsWith nm ".")
                       (class-member-match false cl (.substring nm 1) ptags)
                       (class-member-match true cl nm ptags))]
               (if (and (nil? ptags) (member/field? m) (member/static? m))
                 (.entity-getstatic etf m)
                 (.entity-class-member etf m)))))
         (when-some [cl (.lookup-class rsv nm)]
           (class-constant cl)))))))

;;; ------------------------------------------------------------------------

(defn unhinted-arity-type? ^boolean [^ArityType at ^int start]
  (and (nil? (.return-type at))
       (let [a (.parameter-types at)]
         (loop [i (dec (alength a))]
           (cond (< i start) true
                 (some? (aget a i)) false
                 :else (recur (dec i)))))))

(defn- parse-parameters ^ArityType [^Class return-type ^Resolver rsv
                                    ^vector paramv ^Class or-else-type]
  (let [n-paramv (count paramv)
        tail? (= '& (nth paramv (- n-paramv 2) nil))
        n-params (- n-paramv (int tail?)) ;drop '& marker
        n-fixed (- n-params (int tail?)) ;butlast if '& marker is present
        ptypes (new Class/1 n-params)
        pnames (new String/1 n-params)]
    (dotimes [i n-fixed]
      (let [param (nth paramv i)
            psym (syntax/parameter-symbol param)]
        (aset ptypes i (resolve-tag rsv psym or-else-type))
        (aset pnames i (name psym))))
    (if tail?
      (let [param (peek paramv)
            psym (syntax/parameter-symbol param)
            tp (resolve-tag rsv psym nil)
            variadic? (nil? tp)]
        (aset ptypes n-fixed
              (cond
                (nil? tp) (when (some? or-else-type) clojure.lang.ISeq)
                (.isArray tp) tp
                :else (wrong/other "type of rest parameter must be array" tp)))
        (aset pnames n-fixed (name psym))
        (ArityType. return-type ptypes pnames (not variadic?) variadic?))
      (ArityType. return-type ptypes pnames false false))))

(letfn [(parse-return ^Class [^Resolver rsv ^vector paramv
                              ^Class or-else-type ^boolean accept-art?]
          (let [return-tag (tag-of paramv)]
            (if (= meta/auto-return-type return-tag)
              (if accept-art?
                type/auto-return-marker
                (throw (syntax/info (str (wrong/q meta/auto-return-type)
                                         " not applicable in this context"))))
              (resolve-class rsv return-tag or-else-type))))]
  
  (defn parse-arity-type ^ArityType [^Resolver rsv paramv ^Class or-else-type
                                     ^boolean unnamed-fn?]
    (let [paramv (syntax/vector paramv)]
      (-> (parse-return rsv paramv or-else-type unnamed-fn?)
          (parse-parameters rsv paramv or-else-type))))

  (defn parse-method-type ^ArityType [^Resolver rsv ^Class owner
                                      ^symbol method-name paramv]
    (let [paramv (syntax/vector paramv)
          at (-> (parse-return rsv paramv nil false)
                 (parse-parameters rsv paramv nil))
          mnm (name method-name)
          n (dec (.parameter-count at))]
      (letfn [(select-method-by-arity ^Method [^ArityType at]
                (if-some [ms (seq (resolve/itf-methods-with-name owner mnm n))]
                  (if (nil? (next ms))
                    (first ms)
                    (-> (str "multiple virtual " n "-parameter methods matching ")
                        (wrong/other method-name)))
                  (-> (str "no virtual " n "-parameter method matching ")
                      (wrong/other method-name))))
              (unhinted-to-Object ^Class [^Class tp]
                (or tp Object))
              (select-matching-method ^Method [^ArityType at]
                (let [rt (.return-type at) ;inferred if unhinted
                      pts (new Class/1 n)]
                  (dotimes [i (alength pts)]
                    (aset pts i (-> (aget (.parameter-types at) (inc i))
                                    (unhinted-to-Object))))
                  (if-some [m (resolve/itf-method-exact owner mnm rt pts)]
                    m
                    (wrong/other "no virtual method matching " method-name))))]
        
        (when-not (untagged? (first paramv))
          (throw (syntax/info "no type tag allowed for receiver parameter")))
        (aset (.parameter-types at) 0 owner) ;type of receiver
        (let [m (if (unhinted-arity-type? at 1)
                  (select-method-by-arity at)
                  (select-matching-method at))]
          (when (not= (ir/translates-to-varargs? at) (.isVarArgs m))
            (wrong/other "varargs mismatch for method " method-name))
          (ir/with-method-type at m))))))
