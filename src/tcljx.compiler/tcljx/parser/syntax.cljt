(ns tcljx.parser.syntax
  (:require (tcljx.data [config :as cfg] [wrong :as wrong])
            [clojure.core :as cc])
  (:refer-clojure :exclude [vector list map symbol first second]))

(defn info
  (^Throwable [^String msg]
   (wrong/wr-info msg))
  (^Throwable [^String msg-prefix form]
   (wrong/wr-info-line-number (str msg-prefix (wrong/got-q form)) form)))

;;; ------------------------------------------------------------------------

(defn simple-symbol? ^boolean [form]
  (and (symbol? form) (nil? (namespace form))))

(defn symbol ^symbol [form]
  (if (symbol? form)
    form
    (throw (info "expect symbol" form))))
(defn simple-symbol ^symbol [form]
  (if (simple-symbol? form)
    form
    (throw (info "expect unqualified symbol" form))))
(defn parameter-symbol ^symbol [form]
  (if (= form '&)
    (throw (info "invalid parameter name" form))
    (simple-symbol form)))

(defn simple-symbol-str ^String [form]
  (name (simple-symbol form)))

(defn vector
  (^vector [form]
   (if (vector? form)
     form
     (throw (info "expect vector" form))))
  (^vector [form ^boolean even?]
   (let [x (vector form)]
     (if (and even? (odd? (count x)))
       (throw (info "expect vector with even number of elements" form))
       x))))

(defn list ^seq [form]
  (if (seq? form)
    form
    (throw (info "expect list" form))))

(defn map ^map [form]
  (if (map? form)
    form
    (throw (info "expect map" form))))

;;; ------------------------------------------------------------------------

(defn strip-quote [x]
  (if (and (seq? x) (= cfg/sym-quote (cc/first x)) (nil? (nnext x)))
    (cc/second x)
    x))

(defn next-if-string ^seq [^seq xs]
  (cond-> xs (string? (cc/first xs)) (next)))

(defn empty-tail
  (^void [^seq forms]
   (empty-tail 0 forms))
  (^void [^int n ^seq forms]
   (when (some? (nthnext forms n))
     (throw (info "unexpected arguments at end" (nthnext forms n))))))

(defn first [^seq forms]
  (if (some? (seq forms))
    (cc/first forms)
    (throw (info "missing argument"))))

(defn second [^seq forms]
  (if-some [xs (next forms)]
    (cc/first xs)
    (throw (info "missing argument"))))

(defn varargs-parameter ^symbol [[_ & forms]]
  (if (some? forms)
    (simple-symbol (cc/first forms))
    (throw (info "missing varargs parameter"))))

;;; ------------------------------------------------------------------------

(defn prefixed-nmsp-str ^String [form ^String prefix]
  (str prefix (simple-symbol-str form)))
        
(defn flatten-imports ^seq [^seq rimports ^String prefix ^seq specs
                            ^seq error-context]
  (letfn [(flatten-import ^seq [^seq rimports spec]
            (cond
              (symbol? spec)
              (cons (prefixed-nmsp-str spec prefix) rimports)
                      
              (seq? spec)
              (let [prefix (prefixed-nmsp-str (cc/first spec) prefix)]
                (flatten-imports rimports (str prefix ".")
                                 (rest spec) spec))
                      
              :else
              (throw (info "expect symbol or list" spec))))]
    (reduce flatten-import rimports specs)))

