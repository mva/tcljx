(ns tcljx.parser.syntax
  (:require (tcljx.data [config :as cfg] [error :as error])
            [clojure.core :as cc])
  (:refer-clojure :exclude [vector list map symbol first second]))

(defn simple-symbol? ^boolean [form]
  (and (symbol? form) (nil? (namespace form))))

(defn symbol ^symbol [form]
  (error/when-not (symbol? form)
    "expect symbol" (got-q form))
  form)
(defn simple-symbol ^symbol [form]
  (error/when-not (simple-symbol? form)
    "expect unqualified symbol" (got-q form))
  form)
(defn parameter-symbol ^symbol [form]
  (if (= form '&)
    (error/throw "invalid parameter name" (got-q form))
    (simple-symbol form)))

(defn simple-symbol-str ^String [form]
  (name (simple-symbol form)))

(defn vector
  (^vector [form]
   (error/when-not (vector? form)
     "expect vector" (got-q form))
   form)
  (^vector [form ^boolean even?]
   (let [x (vector form)]
     (if (and even? (odd? (count x)))
       (error/throw "expect vector with even number of elements, got"
                     (txt (count form)))
       x))))

(defn list ^seq [form]
  (error/when-not (seq? form)
    "expect list" (got-q form))
  form)

(defn map ^map [form]
  (error/when-not (map? form)
    "expect map" (got-q form))
  form)

;;; ------------------------------------------------------------------------

(defn strip-quote [x]
  (if (and (seq? x) (= cfg/sym-quote (cc/first x)) (nil? (nnext x)))
    (cc/second x)
    x))

(defn next-if-string ^seq [^seq xs]
  (cond-> xs (string? (cc/first xs)) (next)))

(defn empty-tail
  (^void [^seq forms]
   (empty-tail 0 forms))
  (^void [^int n ^seq forms]
   (error/when-not (nil? (nthnext forms n))
     "unexpected arguments at end" (got-q (nthnext forms n)))))

(defn first [^seq forms]
  (if-some [xs (seq forms)]
    (cc/first xs)
    (error/throw "missing argument")))

(defn second [^seq forms]
  (if-some [xs (next forms)]
    (cc/first xs)
    (error/throw "missing argument")))

;;; ------------------------------------------------------------------------

(defn prefixed-nmsp-str ^String [form ^String prefix]
  (str prefix (simple-symbol-str form)))
        
(defn flatten-imports ^seq [^seq rimports ^String prefix ^seq specs
                            ^seq error-context]
  (letfn [(flatten-import ^seq [^seq rimports spec]
            (cond
              (symbol? spec)
              (cons (prefixed-nmsp-str spec prefix) rimports)
                      
              (seq? spec)
              (let [prefix (prefixed-nmsp-str (cc/first spec) prefix)]
                (flatten-imports rimports (str prefix ".")
                                 (rest spec) spec))
                      
              :else
              (error/throw "expect symbol or list" (got-q spec)
                            (set-list-context error-context))))]
    (reduce flatten-import rimports specs)))

