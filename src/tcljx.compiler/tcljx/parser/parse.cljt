(ns tcljx.parser.parse
  (:require (tcljx.data [config :as cfg] [wrong :as wrong] [ir :as ir]
                        [context :as context]))
  (:import (tcljx.data.ir Resolver NamespaceBuilder Entity Binding
                          Expr Exprs ExprFactory Parser AritySpec MethodSpec)
           (tcljx.data.wrong WrongInfo)))

(defn new-exprs ^Exprs [^Parser parser ^int n]
  (.new-exprs (.expr-factory parser) n))

;; Takes a single form `form` and translates it to Expr using the
;; given form context `fctx`.  This is the workhorse of the parser.
;; Other methods delegate to it with adjusted `fctx` flags.
(def form Parser/.parse-form)

;; Takes a single form and parses it as an argument of the given
;; parent context `parent-fctx`: the form pushes a value to the
;; operand stack that is subsequently consumed by an instruction
;; emitted by the parent form.  Delegates to `form` with
;; `flag-can-recur` and `flag-statm-position` cleared from the
;; parent context `parent-fctx`.
(defn arg ^Expr [^Parser parser ^long parent-fctx form]
  (tcljx.parser.parse/form parser (context/of-arg parent-fctx) form))

;; Takes a seq of forms, each of which is parsed as if by `arg`.
(defn args* ^Exprs [^Parser parser ^long fctx' ^seq forms]
  (let [xs (new-exprs parser (count forms))]
    (loop [i 0, forms (seq forms)]
      (when (some? forms)
        (.set xs i (form parser fctx' (first forms)))
        (recur (inc i) (next forms))))
    xs))
(defn args ^Exprs [^Parser parser ^long parent-fctx ^seq forms]
  (args* parser (context/of-arg parent-fctx) forms))

(defn meta ^Expr [^Parser parser ^long parent-fctx ^map m ^Expr or-else]
  (letfn [(quote-value-of ^map [^map m ^keyword k]
            (if-some [e (find m k)]
              (assoc m k (list cfg/sym-quote (val e)))
              m))]
    (if (some? m)
      ;; Problem: Cannot evaluate the `foo` in a meta map like {:tag
      ;; foo}.  E.g. `int` would refer to a primitive function and
      ;; does not have a value.  Solution: Quote the values of :tag
      ;; and :param-tags map entries to retain any symbol values.
      (->> (-> m (quote-value-of :tag) (quote-value-of :param-tags))
           (arg parser parent-fctx))
      or-else)))

;; Takes a seq of forms, where only the last form pushes a value to
;; the operand stack.  Delegates to `form`, clearing
;; `flag-can-recur` for the butlast elements of `forms`.  The last
;; element is parsed using the unmodified `parent-fctx`.
(defn progn
  (^Expr [^Parser parser ^long parent-fctx ^seq forms]
   (let [n (count forms)]
     (if (zero? n)
       (.empty-expr (.expr-factory parser)) ;translation of form (do)
       (let [fctx' (context/of-progn-prefix parent-fctx)
             xs (new-exprs parser (dec n))]
         (loop [i 0, forms forms]
           (if (< i (.length xs))
             (do (.set xs i (form parser fctx' (first forms)))
                 (recur (inc i) (rest forms)))
             (let [x (form parser parent-fctx (first forms))]
               (.progn-expr (.expr-factory parser) xs x))))))))
  (^Expr [^Parser parser ^seq error-context ^long fctx ^seq forms]
   (context/with-line-from-list [fctx error-context]
     (progn parser fctx (seq forms)))))

;;; ------------------------------------------------------------------------

;;; Returns nil if `form` does not resolve to a binding.
(defn lookup ^Entity [^Parser parser ^symbol form]
  (let [nm (name form)]
    (if-some [nmsp (namespace form)]
      ;; a qualified name always refers to a namespace-level def
      (.lookup-def (.resolver parser) nmsp nm)
      
      ;; for a simple name, the assumption is that a lookup in
      ;; `bindings*` is accurate with very high probability
      (or (.valAt (.bindings* parser) nm nil)
          (.lookup-def (.resolver parser) nil nm))))) ;to cover all defs

;;; Returns nil if `alias` does not resolve to a namespace name.
(defn lookup-namespace ^String [^Parser parser ^String alias]
  (.lookup-namespace (.resolver parser) alias))

;;; Returns nil if `nm` does not resolve to a class name.
(defn lookup-class ^Class [^Parser parser ^String nm]
  (.lookup-class (.resolver parser) nm))

(defn namespace-builder ^NamespaceBuilder [^Parser parser]
  (let [rsv (.resolver parser)]
    (if (instance? NamespaceBuilder rsv)
      rsv
      (throw (wrong/wr-info "cannot manipulate namespace data in this position")))))

;;; ------------------------------------------------------------------------

(defn binding-variables ^Entity/1 [^Binding/1 bnds]
  (let [a (new Entity/1 (alength bnds))]
    (dotimes [i (alength a)]
      (aset a i (.bound-to (aget bnds i))))
    a))

(defn method-spec-template ^MethodSpec [^AritySpec aspec ^int source-idx
                                        ^String name]
  (MethodSpec. (.at aspec) nil nil nil source-idx name))

(defn body-into ^MethodSpec [^MethodSpec mspec ^boolean inst-method?
                             ^Parser parser ^AritySpec aspec]
  (let [pbnds (ir/parameter-bindings parser (.at aspec))
        pvars (binding-variables pbnds)
        rvars (cond-> pvars
                inst-method?
                ^Entity/1 (java.util.Arrays/copyOfRange 1 (alength pvars)))
        xf' (.with-recur-variables (.expr-factory parser) rvars)
        fctx' (context/with-recur context/fctx-initial)]
    (context/with-line-from-list [fctx' (.error-context aspec)]
      (let [x-body (-> (ir/with-local-bindings parser pbnds)
                       (.with-expr-factory xf')
                       (progn fctx' (.body aspec)))]
        (.complete-method xf' mspec pvars fctx' x-body)))))
