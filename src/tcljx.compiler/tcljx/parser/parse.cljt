(ns tcljx.parser.parse
  (:require (tcljx.data [config :as cfg] [wrong :as wrong] [ir :as ir]
                        [context :as context]))
  (:import (tcljx.data.ir Resolver NamespaceBuilder Entity Binding
                          Expr Exprs ExprFactory Parser AritySpec MethodSpec)
           (tcljx.data.wrong WrongInfo)))

(defn new-exprs ^Exprs [^Parser parser ^int n]
  (.new-exprs (.expr-factory parser) n))

;; Takes a single form `form` and translates it to Expr using the
;; given form context `fctx`.  This is the workhorse of the parser.
;; Other methods delegate to it with adjusted `fctx` flags.
(def form Parser/.parse-form)

;; Takes a single form and parses it as an argument of the given
;; parent context `parent-fctx`: the form pushes a value to the
;; operand stack that is subsequently consumed by an instruction
;; emitted by the parent form.  Delegates to `form` with
;; `flag-can-recur` and `flag-statm-position` cleared from the
;; parent context `parent-fctx`.
(defn arg ^Expr [^Parser parser ^long parent-fctx form]
  (tcljx.parser.parse/form parser (context/of-arg parent-fctx) form))

;; Takes a seq of forms, each of which is parsed as if by `arg`.
(defn args ^Exprs [^Parser parser ^long parent-fctx ^seq forms]
  (let [fctx' (context/of-arg parent-fctx)
        xs (new-exprs parser (count forms))]
    (loop [i 0, forms (seq forms)]
      (when (some? forms)
        (.set xs i (form parser fctx' (first forms)))
        (recur (inc i) (next forms))))
    xs))

(defn meta ^Expr [^Parser parser ^long parent-fctx ^map m ^Expr or-else]
  (letfn [(quote-value-of ^map [^map m ^keyword k]
            (if-some [e (find m k)]
              (assoc m k (list cfg/sym-quote (val e)))
              m))]
    (if (some? m)
      ;; Problem: Cannot evaluate the `foo` in a meta map like {:tag
      ;; foo}.  E.g. `int` would refer to a primitive function and
      ;; does not have a value.  Solution: Quote the values of :tag
      ;; and :param-tags map entries to retain any symbol values.
      (->> (-> m (quote-value-of :tag) (quote-value-of :param-tags))
           (arg parser parent-fctx))
      or-else)))

;; Takes a seq of forms, where only the last form pushes a value to
;; the operand stack.  Delegates to `form`, clearing
;; `flag-can-recur` for the butlast elements of `forms`.  The last
;; element is parsed using the unmodified `parent-fctx`.
(defn progn
  (^Expr [^Parser parser ^long parent-fctx ^seq forms]
   (let [n (count forms)]
     (if (zero? n)
       (.empty-expr (.expr-factory parser)) ;translation of form (do)
       (let [fctx' (context/of-progn-prefix parent-fctx)
             xs (new-exprs parser (dec n))]
         (loop [i 0, forms forms]
           (if (< i (.length xs))
             (do (.set xs i (form parser fctx' (first forms)))
                 (recur (inc i) (rest forms)))
             (let [x (form parser parent-fctx (first forms))]
               (.progn-expr (.expr-factory parser) xs x))))))))
  (^Expr [^Parser parser ^seq error-context ^long fctx ^seq forms]
   (context/with-line-from-list [fctx error-context]
     (progn parser fctx (seq forms)))))

;;; ------------------------------------------------------------------------

;;; Returns nil if `form` does not resolve to a binding.
(defn lookup ^Entity [^Parser parser ^symbol form]
  (let [nm (name form)]
    (if-some [nmsp (namespace form)]
      ;; a qualified name always refers to a namespace-level def
      (.lookup-def (.resolver parser) nmsp nm)
      
      ;; for a simple name, the assumption is that a lookup in
      ;; `bindings*` is accurate with very high probability
      (or (.valAt (.bindings* parser) nm nil)
          (.lookup-def (.resolver parser) nil nm))))) ;to cover all defs

;;; Returns nil if `alias` does not resolve to a namespace name.
(defn lookup-namespace ^String [^Parser parser ^String alias]
  (.lookup-namespace (.resolver parser) alias))

;;; Returns nil if `nm` does not resolve to a class name.
(defn lookup-class ^Class [^Parser parser ^String nm]
  (.lookup-class (.resolver parser) nm))

(defn namespace-builder ^NamespaceBuilder [^Parser parser]
  (let [rsv (.resolver parser)]
    (if (instance? NamespaceBuilder rsv)
      rsv
      (throw (wrong/wr-info "cannot manipulate namespace data in this position")))))

;;; ------------------------------------------------------------------------

(defn binding-variables ^Entity/1 [^Binding/1 bnds]
  (let [a (new Entity/1 (alength bnds))]
    (dotimes [i (alength a)]
      (aset a i (.bound-to (aget bnds i))))
    a))

(defn method-spec-template ^MethodSpec [^AritySpec aspec ^int source-idx
                                        ^String name]
  (MethodSpec. (.at aspec) nil nil nil source-idx name))

(defn body-into ^MethodSpec [^MethodSpec mspec ^boolean inst-method?
                             ^Parser parser ^AritySpec aspec]
  (let [pbnds (ir/parameter-bindings parser (.at aspec))
        pvars (binding-variables pbnds)
        rvars (cond-> pvars
                inst-method?
                ^Entity/1 (java.util.Arrays/copyOfRange 1 (alength pvars)))
        xf' (.with-recur-variables (.expr-factory parser) rvars)
        fctx' (context/with-recur context/fctx-initial)]
    (context/with-line-from-list [fctx' (.error-context aspec)]
      (let [x-body (-> (ir/with-local-bindings parser pbnds)
                       (.with-expr-factory xf')
                       (progn fctx' (.body aspec)))]
        (.complete-method xf' mspec pvars fctx' x-body)))))

;;; ------------------------------------------------------------------------

(letfn [(wrong-arity [^Throwable cause form]
          (throw (wrong/wr-info (str "wrong number of args (" (dec (count form))
                                     ") passed to macro") {} cause)))
        (wrong-expand [^Throwable cause form]
          (if-some [ex (wrong/first-wrong-info cause)]
            (throw ex)                  ;discard any parent exceptions
            (throw (wrong/wr-info (str "error while expanding macro "
                                       (wrong/q (first form)))
                                  {} cause))))

        ;; True if `x`'s class has the same name as `cl`.  Use this
        ;; if `x` may come from a different classloader, where class
        ;; identity checks or `instance?` may fail.  `x` may be nil.
        (classname? ^boolean [^Class cl ^Object x]
          (= (.getName cl) (some-> x (.getClass) (.getName))))]

  ;; Application and compiler share their runtime classes.  In this
  ;; case, the macro function's `applyTo` can be invoked directly.
  (defn apply-macro-direct [f form env]
    (try
      (let [form ^clojure.lang.ISeq form]
        ;; mirrors steps in tinyclj.lang.RT/applyMacroMapped:
        (->> (.more form)
             (clojure.lang.Cons. env)
             (clojure.lang.Cons. form)
             (.applyTo ^tinyclj.lang.AFnMh f)))
      (catch clojure.lang.ArityException e
        (wrong-arity e form))
      (catch Throwable t
        (wrong-expand t form))))
  
  ;; Distinct runtime classes: go the long way via the handle for
  ;; `rt/mhd-applyMacroMapped`.
  #_(defn apply-macro-mapped [^MethodHandle apply-mh f form env]
      (try
        ;; Mapped macro invocation: translate the data
        ;; representation along the chain of Compiler -> JVM ->
        ;; Application/macro-expand -> JVM -> Compiler.
        (.invoke apply-mh cpl-to-itf array-to-cpl f form env)
        (catch Throwable t
          (if (classname? clojure.lang.ArityException t)
            (wrong-arity t form)
            (wrong-expand t form)))))

  (defn expand-macro [^Resolver rsv ^Entity macro ^seq form]
    ;; FIXME... does not work in bootstrap scenario (see
    ;; apply-macro-mapped vs apply-macro-direct)
    (apply-macro-direct (.runtime-value macro rsv) form nil)))
