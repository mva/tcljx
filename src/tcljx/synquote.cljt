;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.synquote
  (:require [tcljx.config :as cfg]
            [tcljx.wrong :as wrong])
  (:import (tcljx.config NamespaceContext)
           (clojure.lang IMapEntry IRecord Named)))

(def sym-unquote (symbol cfg/core-lib "unquote"))
(def sym-unquote-splicing (symbol cfg/core-lib "unquote-splicing"))

(defn unquote? ^boolean [form]
  (and (seq? form) (= sym-unquote (first form))))
(defn unquote-splicing? ^boolean [form]
  (and (seq? form) (= sym-unquote-splicing (first form))))

(defn mk-gensym-map []
  (atom {}))

(defn gensym-symbol? [^String nmsp ^String nm]
  (and (nil? nmsp) (.endsWith nm "#")))

;;; Assume the compiler's `clojure.lang.RT/nextID` can be used here,
;;; instead of the application's one.  Most of the time the two are
;;; identical -- unless the `:platform` class loader is used, aka the
;;; bootstrap scenario.  If they are distinct, the generated name
;;; cannot conflict with an application `gensym`, because the latter
;;; currently does not support a `suffix-string` like the "__auto__"
;;; above.  Note: There is the option to use per-input atomic counters
;;; starting at a defined value, but this would still leave macro use
;;; of `gensym` non-deterministic.
(defn gensym-replacement [agensym-map ^String nm]
  (or (get @agensym-map nm)
      (let [nm-auto (str (.substring nm 0 (dec (.length nm)))
                         "__" (clojure.lang.RT/nextID) "__auto__")
            sym (symbol nil nm-auto)]
        (swap! agensym-map assoc nm sym)
        sym)))

(defn rewrite-synquote-name ^Named [^Named nm ^NamespaceContext ctx]
  (letfn [(resolve-class-name ^String [^String nm]
            (if-some [tp (.lookup-class ctx (symbol nil nm))]
              (.getName tp)
              (when-not (neg? (.indexOf nm (int \.)))
                nm)))
          (trim-last ^String [^String nm]
            (.substring nm 0 (dec (.length nm))))

          (rewrite-qualified-name ^symbol [^symbol sym]
            (let [nm (name sym)
                  ns-part (namespace sym)]
              (if-some [ns-part' (and ns-part
                                      (or (.lookup-namespace ctx ns-part)
                                          (resolve-class-name ns-part)))]
                (symbol ns-part' nm)
                sym)))
          (rewrite-name-without-nmsp ^symbol [^symbol sym]
            (let [nm (name sym)]
              (cond
                (.startsWith nm ".")    ;method name and ..
                sym
                
                (.endsWith nm ".")      ;shorthand for (new ...)
                (if-some [nm' (resolve-class-name (trim-last nm))]
                  (symbol nil (str nm' "."))
                  sym)
                
                :else
                (or (.lookup-global-qname ctx nm)
                    (if-some [nm' (resolve-class-name nm)]
                      (symbol nil nm')
                      (symbol (.ns-str ctx) nm))))))]
    
    (cond
      (keyword? nm) nm
      (some? (namespace nm)) (rewrite-qualified-name nm)
      (contains? cfg/specials nm) nm
      :else (rewrite-name-without-nmsp nm))))

;;; ------------------------------------------------------------------------

;; Baseline is the method syntaxQuote() from Clojure's
;; LispReader.java.

(defn template [form]
  (letfn
      [(wrong [^String msg]
         (throw (wrong/wr-info msg {}))) ;no line/column info available here
       (q [form]
         (list cfg/sym-quote form))
            
       (expand-list ^vector [xs]
         (reduce (fn ^vector [^vector ret item]
                   (.cons ret (cond
                                (unquote? item) (list `list (second item))
                                (unquote-splicing? item) (second item)
                                :else (list `list (template item)))))
                 [] xs))
       (flatten-map ^vector [m]
         (reduce (fn ^vector [^vector keyvals ^IMapEntry e]
                   (-> keyvals (.cons (.key e)) (.cons (.val e))))
                 [] (seq m)))

       (quoted? ^boolean [x]        ;quoted form or autoquoted literal
         ;; Assumption: values with non-constant meta are represented
         ;; by a (with-meta ...) form in `x` and return false.
         (if (seq? x)
           (and (= cfg/sym-quote (first x)) (nil? (meta x)))
           (not (symbol? x))))
       (unwrap-quote [x]                ;pre: `(quoted? x)` is true
         (if (seq? x) (second x) x))
       (quoted-in-list? ^boolean [x]
         (and (seq? x) (= `list (first x)) (nil? (nnext x)) ;list of one?
              (quoted? (second x))))
       (unwrap-list [x]            ;pre: `(quoted-in-list? x)` is true
         (unwrap-quote (second x)))
       (list-of? ^boolean [l]
         (and (seq? l) (= (first l) `list)))
       (concat-of [ls]
         (if (every? list-of? ls)
           (list* `list (mapcat rest ls))
           (cons `concat ls)))
       (assemble [apply-sym apply-fn xs]
         (let [ls (expand-list xs)]
           (if (every? quoted-in-list? ls)
             (q (cond->> (map unwrap-list ls)
                  (some? apply-fn) (apply apply-fn)))
             (cond->> (list `seq (concat-of ls))
               (some? apply-sym) (list `apply apply-sym)))))
       
       (encode-collection [form]
         (cond
           (instance? IRecord form) form
           (map? form) (assemble `hash-map hash-map (flatten-map form))
           (vector? form) (assemble `vector vector form)
           (set? form) (assemble `hash-set hash-set form)
           (or (seq? form) (list? form)) (if-some [seq (seq form)]
                                           (assemble nil nil seq)
                                           ())
           :else (throw (UnsupportedOperationException.
                         "unknown collection type"))))]

      (let [tmpl (cond
                   (symbol? form) ;also covers members of `cfg/specials`
                   (q form)
                   
                   (unquote? form)
                   (second form)

                   (unquote-splicing? form)
                   (wrong "unquote-splicing ~@ outside of list")

                   (coll? form)
                   (encode-collection form)

                   ;; all other forms produced by the reader are
                   ;; auto-quoting
                   :else form)]
        (if-some [m (cfg/source-meta form)]
          (let [m-tmpl (template m)]
            (if (and (quoted? tmpl) (quoted? m-tmpl))
              (q (with-meta (unwrap-quote tmpl) (unwrap-quote m-tmpl)))
              (list `with-meta tmpl m-tmpl)))
          tmpl))))
