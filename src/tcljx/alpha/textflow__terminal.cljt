(ns tcljx.alpha.textflow__terminal
  (:require [tcljx.alpha.textflow__termios :as termios])
  (:import (java.io OutputStream InputStream)
           (java.lang AutoCloseable)
           (java.lang.foreign Linker Arena SymbolLookup MemorySegment
                              FunctionDescriptor ValueLayout MemoryLayout)
           (java.lang.invoke MethodHandle)))

;;; see "man 3 termios"
;;; see "man 1 stty"
;;; see https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html
;;; see https://viewsourcecode.org/snaptoken/kilo/03.rawInputAndOutput.html

;;; Enabling the terminal's raw mode requires native access.  One
;;; possible way to avoid any native calls is to bracket the program
;;; by running "stty raw" before it starts and "stty sane" once it
;;; completes.  Or maybe even save the terminal state upfront, then
;;; do "stty raw", and restore the saved state after completion.  This
;;; could be done by the program itself via ProcessBuilder, but
;;; putting the stty calls into a shell script is probably a more sane
;;; approach.

#_
(letfn [(clear-flags! ^int/1 [^int/1 termios ^int offset ^int clear-flags]
          (when-not (zero? (rem offset 4))
            (throw (IllegalArgumentException.)))
          (let [idx (quot offset 4)]
            (aset termios idx (bit-and-not (aget termios idx) clear-flags))
            termios))
        (set-flags! ^int/1 [^int/1 termios ^int offset ^int set-flags]
          (when-not (zero? (rem offset 4))
            (throw (IllegalArgumentException.)))
          (let [idx (quot offset 4)]
            (aset termios idx (bit-or (aget termios idx) set-flags))
            termios))]
  (defn make-raw! ^int/1 [^int/1 termios]
    ;; Also see "Raw mode" section of "man termios".  It describes
    ;; cfmakeraw(), which clears a few more flags.  This also seems to
    ;; mirror the "raw" option of the stty(1) command.
    (-> termios
        ;; BRKINT -- Send SIGINT on break condition?
        ;; ICRNL -- Translate carriage return to newline on input.
        ;; INPCK -- Enable input parity checking.
        ;; ISTRIP -- Strip off eighth bit.
        ;; IXON -- Enable XON/XOFF flow control on output.
        (clear-flags! termios/offsetof-c_iflag (bit-or termios/BRKINT
                                                       termios/ICRNL
                                                       termios/INPCK
                                                       termios/ISTRIP
                                                       termios/IXON))
        ;; OPOST -- Enable implementation-defined output processing.
        ;; Note: Disabling this requires "\r\n" to start a new line.
        (clear-flags! termios/offsetof-c_oflag termios/OPOST)
        ;; CS8 -- Sets the character size (CS) to 8 bits per byte.
        (set-flags! termios/offsetof-c_cflag termios/CS8)
        ;; ECHO -- Echo input characters.
        ;; ICANON -- Input is made available line by line.
        ;; IEXTEN -- Enable  implementation-defined  input processing.
        ;; ISIG -- Generate signal for INTR, QUIT, SUSP, or DSUSP.
        (clear-flags! termios/offsetof-c_lflag (bit-or termios/ECHO
                                                       termios/ICANON
                                                       termios/IEXTEN
                                                       termios/ISIG)))))

(letfn [(downcall-handle ^MethodHandle [^String nm ^MemoryLayout resLayout
                                        & ^MemoryLayout/1 argLayouts]
          (let [linker (Linker/nativeLinker)
                lookup (.defaultLookup linker)
                adr (.findOrThrow lookup nm)
                sig (if (some? resLayout)
                      (FunctionDescriptor/of resLayout argLayouts)
                      (FunctionDescriptor/ofVoid argLayouts))]
            ;; Throws java.lang.IllegalCallerException if the JVM
            ;; instance denies native access, e.g. when running JDK 24
            ;; with --illegal-native-access=deny.  By default, JDK 24
            ;; prints a warning unless the JVM instance is started
            ;; with --enable-native-access=ALL-UNNAMED.
            (.downcallHandle linker adr sig)))
        (get-termios ^int/1 []
          (with-open [arena (Arena/ofConfined)]
            (let [mem (.allocate arena termios/sizeof-struct termios/alignof-struct)
                  res (-> (downcall-handle "tcgetattr" ValueLayout/JAVA_INT
                                           ValueLayout/JAVA_INT ValueLayout/ADDRESS)
                          ^int (.invokeExact termios/STDIN_FILENO mem))]
              (when-not (zero? res)
                (throw (IllegalStateException. "tcgetattr failed")))
              (.toArray mem ValueLayout/JAVA_INT))))
        (copy-termios ^MemorySegment [^Arena arena ^int/1 termios]
          (let [src (MemorySegment/ofArray termios)
                mem (.allocate arena termios/sizeof-struct termios/alignof-struct)]
            (MemorySegment/copy src 0 mem 0 termios/sizeof-struct)
            mem))
        (set-termios ^void [^int/1 termios ^boolean cfmakeraw?]
          ;; From the man page: "Note that tcsetattr() returns success
          ;; if any of the requested changes could be successfully
          ;; carried out.  Therefore, when making multiple changes it
          ;; may be necessary to follow this call with a further call
          ;; to tcgetattr() to check that all changes have been
          ;; performed successfully."
          (with-open [arena (Arena/ofConfined)]
            (let [mem (copy-termios arena termios)]
              (when cfmakeraw?   ;note: cfmakeraw is BSD but not POSIX
                (-> (downcall-handle "cfmakeraw" nil ValueLayout/ADDRESS)
                    ^void (.invokeExact mem)))
              (let [res (-> (downcall-handle "tcsetattr" ValueLayout/JAVA_INT
                                             ValueLayout/JAVA_INT ValueLayout/JAVA_INT ValueLayout/ADDRESS)
                            ^int (.invokeExact termios/STDIN_FILENO termios/TCSAFLUSH mem))]
                (when-not (zero? res)
                  (throw (IllegalStateException. "tcsetattr failed")))))))]

  ;; `close` returns terminal to the state reported at the time of the
  ;; initial call and prints a `newline`.  Use with `with-open`.
  (defn raw-mode ^AutoCloseable []
    (let [initial-termios (get-termios)]
      (set-termios initial-termios true)
      (reify AutoCloseable
        (close [_]
          (set-termios initial-termios false)
          (newline))))))

(letfn [(read-to-R ^String [^InputStream in] ;text after \[ and before \R
          (let [sb (StringBuilder.)]
            (loop []
              (let [in (.read in)]
                (if (or (= in -1) (= in (int \R)) (= in 3)) ;also exit on Ctrl-C
                  (.toString sb)
                  (do (when-not (or (= in 27) (= in 91)) ;skip ESC and \[
                        (.append sb (char in)))
                      (recur)))))))]

  ;; When in raw mode: Move cursor to bottom right corner, request a
  ;; device status report, and parse the cursor position from STDIN.
  ;; Returns nil on error, and an array [rows, columns] otherwise.
  (defn screen-size-via-device-status-report
    (^int/1 []
     (screen-size-via-device-status-report System/out System/in))
    (^int/1 [^OutputStream out ^InputStream in]
     ;; https://en.wikipedia.org/wiki/ANSI_escape_code#Control_Sequence_Introducer_commands
     (.write out (-> (str "\u001b[?25l"  ;hide-cursor
                          "\u001b[s"     ;save-cursor-position
                          "\u001b[999C"  ;cursor-forward
                          "\u001b[999B"  ;cursor-down
                          "\u001b[6n"    ;device-status-report
                          "\u001b[u"     ;restore-cursor-position
                          "\u001b[?25h") ;show-cursor
                     (.getBytes java.nio.charset.StandardCharsets/UTF_8)))
     (.flush out)
     (let [report (read-to-R in)
           i (.indexOf report (int \;))]
       (when (and (>= i 0) (= (.lastIndexOf report (int \;)) i))
         (try                   ;there is exactly one semicolon at `i`
           (doto (new int/1 2)
             (aset 0 (Integer/parseInt report 0 i 10))
             (aset 1 (Integer/parseInt report (inc i) (.length report) 10)))
           (catch NumberFormatException _
             nil)))))))

(defn run []
  (with-open [rm (raw-mode)]
    (prn :screen-size (seq (screen-size-via-device-status-report)))
    (prn :raw-mode-line-1)
    (prn :raw-mode-line-2))
  (prn :done-line-1)
  (prn :done-line-2))

(defn -main [& args]
  (run))
