;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.alpha.textflow
  (:require [tcljx.alpha.textflow__insn :as insn]
            [tcljx.alpha.textflow__ansi :as ansi])
  (:import (java.util Arrays)))

;;; Basic support for styled left-to-right and top-to-bottom text.
;;; Imposes sufficient structure to record a stream of commands, to
;;; combine two or more streams into a multi-column layout, and to
;;; play back a stream to some device.  Primary target is a terminal
;;; supporting ANSI escape sequences.

;;; The style state is encoded as a long.  24 bits for foreground
;;; color, 24 bits for background color, and 16 bits holding the rest
;;; of the state information.

;;; https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit
(def palette-black 0)
(def palette-red 1)
(def palette-green 2)
(def palette-yellow 3)
(def palette-blue 4)
(def palette-magenta 5)
(def palette-cyan 6)
(def palette-white 7)
(def palette-bright-black 8)
(def palette-bright-red 9)
(def palette-bright-green 10)
(def palette-bright-yellow 11)
(def palette-bright-blue 12)
(def palette-bright-magenta 13)
(def palette-bright-cyan 14)
(def palette-bright-white 15)
(def palette-gray palette-bright-black)


;;; A cursor aggregates the stream of commands that should be printed.
(deftype Cursor [^int insn-count ^Object/1 insns ^long style]
  ;; FIXME... Valhalla value type & not null
  )

;;; A fragment is the sequence of commands that have been collected
;;; into cursor `csr`.
(defn fragment ^Object/1 [^Cursor csr]
  (Arrays/copyOf (.insns csr) (.insn-count csr)))

;;; A page is a normalized sequence of commands.  It is either empty,
;;; or sequence ending with text, followed by a `style-default`
;;; command, followed by a `end-current-line` command.
;;;
;;; This function should not be used if the instructions of `csr` are
;;; subject to futher rewriting before rendering, because it would
;;; clobber formatting instructions following the last piece of text.
;;; In this case, use `fragment` instead.
(defn page ^Object/1 [^Cursor csr]
  (letfn [(end-of-text ^int [^int i]
            (if (or (zero? i) (insn/text? (.insns csr) (dec i)))
              i
              (recur (dec i))))]
    (let [eot (end-of-text (.insn-count csr))]
      (if (zero? eot)
        (new Object/1 0)
        (doto (Arrays/copyOf (.insns csr) (+ eot 2))
          (aset (+ eot 0) insn/insn-reset-style)
          (aset (+ eot 1) insn/insn-end-current-line-0))))))

(defn page? ^boolean [^Object/1 frag]
  (or (zero? (alength frag))
      (insn/cmd? insn/end-current-line frag (dec (alength frag)))))

(defn mk-cursor
  (^Cursor []
   (mk-cursor insn/style-default))
  (^Cursor [^long style]
   (Cursor. 0 (new Object/1 16) style)))


;;; A command is encoded as an int.  24 bits for an argument, 8 bits
;;; for the command id.  The command value "all zeros" is reserved.

(letfn [(grow-insns ^Object/1 [^Object/1 insns ^int i]
          (cond-> insns (= i (alength insns)) (Arrays/copyOf (* i 2))))
        (add-insn+style ^Cursor [^Cursor csr ^Object insn ^long style]
          (let [i (.insn-count csr)]
            (Cursor. (inc i)
                     (doto (grow-insns (.insns csr) i) (aset i insn))
                     style)))]
  (defn add-printable-insn ^Cursor [^Cursor csr insn]
    (add-insn+style csr insn (.style csr)))
  (defn add-printable-cmd ^Cursor [^Cursor csr ^int cmd-id ^int cmd-arg]
    (add-printable-insn csr (insn/mk-cmd cmd-id cmd-arg)))
  (defn- add-styling-cmd
    (^Cursor [^Cursor csr ^Integer cmd]
     (add-insn+style csr cmd (insn/apply-to-style (.style csr) ^int cmd)))
    (^Cursor [^Cursor csr ^int id ^int arg]
     (add-styling-cmd csr (insn/mk-cmd id arg))))
  (defn- set-style-flag ^Cursor [^Cursor csr ^int flag ^boolean enabled?]
    (add-styling-cmd csr (- insn/clear-style-flag (int enabled?)) flag))

  (defn text ^Cursor [^Cursor csr ^String txt]
    (add-insn+style csr txt (.style csr)))
  (defn newline
    (^Cursor [^Cursor csr]
     (newline csr 0))
    (^Cursor [^Cursor csr ^int then-column]
     (let [cmd (if (zero? then-column)
                 insn/insn-end-current-line-0
                 (insn/mk-cmd insn/end-current-line then-column))]
       (add-printable-insn csr cmd))))
  (defn advance-lines ^Cursor [^Cursor csr ^int n]
    (add-printable-cmd csr insn/advance-lines n))
  (defn forward-to-column ^Cursor [^Cursor csr ^int column]
    (add-printable-cmd csr insn/forward-to-column column))
  (defn skip-commands ^Cursor [^Cursor csr ^int n]
    (add-printable-cmd csr insn/skip-commands n))
  
  (defn with-style ^Cursor [^Cursor csr ^long style]
    (cond-> csr
      (not= style (.style csr))
      (add-insn+style (insn/mk-style style) style)))

  (defn replay-insn ^Cursor [^Cursor csr insn]
    (cond
      (insn/text? insn) (text csr insn)
      (insn/cmd? insn) (add-styling-cmd csr insn)
      (insn/style? insn) (with-style csr ^long insn)
      :else (throw (IllegalStateException.))))
  (defn replay-fragment ^Cursor [^Cursor csr ^Object/1 frag
                                 ^int start ^int end]
    (loop [csr csr, i start]
      (if (< i end)
        (let [insn (aget frag i)]
          (if (insn/cmd? insn)
            (let [cmd ^int insn]
              (if (insn/cmd? insn/skip-commands cmd)
                (recur csr (insn/skip-to-index i cmd))
                (recur (replay-insn csr insn) (inc i))))
            (recur (replay-insn csr insn) (inc i))))
        csr)))

  (let [mask-4bit 0xf
        mask-8bit 0xff
        mask-24bit 0xffffff]
    (defn foreground-default ^Cursor [^Cursor csr]
      (add-styling-cmd csr (+ insn/set-foreground insn/color-mode-default) 0))
    (defn foreground-4bit ^Cursor [^Cursor csr ^int color]
      (add-styling-cmd csr (+ insn/set-foreground insn/color-mode-palette-4bit)
                       (bit-and mask-4bit color)))
    (defn foreground-8bit ^Cursor [^Cursor csr ^int color]
      (add-styling-cmd csr (+ insn/set-foreground insn/color-mode-palette-8bit)
                       (bit-and mask-8bit color)))
    (defn foreground-rgb ^Cursor [^Cursor csr ^int rgb]
      (add-styling-cmd csr (+ insn/set-foreground insn/color-mode-default)
                       (bit-and mask-24bit rgb)))

    (defn background-default ^Cursor [^Cursor csr]
      (add-styling-cmd csr (+ insn/set-background insn/color-mode-default) 0))
    (defn background-4bit ^Cursor [^Cursor csr ^int color]
      (add-styling-cmd csr (+ insn/set-background insn/color-mode-palette-4bit)
                       (bit-and mask-4bit color)))
    (defn background-8bit ^Cursor [^Cursor csr ^int color]
      (add-styling-cmd csr (+ insn/set-background insn/color-mode-palette-8bit)
                       (bit-and mask-8bit color)))
    (defn background-rgb ^Cursor [^Cursor csr ^int rgb]
      (add-styling-cmd csr (+ insn/set-background insn/color-mode-default)
                       (bit-and mask-24bit rgb))))

  (defn intensity-normal ^Cursor [^Cursor csr]
    (add-styling-cmd csr insn/set-intensity insn/intensity-normal))
  (defn intensity-bright ^Cursor [^Cursor csr]
    (add-styling-cmd csr insn/set-intensity insn/intensity-bright))
  (defn intensity-faint ^Cursor [^Cursor csr]
    (add-styling-cmd csr insn/set-intensity insn/intensity-faint))

  (defn underline
    (^Cursor [^Cursor csr]
     (underline csr true))
    (^Cursor [^Cursor csr ^boolean enabled?]
     (set-style-flag csr insn/flag-style-underline enabled?)))
  (defn strikethrough
    (^Cursor [^Cursor csr]
     (strikethrough csr true))
    (^Cursor [^Cursor csr ^boolean enabled?]
     (set-style-flag csr insn/flag-style-strikethrough enabled?)))
  
  (defn font-bold
    (^Cursor [^Cursor csr]
     (font-bold csr true))
    (^Cursor [^Cursor csr ^boolean enabled?]
     (set-style-flag csr insn/flag-style-font-bold enabled?)))
  (defn font-italic
    (^Cursor [^Cursor csr]
     (font-italic csr true))
    (^Cursor [^Cursor csr ^boolean enabled?]
     (set-style-flag csr insn/flag-style-font-italic enabled?)))

  (defn conceal-off ^Cursor [^Cursor csr]
    (add-styling-cmd csr insn/set-conceal insn/conceal-off))
  (defn conceal-invisible ^Cursor [^Cursor csr] ;can be extracted via cut&paste
    (add-styling-cmd csr insn/set-conceal insn/conceal-invisible))
  (defn conceal-XXX ^Cursor [^Cursor csr]
    (add-styling-cmd csr insn/set-conceal insn/conceal-XXX))
  (defn conceal-spaces ^Cursor [^Cursor csr]
    (add-styling-cmd csr insn/set-conceal insn/conceal-spaces)))

(defmacro with-save-restore-> [csr & body]
  `(let [csr# ~csr]
     (-> csr# ~@body (with-style (.style csr#)))))

;;; ------------------------------------------------------------------------

(letfn [(append-text ^StringBuilder [^StringBuilder sb ^String txt ^int width
                                     ^long style]
          (let [conceal (insn/extract style insn/mask-style-conceal)]
            (if (< conceal insn/conceal-XXX)
              (.append sb txt)
              (.repeat sb (if (= conceal insn/conceal-spaces) " " "X") width))))

        (beginning-of-line-array ^int/1 [^Object/1 page]
          (let [n (insn/line-count page)
                off (new int/1 (inc n))]
            (loop [next-line 1, i 0]
              (if (< i (alength page))
                (let [insn (aget page i)]
                  (if (insn/cmd? insn)
                    (let [cmd ^int insn]
                      (case (insn/cmd-id cmd)
                        (#_end-current-line 1)
                        (do (aset off next-line (inc i))
                            (recur (inc next-line) (inc i)))
                        (#_advance-lines 2)
                        (let [n (insn/cmd-arg cmd)]
                          (Arrays/fill off next-line (+ next-line n) (inc i))
                          (recur (+ next-line n) (inc i)))
                        (#_skip-commands 4)
                        (recur next-line (insn/skip-to-index i cmd))
                        #_else
                        (recur next-line (inc i))))
                    (recur next-line (inc i))))
                off))))
        (end-of-line ^int [^int/1 bola ^int line]
          (dec (aget bola (inc line))))]
  
  (defn render-into
    (^StringBuilder [^StringBuilder sb ^Object/1 frag]
     (render-into sb frag insn/style-default))
    (^StringBuilder [^StringBuilder sb ^Object/1 frag ^long style]
     (loop [sb sb, sb-style style, style style, column 0, i 0]
       (if (< i (alength frag))
         (let [insn (aget frag i)
               sb-style (if (and (not= sb-style style) (insn/printable? insn))
                          (do (ansi/sgr-delta sb sb-style style)
                              style)
                          sb-style)]
           (cond
             (insn/text? insn)
             (let [txt ^String insn, width (insn/text-width txt)]
               (recur (append-text sb txt width style)
                      sb-style style (+ column width) (inc i)))
             
             (insn/cmd? insn)
             (let [cmd ^int insn, arg (insn/cmd-arg cmd)]
               (case (insn/cmd-id cmd)
                 (#_end-current-line 1)
                 (let [column' arg]
                   (recur (-> sb (.append \newline) (.repeat " " column'))
                          sb-style style column' (inc i)))
                 
                 (#_advance-lines 2)
                 ;; Note: "Cursor Next Line" at bottom does not scroll
                 ;; up.  Stick with repeated newline.
                 (if (zero? arg)
                   (recur sb sb-style style column (inc i))
                   (recur (.repeat sb "\n" arg) sb-style style 0 (inc i)))

                 (#_forward-to-column 3)
                 (let [column' (max column arg)]
                   ;; Note: "Cursor Forward" at the right edge of the
                   ;; screen does not move into the next line.  Stick
                   ;; with repeated spaces.
                   (recur (.repeat sb " " (- column' column))
                          sb-style style column' (inc i)))

                 (#_skip-commands 4)
                 (recur sb sb-style style column (insn/skip-to-index i cmd))
                 
                 #_else (let [style' (insn/apply-to-style style cmd)]
                          (recur sb sb-style style' column (inc i)))))

             (insn/style? insn)
             (recur sb sb-style ^long insn column (inc i))
             
             :else (throw (IllegalStateException. (str insn)))))
         (ansi/sgr-delta sb sb-style style)))))
  (defn str-render ^String [^Object/1 frag]
    (-> (StringBuilder.) (render-into frag) (.toString)))

  (defn print-into
    (^StringBuilder [^StringBuilder sb ^Object/1 frag]
     (print-into sb frag insn/style-default))
    (^StringBuilder [^StringBuilder sb ^Object/1 frag ^long style]
     (loop [sb sb, style style, column 0, i 0]
       ;; only `conceal-XXX` and `conceal-spaces` are picked up from
       ;; `style`
       (if (< i (alength frag))
         (let [insn (aget frag i)]
           (cond
             (insn/text? insn)
             (let [txt ^String insn, width (insn/text-width txt)]
               (recur (append-text sb txt width style)
                      style (+ column width) (inc i)))
             
             (insn/cmd? insn)
             (let [cmd ^int insn, arg (insn/cmd-arg cmd)]
               (case (insn/cmd-id cmd)
                 (#_end-current-line 1)
                 (let [column' arg]
                   (recur (-> sb (.append \newline) (.repeat " " column'))
                          style column' (inc i)))
                 
                 (#_advance-lines 2)
                 (if (zero? arg)
                   (recur sb style column (inc i))
                   (recur (.repeat sb "\n" arg) style 0 (inc i)))

                 (#_forward-to-column 3)
                 (let [column' (max column arg)]
                   (recur (.repeat sb " " (- column' column))
                          style column' (inc i)))
                 
                 (#_skip-commands 4)
                 (recur sb style column (insn/skip-to-index i cmd))
                 
                 #_else
                 (let [style' (insn/apply-to-style style cmd)]
                   (recur sb style' column (inc i)))))

             (insn/style? insn)
             (recur sb ^long insn column (inc i))
             
             :else (throw (IllegalStateException. (str insn)))))
         sb))))
  (defn str-print ^String [^Object/1 frag]
    (-> (StringBuilder.) (print-into frag) (.toString)))

  (defn- side-by-side* ^Cursor [^Cursor csr ^Object/2 pages ^int/1 columns]
    (let [n (alength pages)
          bolas (new int/2 n)] 
      (letfn [(line-count ^int [^int p]
                (dec (alength (aget bolas p))))
              (page-line-column ^int [^Object/1 page ^int start]
                (if (zero? start)
                  0
                  (let [cmd ^int (aget page (dec start))]
                    (case (insn/cmd-id cmd)
                      (#_end-current-line 1) (insn/cmd-arg cmd)
                      (#_advance-lines 2) 0))))
              (append-page-line ^Cursor [^Cursor acc ^Object/1 page
                                         ^int page-column ^int start ^int end]
                (loop [acc acc, i start]
                  (if (< i end)
                    (let [insn (aget page i)]
                      (if (insn/cmd? insn)
                        (let [cmd ^int insn]
                          (case (insn/cmd-id cmd)
                            (#_forward-to-column 3)
                            (let [column' (+ (insn/cmd-arg insn) page-column)]
                              (recur (forward-to-column acc column') (inc i)))
                            (#_skip-commands 4)
                            (recur acc (insn/skip-to-index i cmd))
                            #_else
                            (recur (replay-insn acc insn) (inc i))))
                        (recur (replay-insn acc insn) (inc i))))
                    acc)))
              (append-line! ^Cursor [^Cursor acc ^int line ^long/1 !styles]
                (loop [acc acc, p 0]
                  (if (< p n)
                    (if (< line (line-count p))
                      (let [page (aget pages p)
                            start (aget bolas p line)
                            end (end-of-line (aget bolas p) line)
                            page-column (aget columns p)
                            column-0 (+ page-column
                                        (page-line-column page start))
                            csr' (-> (forward-to-column acc column-0)
                                     (with-style (aget !styles p))
                                     (append-page-line page page-column
                                                       start end))]
                        (aset !styles p (.style csr'))
                        (recur csr' (inc p)))
                      (recur acc (inc p)))
                    (newline acc))))]
        (dotimes [p n]
          (aset bolas p (beginning-of-line-array (aget pages p))))
        (let [total-lines ^int (reduce #(max ^int %1 (line-count ^int %2))
                                       0 (range n))
              !styles (new long/1 n)] ;initialized to insn/style-default
          (loop [csr csr, line 0]
            (if (< line total-lines)
              (recur (-> (with-style csr insn/style-default)
                         (append-line! line !styles))
                     (inc line))
              csr))))))

  (defn side-by-side-into ^Cursor [^Cursor csr ^Object/2 pages ^int/1 columns]
    (dotimes [i (alength pages)]
      (when-not (page? (aget pages i))
        (throw (IllegalArgumentException. "page required"))))
    (side-by-side* csr pages columns)))

(defn print-page ^void [^Object/1 page]
  (-> (StringBuilder.)
      #_(.append "---- start of page ----\n")
      (render-into #_print-into page)
      #_(.append "---- end of page ----\n")
      (.toString)
      (print))
  ;; print without newline is not automatically flushed on program
  ;; exit, so force the output here to avoid any surprises
  (flush))
