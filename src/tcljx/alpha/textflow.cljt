;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.alpha.textflow
  (:require [tcljx.alpha.textflow__impl :as impl]
            [tcljx.alpha.textflow__ansi :as ansi])
  (:import (java.util Arrays)))

;;; Basic support for styled left-to-right and top-to-bottom text.
;;; Imposes sufficient structure to record a stream of commands, to
;;; combine two or more streams into a multi-column layout, and to
;;; play back a stream to some device.  Primary target is a terminal
;;; supporting ANSI escape sequences.

;;; The style state is encoded as a long.  24 bits for foreground
;;; color, 24 bits for background color, and 16 bits holding the rest
;;; of the state information.

;;; https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit
(def palette-black 0)
(def palette-red 1)
(def palette-green 2)
(def palette-yellow 3)
(def palette-blue 4)
(def palette-magenta 5)
(def palette-cyan 6)
(def palette-white 7)
(def palette-bright-black 8)
(def palette-bright-red 9)
(def palette-bright-green 10)
(def palette-bright-yellow 11)
(def palette-bright-blue 12)
(def palette-bright-magenta 13)
(def palette-bright-cyan 14)
(def palette-bright-white 15)
(def palette-gray palette-bright-black)


;;; A cursor aggregates the stream of commands that should be printed.
(deftype Cursor [^int cmd-count ^Object/1 cmds ^long style]
  ;; FIXME... Valhalla value type & not null
  )

;;; A fragment is the sequence of commands that have been collected
;;; into cursor `csr`.
(defn fragment ^Object/1 [^Cursor csr]
  (Arrays/copyOf (.cmds csr) (.cmd-count csr)))

;;; A page is a normalized sequence of commands.  It is either empty,
;;; or sequence ending with text, followed by a `style-default`
;;; command, followed by a `end-current-line` command.
(defn page ^Object/1 [^Cursor csr]
  (letfn [(end-of-text ^int [^int i]
            (if (or (zero? i) (string? (aget (.cmds csr) (dec i))))
              i
              (recur (dec i))))]
    (let [eot (end-of-text (.cmd-count csr))]
      (if (zero? eot)
        (new Object/1 0)
        (doto (Arrays/copyOf (.cmds csr) (+ eot 2))
          (aset (+ eot 0) (object impl/style-default))
          (aset (+ eot 1) (object (impl/mk-cmd impl/end-current-line 0))))))))

(defn page? ^boolean [^Object/1 frag]
  (or (zero? (alength frag))
      (impl/cmd? impl/end-current-line frag (dec (alength frag)))))

(defn mk-cursor
  (^Cursor []
   (mk-cursor impl/style-default))
  (^Cursor [^long style]
   (Cursor. 0 (new Object/1 16) style)))


;;; A command is encoded as an int.  24 bits for an argument, 8 bits
;;; for the command id.  The command value "all zeros" is reserved.

(letfn [(grow-cmds ^Object/1 [^Object/1 cmds ^int i]
          (cond-> cmds (= i (alength cmds)) (Arrays/copyOf (* i 2))))
        (add-object ^Cursor [^Cursor csr ^Object cmd ^long style]
          (let [i (.cmd-count csr)]
            (Cursor. (inc i)
                     (doto (grow-cmds (.cmds csr) i) (aset i cmd))
                     style)))
        (add-cmd
          (^Cursor [^Cursor csr ^Integer cmd]
           (let [style' (impl/apply-command (.style csr) ^int cmd)]
             (add-object csr cmd style')))
          (^Cursor [^Cursor csr ^int id ^int arg]
           (add-cmd csr (object (impl/mk-cmd id arg)))))
        (add-cmd-bool ^Cursor [^Cursor csr ^int id ^boolean arg?]
          (add-cmd csr id (int arg?)))]
  (defn text ^Cursor [^Cursor csr ^String txt]
    (add-object csr txt (.style csr)))
  (defn newline
    (^Cursor [^Cursor csr]
     (newline csr 0))
    (^Cursor [^Cursor csr ^int then-column]
     (add-cmd csr impl/end-current-line then-column)))
  (defn forward-to-column ^Cursor [^Cursor csr ^int column]
    (add-cmd csr impl/forward-to-column column))
  
  (defn with-style ^Cursor [^Cursor csr ^long style]
    (cond-> csr
      (not= style (.style csr))
      (add-object (object style) style)))

  (defn- replay ^Cursor [^Cursor csr x]
    (cond
      (instance? String x) (text csr x)
      (instance? Integer x) (add-cmd csr x)
      (instance? Long x) (with-style csr ^long x)
      :else (throw (IllegalStateException.))))

  (let [mask-4bit 0xf
        mask-8bit 0xff
        mask-24bit 0xffffff]
    (defn foreground-default ^Cursor [^Cursor csr]
      (add-cmd csr (+ impl/set-foreground impl/color-mode-default) 0))
    (defn foreground-4bit ^Cursor [^Cursor csr ^int color]
      (add-cmd csr (+ impl/set-foreground impl/color-mode-palette-4bit)
               (bit-and mask-4bit color)))
    (defn foreground-8bit ^Cursor [^Cursor csr ^int color]
      (add-cmd csr (+ impl/set-foreground impl/color-mode-palette-8bit)
               (bit-and mask-8bit color)))
    (defn foreground-rgb ^Cursor [^Cursor csr ^int rgb]
      (add-cmd csr (+ impl/set-foreground impl/color-mode-default)
               (bit-and mask-24bit rgb)))

    (defn background-default ^Cursor [^Cursor csr]
      (add-cmd csr (+ impl/set-background impl/color-mode-default) 0))
    (defn background-4bit ^Cursor [^Cursor csr ^int color]
      (add-cmd csr (+ impl/set-background impl/color-mode-palette-4bit)
               (bit-and mask-4bit color)))
    (defn background-8bit ^Cursor [^Cursor csr ^int color]
      (add-cmd csr (+ impl/set-background impl/color-mode-palette-8bit)
               (bit-and mask-8bit color)))
    (defn background-rgb ^Cursor [^Cursor csr ^int rgb]
      (add-cmd csr (+ impl/set-background impl/color-mode-default)
               (bit-and mask-24bit rgb))))

  (defn intensity-normal ^Cursor [^Cursor csr]
    (add-cmd csr impl/set-intensity impl/intensity-normal))
  (defn intensity-bright ^Cursor [^Cursor csr]
    (add-cmd csr impl/set-intensity impl/intensity-bright))
  (defn intensity-faint ^Cursor [^Cursor csr]
    (add-cmd csr impl/set-intensity impl/intensity-faint))

  (defn underline
    (^Cursor [^Cursor csr]
     (underline csr true))
    (^Cursor [^Cursor csr ^boolean enabled?]
     (add-cmd-bool csr impl/set-underline enabled?)))
  (defn strikethrough
    (^Cursor [^Cursor csr]
     (strikethrough csr true))
    (^Cursor [^Cursor csr ^boolean enabled?]
     (add-cmd-bool csr impl/set-strikethrough enabled?)))

  (defn font-bold
    (^Cursor [^Cursor csr]
     (font-bold csr true))
    (^Cursor [^Cursor csr ^boolean enabled?]
     (add-cmd-bool csr impl/set-font-bold enabled?)))
  (defn font-italic
    (^Cursor [^Cursor csr]
     (font-italic csr true))
    (^Cursor [^Cursor csr ^boolean enabled?]
     (add-cmd-bool csr impl/set-font-italic enabled?)))

  (defn conceal-off ^Cursor [^Cursor csr]
    (add-cmd csr impl/set-conceal impl/conceal-off))
  (defn conceal-invisible ^Cursor [^Cursor csr] ;can be extracted via cut&paste
    (add-cmd csr impl/set-conceal impl/conceal-invisible))
  (defn conceal-XXX ^Cursor [^Cursor csr]
    (add-cmd csr impl/set-conceal impl/conceal-XXX))
  (defn conceal-spaces ^Cursor [^Cursor csr]
    (add-cmd csr impl/set-conceal impl/conceal-spaces))
  )

(defmacro with-save-restore-> [csr & body]
  `(let [csr# ~csr]
     (-> csr# ~@body (with-style (.style csr#)))))

;;; ------------------------------------------------------------------------

(letfn [(text-width ^int [^String txt]
          (.codePointCount txt 0 (.length txt)))
        (append-text ^StringBuilder [^StringBuilder sb ^String txt ^int width
                                     ^long style]
          (let [conceal (impl/extract impl/mask-style-conceal style)]
            (if (< conceal impl/conceal-XXX)
              (.append sb txt)
              (.repeat sb (if (= conceal impl/conceal-spaces) " " "X") width))))
        
        (line-count ^int [^Object/1 frag] ;number of `end-current-line`
          (loop [acc 0, i (dec (alength frag))]
            (if (neg? i)
              acc
              (recur (+ acc (int (impl/cmd? impl/end-current-line frag i)))
                     (dec i)))))
        (beginning-of-line-array ^int/1 [^Object/1 page]
          (let [n (line-count page)
                off (new int/1 (inc n))]
            (loop [next-line 1, i 0]
              (if (< i (alength page))
                (recur (if (impl/cmd? impl/end-current-line page i)
                         (do (aset off next-line (inc i))
                             (inc next-line))
                         next-line)
                       (inc i))
                off))))
        (end-of-line ^int [^int/1 bola ^int line]
          (dec (aget bola (inc line))))]
  
  (defn render-into
    (^StringBuilder [^StringBuilder sb ^Object/1 frag]
     (render-into sb frag impl/style-default))
    (^StringBuilder [^StringBuilder sb ^Object/1 frag ^long style]
     (loop [sb sb, style style, column 0, i 0]
       (if (< i (alength frag))
         (let [x (aget frag i)]
           (cond
             (instance? String x)
             (let [txt ^String x, width (text-width txt)]
               (recur (append-text sb txt width style)
                      style (+ column width) (inc i)))
             
             (instance? Integer x)
             (let [cmd ^int x, arg (impl/cmd-arg cmd)]
               (case (impl/cmd-id cmd)
                 (#_end-current-line 1)
                 (let [column' arg]
                   (recur (-> (.append sb \newline)
                              (ansi/cursor-forward column'))
                          style column' (inc i)))
                 
                 (#_forward-to-column 2)
                 (let [column' (max column arg)]
                   (recur (ansi/cursor-forward sb (- column' column))
                          style column' (inc i)))
                 
                 #_else
                 (let [style' (impl/apply-command style cmd)]
                   (recur (ansi/sgr-delta sb style style')
                          style' column (inc i)))))

             (instance? Long x)
             (let [style' ^long x]
               (recur (ansi/sgr-delta sb style style') style' column (inc i)))
             
             :else (throw (IllegalStateException. (str x)))))
         sb))))

  (defn print-into
    (^StringBuilder [^StringBuilder sb ^Object/1 frag]
     (print-into sb frag impl/style-default))
    (^StringBuilder [^StringBuilder sb ^Object/1 frag ^long style]
     (loop [sb sb, style style, column 0, i 0]
       (if (< i (alength frag))
         (let [x (aget frag i)]
           (cond
             (instance? String x)
             (let [txt ^String x, width (text-width txt)]
               (recur (append-text sb txt width style)
                      style (+ column width) (inc i)))
             
             (instance? Integer x)
             (let [cmd ^int x, arg (impl/cmd-arg cmd)]
               (case (impl/cmd-id cmd)
                 (#_end-current-line 1)
                 (let [column' arg]
                   (recur (-> (.append sb \newline)
                              (.repeat " " column'))
                          style column' (inc i)))
                 
                 (#_forward-to-column 2)
                 (let [column' (max column arg)]
                   (recur (.repeat sb " " (- column' column))
                          style column' (inc i)))
                 
                 #_else
                 (let [style' (impl/apply-command style cmd)]
                   (recur sb style' column (inc i)))))

             (instance? Long x)
             (let [style' ^long x]
               (recur sb style' column (inc i)))
             
             :else (throw (IllegalStateException. (str x)))))
         sb))))

  (defn- side-by-side* ^Object/1 [^Object/2 pages ^int/1 columns]
    (let [n (alength pages)
          bolas (new int/2 n)] 
      (letfn [(line-count ^int [^int p]
                (dec (alength (aget bolas p))))
              (page-line-column ^int [^Object/1 page ^int start]
                (if (zero? start)
                  0
                  (let [cmd ^int (aget page (dec start))]
                    (assert (impl/cmd? impl/end-current-line cmd))
                    (impl/cmd-arg cmd))))
              (append-page-line ^Cursor [^Cursor acc ^Object/1 page
                                         ^int column ^int start ^int end]
                (loop [acc acc, i start]
                  (if (< i end)
                    (let [x (aget page i)]
                      (recur (if (impl/cmd? impl/forward-to-column x)
                               (let [column' (+ (impl/cmd-arg x) column)]
                                 (forward-to-column acc column'))
                               (replay acc x))
                             (inc i)))
                    acc)))
              (append-line! ^Cursor [^Cursor acc ^int line ^long/1 !styles]
                (loop [acc acc, p 0]
                  (if (< p n)
                    (if (< line (line-count p))
                      (let [page (aget pages p)
                            start (aget bolas p line)
                            end (end-of-line (aget bolas p) line)
                            column (+ (aget columns p)
                                      (page-line-column page start))
                            csr' (-> (forward-to-column acc column)
                                     (with-style (aget !styles p))
                                     (append-page-line page column start end))]
                        (aset !styles p (.style csr'))
                        (recur csr' (inc p)))
                      (recur acc (inc p)))
                    (newline acc))))]
        (dotimes [p n]
          (aset bolas p (beginning-of-line-array (aget pages p))))
        (let [total-lines ^int (reduce #(max ^int %1 (line-count ^int %2))
                                       0 (range n))
              !styles (new long/1 n)] ;initialized to impl/style-default
          (loop [acc (mk-cursor), line 0]
            (if (< line total-lines)
              (recur (-> (with-style acc impl/style-default)
                         (append-line! line !styles))
                     (inc line))
              (page acc)))))))

  (defn side-by-side ^Object/1 [^Object/2 pages ^int/1 columns]
    (dotimes [i (alength pages)]
      (when-not (page? (aget pages i))
        (throw (IllegalArgumentException. "page required"))))
    (if (and (= (alength pages) 1) (zero? (aget columns 0)))
      (aget pages 0)
      (side-by-side* pages columns))))

(defn print-page ^void [^Object/1 page]
  (-> (StringBuilder.)
      (.append "---- start of page ----\n")
      (render-into #_print-into page)
      (.append "---- end of page ----\n")
      (.toString)
      (print))
  ;; print without newline is not automatically flushed on program
  ;; exit, so force the output here to avoid any surprises
  (flush))
