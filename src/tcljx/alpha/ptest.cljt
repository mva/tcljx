;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.alpha.ptest ;small subset of clojure.test -- partial but parallel
  (:require [tcljx.alpha.ptest__impl :as impl]))

(defmacro deftest [nm & body]
  (assert (symbol? nm))
  (let [m {:var true, :test true, :line (:line (meta &form))}]
    ;; Meta map has :test to identify test vars, and :line number to
    ;; sort the vars into source code order.
    `(defn ~(vary-meta nm merge m) ^void []
       ~@body)))

(defmacro thrown-msg-test [ctx class re form]
  (assert (symbol? class))
  `(try
     ~form
     (.outcome-fail ~ctx "no exception was raised"
                    (object ~class) nil)
     ~(if (nil? re)
        `(catch ~class _
           (.outcome-pass ~ctx))
        `(catch ~class e#
           (let [m# (.getMessage e#), re# ~re]
             (if (re-find re# m#)
               (.outcome-pass ~ctx)
               (.outcome-fail ~ctx "unexpected exception message"
                              (object re#) m#)))))
     (catch Throwable t#
       (.outcome-fail ~ctx "unexpected exception type"
                      ~class (class t#)))))

(defmacro is [form]
  (let [ctx (gensym "__ctx")
        line (-> &form (meta) :line)]
    (assert (some? line) "form of `is` macro has no :line meta")
    `(when-some [~ctx (impl/is-context-if-selected ~line)]
       ~(case (when (seq? form) (first form))
          (= tinyclj.core/= tinyclj.lang.primitive/equiv-nary)
          `(impl/equiv-test ~ctx ~form)
          
          (thrown? tcljx.alpha.ptest/thrown?)
          `(thrown-msg-test ~ctx ~(second form) nil ~@(nthrest form 2))
          
          (thrown-with-msg? tcljx.alpha.ptest/thrown-with-msg?)
          `(thrown-msg-test ~ctx ~@(rest form))
          
          #_else `(impl/boolean-test ~ctx ~form)))))

;;; ------------------------------------------------------------------------

;;; Calls `.printStackTrace` with output redirected to `*err*`.  Use
;;; inside a `deftest` to have the stack trace captured as part of the
;;; test output.  Calling the single argument JDK method writes to
;;; `System/err`, bypassing the captured `*err*`.
(defn print-stack-trace ^void [^Throwable t]
  (.printStackTrace t ^java.io.PrintWriter *err*))

(defn run-and-report ^keyword [^vector nmspv]
  (let [rep (-> (impl/run-tests nmspv) (time))]
    (println "\nRan" (.tests rep) "tests containing"
             (impl/is-count rep) "assertions.")
    (println (.is-fail rep) "failures," (.is-error rep) "errors.")
    (impl/exit-status rep)))

(defn run-scoped-tests
  "If the environment variable \"TEST\") is set, then only run the test
  of this namespaced var or only the tests from the given namespace.
  Optionally, limit this to matching line numbers if the suffix
  `:<number>` is present.  Otherwise, run the tests from the
  namespaces in `else-namespaces`.  Var and namespace can be specified
  as symbol or string.  Depending on the outcome, result is one of the
  keywords :error, :fail, or :success."
  (^keyword [else-namespaces]
   (run-and-report (if-some [spec (System/getenv "TEST")]
                     (impl/parse-scope-spec spec)
                     (impl/parse-scope-specs else-namespaces)))))
