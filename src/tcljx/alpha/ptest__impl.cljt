;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.alpha.ptest__impl
  (:require
   [tcljx.alpha.ptest__style :as style]
   [tcljx.alpha.ptest__align :as align])
  (:import
   (clojure.lang Var)
   (java.io StringWriter)
   (java.time Instant)
   (java.util ArrayList)
   (java.util.concurrent StructuredTaskScope$ShutdownOnFailure
                         StructuredTaskScope$Subtask
                         CountDownLatch)
   (java.util.function Function IntPredicate)))

(def ^:private run-tests-as-concurrent-tasks? true)
(def ^:private deadline-test-var-seconds (* 1 60))
(def ^:private deadline-namespace-seconds (* 2 60))

(letfn [(nmsp-of ^String [^String spec]
          (let [i-var (.indexOf spec (int \/))]
            (if (neg? i-var)
              spec
              (.substring spec 0 i-var))))
        (namespace-scope ^vector [^String spec]
          (let [nmsp (nmsp-of spec)]
            (if (identical? nmsp spec)
              [spec true]               ;scope is whole nmsp
              (let [i-var (inc (.length nmsp))
                    i-line (inc (.indexOf spec (int \:) i-var))]
                (if (zero? i-line)
                  [nmsp {(.substring spec i-var) true}] ;scope is nmsp/var
                  (let [var (.substring spec i-var (dec i-line))
                        line (.substring spec i-line)]
                    [nmsp {var #{(Integer/parseInt line)}}]))))))
        (scope-map ^map [^vector nmsp-scope]
          (conj {} nmsp-scope))]
  
  (defn parse-scope-spec ^vector [spec]
    [(namespace-scope (str spec))])

  (defn parse-scope-specs ^vector [specs]
    (letfn [(union-var [a b]
              (or (true? a) (true? b) (into a b))) ;use `into` as `set/union`
            (union-nmsp [a b]
              (or (true? a) (true? b) (merge-with union-var a b)))]
      (let [m (transduce (map (comp scope-map namespace-scope str))
                         (completing (partial merge-with union-nmsp))
                         {} specs)]
        (->> (map (comp nmsp-of str) specs)
             (distinct)
             (mapv (partial find m)))))))

;;; ------------------------------------------------------------------------

(deftype Report [^int tests ^int is-pass ^int is-fail ^int is-error]
  java.lang.Record)
(def ^:private report-empty (Report. 0 0 0 0))
(def ^:private test-report-empty (Report. 1 0 0 0))
(def ^:private is-report-pass (Report. 0 1 0 0))
(def ^:private is-report-fail (Report. 0 0 1 0))
(def ^:private is-report-error (Report. 0 0 0 1))

(defn- add-report ^Report [^Report a ^Report b]
  (Report. (+ (.tests a) (.tests b))
           (+ (.is-pass a) (.is-pass b))
           (+ (.is-fail a) (.is-fail b))
           (+ (.is-error a) (.is-error b))))
(defn- add-reports ^Report [^Report init reports]
  (reduce add-report init reports))

(defn is-count ^int [^Report rep]
  (+ (.is-pass rep) (.is-fail rep) (.is-error rep)))

(defn all-pass? ^boolean [^Report rep]
  (zero? (+ (.is-error rep) (.is-fail rep))))

(defn exit-status ^keyword [^Report rep]
  (if (zero? (.is-error rep) )
    (if (zero? (.is-fail rep)) :success :fail)
    :error))

;;; ------------------------------------------------------------------------

(defn- print-lines [^java.lang.StringBuffer buffer ^int start ^int end]
  (let [s (.substring buffer start end)]
    (print s)
    (when-not (.endsWith s "\n") (newline))))

(definterface ITestContext
  (output-position ^int [])
  (register-outcome ^void [^int out-start ^int out-end ^Callable outcome]))

(deftype TestContext [^symbol var-symbol
                      ^IntPredicate select-is? ;enable `is` based on line number
                      ^StringWriter output ;target of *out* and *err*
                      ^ArrayList outcomes ;receives `is` outcome Callables
                      ;; ^int line    ;line number of `deftest` or `is`
                      ^:unsynchronized-mutable ^int out-mark]
  ITestContext
  (output-position [_]
    (-> output (.getBuffer) (.length)))
  (register-outcome [_ out-start out-end outcome]
    (when (< out-mark out-start)
      (.add outcomes
            (^Callable fn []
             (print-lines (.getBuffer output) out-mark out-start)
             report-empty)))
    (when (some? outcome)       ;omit when marking the `deftest`'s end
      (.add outcomes outcome))
    (set! out-mark out-end)))

;;; ------------------------------------------------------------------------

(definterface IsContext
  ;; An error is any unexpected exception outside or within an `is`
  ;; form.
  (outcome-error ^void [^Throwable ex])
  (outcome-fail ^void [^String msg expected actual])
  (outcome-pass ^void []))

(defmacro equiv-test ^void [ctx [_ exp act :as form]]
  (assert (= (count form) 3))
  `(try
     (let [exp# ~exp, act# ~act]
       (if (= exp# act#)
         (.outcome-pass ~ctx)
         (.outcome-fail ~ctx "expected not equivalent to actual value"
                        (object exp#) (object act#))))
     (catch Throwable t#
       (.outcome-error ~ctx t#))))

(defmacro boolean-test ^void [ctx form]
  `(try
     (let [form# ~form]
       (if form#
         (.outcome-pass ~ctx)
         (.outcome-fail ~ctx "expression evaluates to false"
                        (object true) (object form#))))
     (catch Throwable t#
       (.outcome-error ~ctx t#))))

;;; ------------------------------------------------------------------------

(defn- print-stack-trace ^void [^Throwable t]
  (when (some? t)
    (.printStackTrace t (java.io.PrintWriter. *out*))
    (println)))

(defn- print-header [^TestContext test-ctx ^String prefix ^int line]
  (let [line-suffix (when (>= line 0)
                      (str ":" (style/highlight-str (str line))))]
    (println prefix (str (.var-symbol test-ctx) line-suffix))))

(defn- some-output? ^boolean [^int out-start ^int out-end]
  (< out-start out-end))
(defn- print-output ^void [^TestContext test-ctx ^int out-start ^int out-end]
  (when (some-output? out-start out-end)
    (println (style/dim-str "---- output start ----"))
    (print-lines (-> test-ctx .output (.getBuffer)) out-start out-end)
    (println (style/dim-str "----- output end -----"))))

(def ^:private header-pass (style/success-str "PASS"))
(def ^:private header-fail (style/error-header-str " FAIL " "*FAIL*"))
(def ^:private header-error (style/error-header-str " ERROR " "*ERROR*"))

(deftype IsContextImpl [^TestContext test-ctx
                        ^int line    ;negative if "between" `is` forms
                        ^int out-start]
  IsContext
  (outcome-error [this ex]
    (let [out-end (.output-position test-ctx)]
      (.register-outcome test-ctx out-start out-end
                         (^Callable fn []
                          (print-header test-ctx header-error line)
                          (print-output test-ctx out-start out-end)
                          (print-stack-trace ex)
                          is-report-error))))
  (outcome-fail [this msg expected actual]
    (let [out-end (.output-position test-ctx)]
      (.register-outcome test-ctx out-start out-end 
                         (^Callable fn []
                          (print-header test-ctx header-fail line)
                          (print-output test-ctx out-start out-end)
                          (align/print-expected-actual msg expected actual)
                          is-report-fail))))
  (outcome-pass [this]
    (let [out-end (.output-position test-ctx)]
      (.register-outcome test-ctx out-start out-end
                         (^Callable fn []
                          (when (some-output? out-start out-end)
                            (print-header test-ctx header-pass line)
                            (print-output test-ctx out-start out-end))
                          is-report-pass)))))

;;; `TEST-CTX' provides context to `is` macros.
(def ^:private TEST-CTX (java.lang.ScopedValue/newInstance))

(defn is-context-if-selected ^IsContext [^int line] ;called from `is`
  (let [test-ctx ^TestContext (.get TEST-CTX)]
    (when (.test (.select-is? test-ctx) line)
      (IsContextImpl. test-ctx line (.output-position test-ctx)))))

;;; ------------------------------------------------------------------------

(defn- var-line ^Integer [^Var var] (-> var (meta) :line))
(defn- var-name ^String [^Var var] (name (symbol var)))

(defn- run-test-var ^Callable [^Var var ^IntPredicate select-is?]
  (let [test-ctx (TestContext. (symbol var) select-is?
                               (StringWriter.) (ArrayList.) 0)]
    ;; Runs the deftest function `var` with `*out*` and `*err`
    ;; redirected to the output member of `ctx`.
    (-> (java.lang.ScopedValue/where TEST-CTX test-ctx)
        (.run (^Runnable fn []
               ;; note: the unit tests of this namespace call this function
               ;; recursively, i.e. there really must be a binding that
               ;; establishes a nested context and restores the parent context
               (try
                 (binding [*out* (.output test-ctx)
                           *err* (.output test-ctx)]
                   (@var))
                 (catch Throwable t     ;any exception outside `is`
                   (let [out-pos (.output-position test-ctx)
                         oob-ctx (IsContextImpl. test-ctx -1 out-pos)]
                     (.outcome-error oob-ctx t)))))))
    
    (let [size (.output-position test-ctx)]
      (.register-outcome test-ctx size size nil)) ;capture any remaining output
    
    (^Callable fn []
     ;; print deftest outcomes only on demand
     (->> (map Callable/.call (.outcomes test-ctx))
          (add-reports test-report-empty)))))

(def ^:private select-all (^IntPredicate fn [line] true))

(defmacro ^:private with-fork [scope binding-frame & body]
  `(let [binding-frame# ~binding-frame]
     (.fork ~scope
            (^java.util.concurrent.Callable fn []
             (clojure.lang.Var/resetThreadBindingFrame binding-frame#)
             ~@body))))

(defn- run-tests* ^Report [binding-frame ^vector nmspv]
  (letfn [(nmsp-test-vars ^seq [nmsp vars] ;returns a seq of Var
            (letfn [(resolve-var [^String var]
                      (let [sym (symbol nmsp var)]
                        (or (find-var sym)
                            (throw (Exception. (str "no var found: " sym))))))]
              (sort-by var-line
                       (if (true? vars)
                         (->> (vals (ns-interns (the-ns (symbol nil nmsp))))
                              (filter #(-> % (meta) :test (true?))))
                         (map resolve-var (keys vars))))))
          (run-var-with-pred ^Callable [^map var-line-map ^Var var]
            (let [lines (var-line-map (var-name var) true)]
              (run-test-var var (if (true? lines)
                                  select-all
                                  (^IntPredicate fn [line]
                                   (contains? lines line))))))
          (collect-run-var-outcomes ^vector [^String nmsp vars]
            (let [var-line-map (if (true? vars) {} vars)
                  vars (nmsp-test-vars nmsp vars)]
              (if run-tests-as-concurrent-tasks?
                (with-open [scope (StructuredTaskScope$ShutdownOnFailure.)]
                  (let [taskv (mapv #(with-fork scope binding-frame
                                       (run-var-with-pred var-line-map %))
                                    vars)]
                    
                    (.joinUntil scope (.plusSeconds (Instant/now)
                                                    deadline-test-var-seconds))
                    (.throwIfFailed scope (Function/identity))
                    
                    (mapv StructuredTaskScope$Subtask/.get taskv)))

                ;; alternative: sequential execution
                (mapv (partial run-var-with-pred var-line-map) vars))))
          (run-nmsp ^Callable [[nmsp vars]]
            (let [outcomes (collect-run-var-outcomes nmsp vars)]
              ;; print deftest results of the whole namespace as one
              ;; block, but only on demand
              (^Callable fn []
               (let [report (->> (map Callable/.call outcomes)
                                 (add-reports report-empty))]
                 (when (all-pass? report)
                   (println (str header-pass " " nmsp "/... ("
                                 (.tests report) " tests)")))
                 report))))]
    
    ;; Print outcomes sequentially in namespace execution order, as
    ;; soon as they become available.  A long running namespace blocks
    ;; the output of all following namespaces.
    (->> (if run-tests-as-concurrent-tasks?
           (with-open [scope (StructuredTaskScope$ShutdownOnFailure.)]
             (let [n (count nmspv)
                   alatch (new CountDownLatch/1 (inc n))
                   atask (new StructuredTaskScope$Subtask/1 n)]
               (dotimes [i (alength alatch)]
                 (aset alatch i (CountDownLatch. 1)))
               (.countDown (aget alatch 0)) ;first task can print immediately
               
               (dotimes [i (alength atask)]
                 (->> (with-fork scope binding-frame
                        (let [outcome (run-nmsp (nth nmspv i))]
                          (.await (aget alatch i))
                          (let [report (.call outcome)]
                            ;; only unlock next task's output if this
                            ;; task completes successfully
                            (.countDown (aget alatch (inc i)))
                            report)))
                      (aset atask i)))
               
               (.joinUntil scope (.plusSeconds (Instant/now)
                                               deadline-namespace-seconds))
               (.throwIfFailed scope (Function/identity))
               
               (mapv StructuredTaskScope$Subtask/.get atask)))

           ;; alternative: sequential execution
           (mapv #(.call (run-nmsp %)) nmspv))
         (add-reports report-empty))))

(defn run-tests ^Report [^vector nmspv]
  (run-tests* (Var/cloneThreadBindingFrame) nmspv))
