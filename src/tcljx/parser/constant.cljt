(ns tcljx.parser.constant
  (:require
   (tcljx.data [wrong :as wrong] [type :as type] [model :as model]))
  (:import
   (tcljx.data.model Expr Parser)
   (java.lang.constant ConstantDesc ConstantDescs)
   (java.util.regex Pattern)))

;;; Given a primitive type's box class, return the primitive type.
;;; Also returns String for String, and nil for all other classes.
(defn primitive-type-of [^Class tp]
  (condp identical? tp
    ;; instances of ConstantDesc
    Integer Integer/TYPE
    Long Long/TYPE
    Float Float/TYPE
    Double Double/TYPE
    String String
    ;; not numeric and not ConstantDesc
    Boolean Boolean/TYPE
    Character Character/TYPE
    ;; numeric but not ConstantDesc
    Byte Byte/TYPE
    Short Short/TYPE
    #_else nil))

;;; Note: This function caters for a superset of the form types that
;;; are produced by the reader.  It additionally accepts some values
;;; that may be injected via macros, like Byte or Short.
(defn parse-constant-nometa ^Expr [^Parser parser form]
  ;; pre: (not (instance? IMeta form))
  (let [ef (.expr-factory parser)]
    (cond
      (nil? form)
      (model/new-constant ef ConstantDescs/NULL type/poly-reference)
      
      (instance? ConstantDesc form)
      (model/new-constant ef form (primitive-type-of (.getClass form)))
      
      (keyword? form)
      (.new-loadable ef form type/keyword)
      
      (boolean? form)
      (model/new-constant ef (int ^boolean form) Boolean/TYPE)
      
      (char? form)
      (model/new-constant ef (int ^char form) Character/TYPE)
      
      (number? form)      ;any non-ConstantDesc number: Byte and Short
      (model/new-constant ef (.intValue ^Number form)
                          (primitive-type-of (.getClass form)))

      (instance? Pattern form)
      (.new-loadable ef form Pattern)

      :else (wrong/other "unsupported literal value" (class form)))))
