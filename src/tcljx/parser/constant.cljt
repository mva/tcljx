(ns tcljx.parser.constant
  (:require (tcljx.data [wrong :as wrong] [type :as type] [model :as model]))
  (:import (tcljx.data.model Scope Expr)
           (java.lang.constant ConstantDesc ConstantDescs)))

(defn parse-constant ^Expr [^Scope scope form]
  ;; pre: (not (instance? IMeta form))
  (letfn [(const-desc-tp ^Class [form]
            (condp instance? form
              Integer Integer/TYPE
              Long Long/TYPE
              Float Float/TYPE
              Double Double/TYPE
              String String
              #_else (throw (IllegalArgumentException.))))
          (comp-int-tp ^Class [form]      ;pre: form is not ConstantDesc
            (condp instance? form
              Byte Byte/TYPE
              Short Short/TYPE
              #_else (throw (IllegalArgumentException.))))]
    (let [ef (.expr-factory scope)]
      (cond
        (nil? form)
        (.new-constant ef type/poly-reference ConstantDescs/NULL)
        
        (instance? ConstantDesc form)
        (.new-constant ef (const-desc-tp form) form)
        
        (keyword? form)
        (assert false) #_(compile-named form rt/clnm-keyword ctx)
        
        (boolean? form)
        (.new-constant ef Boolean/TYPE form)
        
        (char? form)
        (.new-constant ef Character/TYPE (object (int ^char form)))
        
        (number? form)
        (.new-constant ef (comp-int-tp form) (object (.intValue ^Number form)))
        
        :else
        (.new-constant ef (class form) form))))) ;Class and Pattern
