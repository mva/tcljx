(ns tcljx.parser.constant
  (:require
   (tcljx.data [wrong :as wrong] [type :as type] [model :as model]
               [reflect :as reflect] [resolve :as resolve]))
  (:import
   (tcljx.data.model Expr Parser)
   (java.lang.constant ConstantDesc ConstantDescs)
   (java.util.regex Pattern PatternSyntaxException)))

;;; Given a primitive type's box class, return the primitive type.
;;; Also returns String for String, and nil for all other classes.
(defn primitive-type-of [^Class tp]
  (condp identical? tp
    ;; instances of ConstantDesc
    Integer Integer/TYPE
    Long Long/TYPE
    Float Float/TYPE
    Double Double/TYPE
    String String
    ;; not numeric and not ConstantDesc
    Boolean Boolean/TYPE
    Character Character/TYPE
    ;; numeric but not ConstantDesc
    Byte Byte/TYPE
    Short Short/TYPE
    #_else nil))

;;; Note: This function caters for a superset of the form types that
;;; are produced by the reader.  It additionally accepts common values
;;; that may be injected via macros, like Class or Byte.
(defn parse-constant-nometa ^Expr [^Parser parser form]
  ;; pre: (not (instance? IMeta form))
  (let [ef (.expr-factory parser)]
    (cond
      (nil? form)
      (model/new-constant ef ConstantDescs/NULL type/poly-reference)
      
      (instance? ConstantDesc form)
      (model/new-constant ef form (primitive-type-of (.getClass form)))
      
      (keyword? form)
      (.new-loadable ef form type/keyword)
      
      (boolean? form)
      (model/new-constant ef (int ^boolean form) Boolean/TYPE)
      
      (char? form)
      (model/new-constant ef (int ^char form) Character/TYPE)
      
      (number? form)         ;any non-ClassDesc number: Byte and Short
      (model/new-constant ef (.intValue ^Number form)
                          (primitive-type-of (.getClass form)))

      (class? form)
      (model/new-constant ef form Class)
      
      :else
      ;; Pattern, using the *reference* object's class as
      ;; type (anything Constable works as well during emit)
      (.new-loadable ef form (class form)))))

(defn regex-literal ^Expr [^Parser parser ^String pattern]
  (try
    (.new-loadable (.expr-factory parser) (Pattern/compile pattern) Pattern)
    (catch PatternSyntaxException e
      (throw (wrong/wr-info (str "invalid regex " (wrong/q pattern)) {} e)))))
