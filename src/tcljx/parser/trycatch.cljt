(ns tcljx.parser.trycatch
  (:require
   (tcljx.data [context :as context] [model :as model])
   (tcljx.parser [syntax :as syntax] [interop :as interop]))
  (:import
   (tcljx.data.model CodeEmitter Expr Exprs Binding Scope)))

(deftype CatchBinding [^Expr bnd-x ^Class ctp]) ;FIXME... Valhalla value
(letfn [(finally-form? ^boolean [x]
          (and (seq? x) (= (first x) 'finally)))
        (catch-form? ^boolean [x]
          (and (seq? x) (= (first x) 'catch)))
        (body-form? ^boolean [x]
          (not (catch-form? x)))

        (parse-finally ^Exprs [^Scope scope ^long fctx ^seq form]
          (when (some? form)
            (let [fctx (bit-and-not fctx context/flag-statm-position)
                  xs (context/new-exprs scope 2)]
              ;; parse finally twice: first copy is attached to the
              ;; end of the `try`'s body, the second is placed in the
              ;; wildcard exception handler before the ATHROW
              (.set xs 0 (context/parse-progn scope form fctx (next form)))
              (.set xs 1 (context/parse-progn scope form fctx (next form)))
              xs)))
        (parse-binding ^CatchBinding [^Scope scope ^long fctx [_ tp nm :as form]]
          (when-not (catch-form? form)
            (throw (syntax/info "expect catch clause" form)))
          (let [ctp (-> (context/parse-form scope fctx tp)
                        (model/type-literal tp))]
            (when (or (nil? ctp) (not (.isAssignableFrom Throwable ctp)))
              (throw (syntax/info "expect caught exception type" tp)))
            (-> (.new-catching-local (.expr-factory scope) fctx ctp
                                     (syntax/simple-symbol-str nm))
                (CatchBinding. ctp))))
        (block-handler ^Expr [^Scope scope ^Expr bnd-x ^long fctx ^seq body]
          ;; `block-let` implies that there is no information during
          ;; code generation whether `body` throws
          (let [bnd-xs (context/new-exprs scope 1)]
            (.set bnd-xs 0 bnd-x)
            (.block-let (.expr-factory scope) fctx bnd-xs
                        (-> (context/with-local-binding scope bnd-x)
                            (context/parse-progn fctx body)))))
        (parse-try-catch ^Expr [^Scope scope ^long fctx ^seq formr
                                ^seq finally-form]
          (let [[body-forms catch-forms] (split-with body-form? formr)
                body (context/parse-progn scope fctx body-forms)]
            (cond
              (seq catch-forms)
              (let [ctps (new Class/1 (count catch-forms))
                    b+cs (context/new-exprs scope (inc (alength ctps)))]
                (.set b+cs 0 body)
                (loop [[catch-form & catch-formr] catch-forms, i 1]
                  (when (< i (.length b+cs))
                    (context/with-line-from-list [fctx catch-formr]
                      (let [cb (parse-binding scope fctx catch-form)
                            body (nthnext catch-form 3)]
                        (aset ctps (dec i) (.ctp cb))
                        (.set b+cs i (block-handler scope (.bnd-x cb) fctx body))))
                    (recur catch-formr (inc i))))
                (.try-catch-finally (.expr-factory scope) fctx
                                    b+cs ctps
                                    (parse-finally scope fctx finally-form)))

              (some? finally-form)
              (let [body-xs (context/new-exprs scope 1)]
                (.set body-xs 0 body)
                (.try-catch-finally (.expr-factory scope) fctx
                                    body-xs (new Class/1 0)
                                    (parse-finally scope fctx finally-form)))

              :else body)))]
  
  (defn parse-try ^Expr [^Scope scope ^long fctx [_ & formr]]
    (let [fctx (bit-and-not fctx context/flag-can-recur) ;assume closure
          lst (last formr)]
      (if (finally-form? lst)
        (parse-try-catch scope fctx (butlast formr) lst)
        (parse-try-catch scope fctx formr nil)))))
