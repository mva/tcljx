(ns tcljx.parser.trycatch
  (:require
   (tcljx.data [wrong :as wrong] [model :as model])
   (tcljx.parser [syntax :as syntax] [interop :as interop] [context :as context])
   (tcljx.classgen [insn :as insn]))
  (:import
   (tcljx.data.model CodeEmitter Expr Binding Scope)
   (tcljx.classgen.insn Insn)))

(deftype CatchBinding [^Insn bnd-x ^Class ctp]) ;FIXME... Valhalla value
(letfn [(finally-form? ^boolean [x]
          (and (seq? x) (= (first x) 'finally)))
        (catch-form? ^boolean [x]
          (and (seq? x) (= (first x) 'catch)))
        (body-form? ^boolean [x]
          (not (catch-form? x)))

        (parse-finally ^Insn [^Scope scope ^long fctx ^seq form]
          (when (some? form)
            (wrong/with-line-from-list [fctx  form]
              (context/parse-progn scope fctx (next form)))))
        (parse-binding ^CatchBinding [^Scope scope ^long fctx [_ tp nm :as form]]
          (when-not (catch-form? form)
            (throw (syntax/info "expect catch clause" form)))
          (let [ctp (-> (context/parse-form scope fctx tp)
                        (model/type-expression tp))]
            (when (or (nil? ctp) (not (.isAssignableFrom Throwable ctp)))
              (throw (syntax/info "expect caught exception type" tp)))
            (CatchBinding. (.new-local (.expr-factory scope) fctx ctp
                                       (syntax/simple-symbol-str nm)
                                       (-> (^CodeEmitter fn [_ _ _] ctp)
                                           (insn/mk-insn ctp)))
                           ctp)))
        (block-handler ^Insn [^Scope scope ^Insn bnd-x ^long fctx ^seq body]
          ;; `block-let` implies that there is no information during
          ;; code generation whether `body` throws
          (.block-let (.expr-factory scope) fctx (insn/insns-of bnd-x)
                      (-> (context/with-local-binding scope bnd-x)
                          (context/parse-progn fctx body))))
        (parse-try-catch ^Insn [^Scope scope ^long fctx ^seq formr
                                ^seq finally-form]
          (let [[body-forms catch-forms] (split-with body-form? formr)
                body (context/parse-progn scope fctx body-forms)]
            (cond
              (seq catch-forms)
              (let [ctps (new Class/1 (count catch-forms))
                    b+cs (context/new-exprs scope (inc (alength ctps)))]
                (.set b+cs 0 body)
                (loop [[catch-form & catch-formr] catch-forms, i 1]
                  (when (< i (.length b+cs))
                    (wrong/with-line-from-list [fctx catch-formr]
                      (let [cb (parse-binding scope fctx catch-form)
                            body (nthnext catch-form 3)]
                        (aset ctps (dec i) (.ctp cb))
                        (.set b+cs i (block-handler scope (.bnd-x cb) fctx body))))
                    (recur catch-formr (inc i))))
                (.try-catch-finally (.expr-factory scope) fctx
                                    b+cs ctps
                                    (parse-finally scope fctx finally-form)))

              (some? finally-form)
              (.try-catch-finally (.expr-factory scope) fctx
                                  (insn/insns-of body) (new Class/1 0)
                                  (parse-finally scope fctx finally-form))

              :else body)))]
  
  (defn parse-try ^Expr [^Scope scope ^long fctx [_ & formr]]
    (let [lst (last formr)]
      (if (finally-form? lst)
        (parse-try-catch scope fctx (butlast formr) lst)
        (parse-try-catch scope fctx formr nil)))))
