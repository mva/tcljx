(ns tcljx.parser.fn
  (:require
   (tcljx.data [wrong :as wrong] [context :as context] [type :as type]
               [model :as model] [resolve :as resolve] [reflect :as reflect])
   (tcljx.parser [parse :as parse] [syntax :as syntax] [interop :as interop]
                 [loop :as loop]))
  (:import
   (tcljx.data.model Expr Exprs Entity Binding ExprFactory ArityType AritySpec
                     MethodSpec Parser ParseArityBody Resolver)
   (tcljx.data.resolve Match)
   (java.lang.constant MethodHandleDesc ConstantDescs)
   (java.lang.reflect Method)
   (java.util Arrays Comparator)))

(defn- fixup-arity-type ^ArityType [^ArityType at ^Method m]
  (let [unhinted? (interop/unhinted-arity-type? at 0)
        resolve (fn ^Class [^Class at-tp ^Class method-tp]
                  (or at-tp (if unhinted? method-tp Object)))
        rtype (let [mtype (.getReturnType m)
                    rtype (resolve (.return-type at) mtype)]
                (when-not (type/jvm-assignable-from? mtype rtype)
                  (wrong/other (str "function result " (wrong/q rtype)
                                    " not assignment compatible to method's "
                                    (wrong/q mtype))))
                rtype)
        pclasses (.getParameterTypes m)
        aparam-tp (new Class/1 (.parameter-count at))]
    (dotimes [i (alength aparam-tp)]
      (let [pclass (aget pclasses i)
            dclass (resolve (aget (.parameter-types at) i) pclass)]
        (if (type/jvm-assignable-from? pclass dclass)
          (aset aparam-tp i dclass)
          (wrong/other (str "function parameter " (wrong/q dclass)
                            " not assignment compatible to "
                            "method's " (wrong/q pclass))))))
    (when-not (= (.varargs? at) (.isVarArgs m))
      (wrong/other "interface and function disagree on varargs status"))
    (model/with-return-type at rtype aparam-tp)))

(defn- itf-method ^Method [^AritySpec/1 specs ^Class itf-class]
  (when-not (= (alength specs) 1)
    (wrong/other "interface function must implement exactly one arity"))
  (let [an (-> (aget specs 0) .at .parameter-count)]
    (or (first (->> (resolve/itf-methods itf-class)
                    (filter #(= (Method/.getParameterCount %) an))))
        (wrong/other (str "interface " (wrong/q itf-class)
                          " has no method of arity " an)))))

(defn- fixup-arity-specs-from-itf ^AritySpec/1 [^AritySpec/1 specs ^Method m]
  (let [spec (aget specs 0)]
    (aset specs 0 (AritySpec. (fixup-arity-type (.at spec) m)
                              (.body spec) (.error-context spec)))
    specs))

(defn- arity-specs-of ^AritySpec/1 [^Resolver rsv ^long fctx ^seq form
                                    ^Class or-else-type ^boolean unnamed-fn?
                                    ^seq more]
  (letfn [(max-parameter-count ^int [^AritySpec/1 specs]
            (loop [n 0, i (dec (alength specs))]
              (if (neg? i)
                n
                (recur (max n (-> (aget specs i) .at .parameter-count))
                       (dec i)))))
          (arity-spec-of ^AritySpec [paramv ^seq body ^seq error-context]
            (context/with-line-from-list [fctx error-context]
              (-> (interop/parse-arity-type rsv paramv or-else-type unnamed-fn?)
                  (AritySpec. body error-context))))
          
          (specs-1 ^AritySpec/1 [paramv ^seq body ^seq error-context]
            (doto (new AritySpec/1 1)
              (aset 0 (arity-spec-of paramv body error-context))))
          (specs-n ^AritySpec/1 [^seq arity-seq] ;pre: `arity-seq` is not empty
            (let [n (count arity-seq)
                  specs (new AritySpec/1 n)]
              (loop [seen-ns #{}, seen-va -1, i 0,
                     [[paramv & body :as arity] & arity-r] arity-seq]
                (if (< i n)
                  (if (seq? arity)
                    (let [spec (arity-spec-of paramv body arity)
                          at (.at spec)
                          n (.parameter-count at)
                          va (if (model/translates-to-varargs? at) i -1)]
                      (when (contains? seen-ns n)
                        (wrong/other (str "multiple function arities "
                                          "with " n " parameters")))
                      (when (and (>= va 0) (>= seen-va 0))
                        (wrong/other (str "multiple variadic function "
                                          "arities")))
                      (aset specs i spec)
                      (recur (conj seen-ns n) va (inc i) arity-r))
                    (throw (syntax/info "expect function arity ([...] ...)"
                                        arity)))
                  
                  (when (and (>= seen-va 0)
                             (not= (max-parameter-count specs) seen-va))
                    (wrong/other "only maximum arity can be variadic"))))
              specs))]
    
    (let [[h & t] more]
      (if (seq? h)                      ;arity in parenthesis?
        (if (some? t)                   ;more than one arity?
          (specs-n more)
          (specs-1 (first h) (next h) h))
        (specs-1 h t form)))))          ;single inlined arity

(defn mk-parse-arity-body ^ParseArityBody [^long fctx ^boolean inst-method?]
  (^ParseArityBody fn [parser aspec source-idx]
   (let [pbnds (model/parameter-bindings parser (.at aspec))
         pvars (loop/binding-variables pbnds)
         rvars (cond-> pvars
                 inst-method?
                 ^Entity/1 (Arrays/copyOfRange 1 (alength pvars)))
         fctx' (context/with-recur context/fctx-initial)
         parser' (-> (model/with-local-bindings parser pbnds)
                     (.with-recur-variables rvars))
         x-body (parse/progn parser' (.error-context aspec) fctx' (.body aspec))
         code (.emitter-method (.expr-factory parser') fctx x-body)]
     (MethodSpec. (.at aspec) code x-body pvars source-idx
                  (when inst-method?
                    (-> aspec .error-context (first) (name)))))))

(defn parse-fn* ^Expr [^Parser parser ^long fctx ^seq form]
  (letfn [(new-fn ^Expr [^symbol fn-nm ^Class itf-class ^seq more]
            (let [rsv (.resolver parser)
                  pab (mk-parse-arity-body fctx false)]
              (if (nil? itf-class)
                (let [specs (arity-specs-of rsv fctx form Object
                                            (nil? fn-nm) more)] 
                  (.new-function (.expr-factory parser) parser pab fn-nm
                                 specs))
                (let [specs (arity-specs-of rsv fctx form nil true more)
                      m (itf-method specs itf-class)]
                  (.new-itf-fn (.expr-factory parser) parser pab itf-class
                               (reflect/mhd-of-method itf-class m)
                               (fixup-arity-specs-from-itf specs m))))))]
    (let [itf-tag (interop/tag-of (first form))
          fn-nm (second form)]
      (if (symbol? fn-nm)
        (do (when (some? (interop/tag-of fn-nm))
              (wrong/other "type tag on function name is not supported"))
            (when (some? itf-tag)
              (wrong/other "interface function cannot have a name"))
            (new-fn (syntax/simple-symbol fn-nm) nil (nnext form)))
        (if (some? itf-tag)
          (let [itf (interop/resolve-interface (.resolver parser)
                                               (syntax/symbol itf-tag))]
            (new-fn nil itf (next form)))
          (new-fn nil nil (next form)))))))
