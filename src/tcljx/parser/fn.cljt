(ns tcljx.parser.fn
  (:require
   (tcljx.data [wrong :as wrong] [type :as type] [model :as model]
               [resolve :as resolve] [reflect :as reflect])
   (tcljx.parser [syntax :as syntax] [context :as context]
                 [interop :as interop]))
  (:import
   (tcljx.data.model Expr Exprs ExprFactory ArityType Scope Resolver)
   (tcljx.data.resolve Match)
   (java.lang.constant MethodHandleDesc ConstantDescs)
   (java.lang.reflect Method Constructor Field)))

#_(definterface ArityMethod
  (at ^ArityType [])

  ;; The "external" method and the "implementation" method differ if
  ;; there is a bridge method mapping vararg `Object...` to variadic
  ;; `ISeq`.
  (load-mh-ext ^DirectMethodHandleDesc [])
  (load-mh-impl ^DirectMethodHandleDesc []))

#_(deftype ArityMethodImpl [^ArityType at
                          ^DirectMethodHandleDesc load-mh-ext
                          ^DirectMethodHandleDesc load-mh-impl]
  java.lang.Record
  ArityMethod)

;;; ------------------------------------------------------------------------

(defn redirection ^MethodHandleDesc [^Resolver rsv ^ArityType at
                                     [op :as ^seq form]]
  (letfn [(resolves-to-class ^Class [^String nm]
            (when (and (some? nm) (nil? (.lookup-namespace rsv nm)))
              (.lookup-class rsv nm)))
          (dot-member-args ^seq [[_ _ & [x :as xs]]]
            (let [[member :as tail] (if (and (= (count xs) 1) (seq? x)) x xs)]
              (when (syntax/simple-symbol? member)
                tail)))
          (parameters-in-sequence? ^boolean [^seq form-args]
            (let [pnames (.parameter-names at)]
              (loop [[arg :as args] form-args, i 0]
                (if (< i (alength pnames))
                  (if (and (syntax/simple-symbol? arg)
                           (nil? (interop/tag-of arg))
                           (= (name arg) (aget pnames i)))
                    (recur (rest args) (inc i))
                    false)              ;does not match parameter list
                  ;; number of arguments matches number of parameters,
                  ;; and no pathological duplicate argument names
                  (and (nil? (seq args)) (= form-args (distinct form-args)))))))
          (member-mhd ^MethodHandleDesc [^Class owner ^String mnm ^seq args]
            (when (parameters-in-sequence? args)
              (let [ms (resolve/members-by-param-tags true owner mnm
                                                      (.parameter-types at))]
                (when (and (some? (seq ms)) (nil? (next ms)))
                  ;; FIXME... varargs flag must also match the arity signature
                  (let [m ^Match (first ms)
                        mode (.invocation-mode m)
                        member (.member m)]
                    (when (and (not= mode resolve/invoke-polymorphic)
                               (= (.varargs? at)
                                  (= mode resolve/invoke-tail-into-array)))
                      (condp instance? member
                        Method (reflect/mhd-of-method owner member)
                        Constructor (reflect/mhd-of-constructor owner member)
                        Field (reflect/mhd-of-field owner member))))))))]

    ;; Important: Working on the syntax level is brittle.  There are
    ;; many syntactically different ways to redirect to a method or
    ;; field, both static and virtual.  Every supported syntax variant
    ;; should have a matching test in tcljx.parser.redirection-test.
    (when (and (nil? (interop/tag-of form)) (symbol? op))
      (let [mhd (if (= op '.)
                  ;; dot form (. Classname member ...)
                  ;; dot form (. Classname (member ...))
                  (when (syntax/simple-symbol? (second form))
                    (when-some [cl (resolves-to-class (name (second form)))]
                      (when-some [[member-sym & args] (dot-member-args form)]
                        (member-mhd cl (name member-sym) args))))
                  ;; invoke static (Classname/member ...)
                  (when-some [cl (resolves-to-class (namespace op))]
                    (when (nil? (interop/param-tags-of op))
                      (member-mhd cl (name op) (rest form)))))
            auto? (type/auto-return-marker? (.return-type at))]
        (when (some? mhd)
          (when (= (cond-> (.invocationType mhd)
                     auto? (.changeReturnType ConstantDescs/CD_void))
                   (cond-> (model/mtd-of-arity-type at)
                     auto? (.changeReturnType ConstantDescs/CD_void)))
            mhd))))))

;;; ------------------------------------------------------------------------

(defn parse-arity-body ^Expr [^Scope scope ^seq error-context
                              ^Exprs param-bindings ^long fctx ^seq body]
  (.progn-expr (.expr-factory scope) param-bindings
               (-> (context/with-local-bindings scope param-bindings)
                   (context/parse-progn error-context fctx body))))

(defn parse-fn* ^Expr [^Scope scope ^long fctx
                       [_ fn-nm paramv & body :as ^seq form]]
  (let [fn-nm (syntax/simple-symbol-str fn-nm)
        mangled-nm (context/pick-unique-name scope fn-nm)
        at (interop/parse-arity-type (.resolver scope) fctx paramv form)
        pbnds (model/parameter-bindings scope at)
        code (parse-arity-body scope form pbnds fctx body)
        redir (when (nil? (next body))
                (let [form (first body)]
                  (when (and (and  (seq? form)) (nil? (interop/tag-of form)))
                    (redirection (.resolver scope) at form))))
        ef (.expr-factory scope)]
    (.new-function ef
                   mangled-nm
                   (doto (new ArityType/1 1) (aset 0 at))
                   (doto (.new-exprs ef 1) (.set 0 code))
                   (doto (new MethodHandleDesc/1 1) (aset 0 redir)))))
