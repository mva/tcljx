(ns tcljx.parser.fn
  (:require
   (tcljx.data [wrong :as wrong] [context :as context] [type :as type]
               [model :as model] [resolve :as resolve] [reflect :as reflect])
   (tcljx.parser [syntax :as syntax] [interop :as interop] [loop :as loop]))
  (:import
   (tcljx.data.model Expr Exprs ExprFactory ArityType AritySpec Parser Resolver)
   (tcljx.data.resolve Match)
   (java.lang.constant MethodHandleDesc ConstantDescs)
   (java.util Arrays Comparator)
   (java.util.function BiFunction)))

(defn parse-fn* ^Expr [^Parser parser ^long fctx ^seq form]
  (letfn [(max-parameter-count ^int [^AritySpec/1 specs]
            (loop [n 0, i (dec (alength specs))]
              (if (neg? i)
                n
                (recur (max n (-> (aget specs i) .at .parameter-count))
                       (dec i)))))
          (parse-arity ^AritySpec [paramv ^seq body ^seq error-context ^int i]
            (context/with-line-from-list [fctx error-context]
              (let [at (interop/parse-arity-type (.resolver parser) paramv)]
                (AritySpec. at body nil error-context nil i))))
          (specs-1 ^AritySpec/1 [paramv ^seq body ^seq error-context]
            (doto (new AritySpec/1 1)
              (aset 0 (parse-arity paramv body error-context 0))))
          (specs-n ^AritySpec/1 [^seq arity-seq] ;pre: `arity-seq` is not empty
            (let [n (count arity-seq)
                  specs (new AritySpec/1 n)]
              (loop [seen-ns #{}, seen-va -1, i 0,
                     [[paramv & body :as arity] & arity-r] arity-seq]
                (if (< i n)
                  (if (seq? arity)
                    (let [spec (parse-arity paramv body arity i)
                          at (.at spec)
                          n (.parameter-count at)
                          va (if (model/translates-to-varargs? at) i -1)]
                      (when (contains? seen-ns n)
                        (wrong/other (str "multiple function arities "
                                          "with " n " parameters")))
                      (when (and (>= va 0) (>= seen-va 0))
                        (wrong/other (str "multiple variadic function "
                                          "arities")))
                      (aset specs i spec)
                      (recur (conj seen-ns n) va (inc i) arity-r))
                    (throw (syntax/info "expect function arity ([...] ...)"
                                        arity)))
                  
                  (when (and (>= seen-va 0)
                             (not= (max-parameter-count specs) seen-va))
                    (wrong/other "only maximum arity can be variadic"))))
              (->> (^Comparator fn ^int [^AritySpec o1 ^AritySpec o2]
                    (Integer/compare (-> o1 .at .parameter-count)
                                     (-> o2 .at .parameter-count)))
                   (Arrays/sort specs))
              specs))
          (new-fn ^Expr [^symbol fn-nm [h & t :as ^seq more]]
            (let [pab (^BiFunction fn ^Expr [^Parser parser ^AritySpec spec]
                       (let [pbnds (model/parameter-bindings parser (.at spec))]
                         (-> (model/with-local-bindings parser pbnds)
                             (loop/parse-loop-body (.error-context spec)
                                                   fctx pbnds (.body spec)))))]
              (.new-function (.expr-factory parser) parser fn-nm pab
                             (if (seq? h)    ;arity in parenthesis?
                               (if (some? t) ;more than one arity?
                                 (specs-n more)
                                 (specs-1 (first h) (next h) h))
                               (specs-1 h t form)))))] ;single inlined arity
    (let [fn-nm (second form)]
      (if (symbol? fn-nm)
        (new-fn (syntax/simple-symbol fn-nm) (nnext form))
        (new-fn nil (next form))))))
