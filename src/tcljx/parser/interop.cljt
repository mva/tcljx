(ns tcljx.parser.interop
  (:require
   (tcljx [type :as type] [model :as model])
   (tcljx.parser [wrong :as wrong] [syntax :as syntax]))
  (:import
   (tcljx.model Resolver ArityType)
   (clojure.lang IMeta)))

;;; Returns nil if lookup fails.
(defn lookup-type ^Class [^Resolver rsv ^symbol tp]
  (letfn [(spec-dimensions ^int [^String nm] ;zero if not name of array type
            (when (= (.length nm) 1)
              (let [n (- (int (.charAt nm 0)) (int \0))]
                (when (<= 1 n 9)
                  n))))]
    (let [nm (name tp)]
      (if-some [nmsp (namespace tp)]
        (let [n (spec-dimensions nm)]
          (when (pos? n)
            (type/array-type-of-class (.lookup-class rsv nmsp) n)))
        (.lookup-class rsv nm)))))

;;; ------------------------------------------------------------------------

(defn get-tag [^map form-meta]
  (when (some? form-meta)
    ;; Note: using `valAt` is slightly more direct than IFn.invoke()
    ;; or RT.get().
    (.valAt form-meta :tag nil)))
(defn tag-of ^symbol [form]
  (when-some [tag (get-tag (meta form))]
    (syntax/symbol tag)))
(defn resolve-tag* ^Class [^Resolver rsv ^symbol tag ^Class or-else]
  (if (some? tag)
    (or (lookup-type rsv tag) (wrong/class-not-found tag))
    or-else))
(defn resolve-tag
  (^Class [^Resolver rsv ^IMeta form]
   (resolve-tag rsv form Object))
  (^Class [^Resolver rsv ^IMeta form ^Class or-else]
   (resolve-tag* rsv (tag-of form) or-else)))

(defn get-param-tags [^map form-meta]
  (when (some? form-meta)
    (.valAt form-meta :param-tags nil)))
(defn param-tags-of ^vector [form]
  (when-some [ptags (get-param-tags (meta form))]
    (syntax/vector ptags)))


;;; If `paramv` is tagged with `auto-return-type`, then the arity's
;;; return type is set to the temporary `auto-return-marker`.
(defn parse-arity-type ^ArityType [^Resolver rsv paramv ^seq error-context]
  (wrong/with-line-context error-context
    (let [paramv (syntax/vector paramv)
          n (count paramv)
          ptypes (new Class/1 n)
          pnames (new String/1 n)]
      (assert (not= '& (nth paramv (- n 2) nil)))
      (dotimes [i (alength ptypes)]
        (let [param (nth paramv i)
              psym (syntax/simple-symbol param)]
          (aset ptypes i (resolve-tag rsv psym))
          (aset pnames i (name psym))))
      (let [return-tag (tag-of paramv)]
        (-> (if (= 'auto-return-type return-tag)
              type/auto-return-marker
              (resolve-tag* rsv return-tag Object))
            (tcljx.model.ArityTypeImpl. ptypes pnames))))))
