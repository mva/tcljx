(ns tcljx.parser.interop
  (:require
   (tcljx.data [meta :as meta] [type :as type] [resolve :as resolve]
               [wrong :as wrong] [context :as context] [model :as model])
   (tcljx.parser [syntax :as syntax]))
  (:import
   (tcljx.data.resolve Match)
   (tcljx.data.model Resolver Expr Entity ExprFactory Parser ArityType)
   (clojure.lang IMeta)))

(defn array-rank ^int [^String nm] ;returns 0 if not in [1-9]
  (when (= (.length nm) 1)
    (let [ch (int (.charAt nm 0))]
      (when (<= (int \1) ch (int \9))
        (- ch (int \0))))))

;;; Returns nil if lookup fails.  The three argument arity returns an
;;; array type if class `cl` is provided and `nm` is a digit
;;; matching [1-9].
(defn lookup-type
  (^Class [^Resolver rsv ^symbol tp]
   (let [nm (name tp)]
     (if-some [nmsp (namespace tp)]
       (lookup-type rsv (.lookup-class rsv nmsp) nm)
       (.lookup-class rsv nm))))
  (^Class [^Resolver rsv ^Class cl ^String nm] ;nil if `cl` is nil
   (when (some? cl)
     (let [n (array-rank nm)]
       (when (pos? n)
         (type/array-type-of-class cl n))))))

;;; ------------------------------------------------------------------------

(defn tag-of ^symbol [form]
  (when-some [tag (meta/get-tag (meta form))]
    (syntax/symbol tag)))
(defn resolve-tag* ^Class [^Resolver rsv ^symbol tag ^Class or-else]
  (if (some? tag)
    (or (lookup-type rsv tag) (throw (wrong/info-class-not-found tag)))
    or-else))
(defn resolve-tag
  (^Class [^Resolver rsv ^IMeta form]
   (resolve-tag rsv form Object))
  (^Class [^Resolver rsv ^IMeta form ^Class or-else]
   (resolve-tag* rsv (tag-of form) or-else)))

(defn get-param-tags ^Object [^map form-meta] ;nil if no param tags are given
  (when (some? form-meta)
    (.valAt form-meta :param-tags nil)))
(defn param-tags-of ^vector [form]
  (when-some [ptags (get-param-tags (meta form))]
    (syntax/vector ptags)))

;;; ------------------------------------------------------------------------

(defn parse-type-symbol ^Class [^Resolver resolver form]
  (let [sym (syntax/symbol form)]
    (or (lookup-type resolver sym)
        (throw (syntax/info "expected type expression" form)))))

(defn cast-to-tag ^Expr [^Expr x ^Parser parser ^long fctx tag]
  (let [tp (parse-type-symbol (.resolver parser) tag)]
    (.type-cast (.expr-factory parser) fctx tp x)))

(defn- class-member-match ^Match [^boolean static? ^Class owner ^String mnm
                                  ^Class/1 ptags]
  (let [ms (resolve/members-by-param-tags static? owner mnm ptags)
        wr-info (fn ^Throwable []
                  (let [sym (wrong/q-as-symbol owner mnm)]
                    (-> (if (and static? (= resolve/constructor-name mnm))
                          (if (seq ms)
                            (str "multiple constructors matching " sym)
                            (str "no constructor matching " sym))
                          (let [label (if static? "static" "virtual")]
                            (if (seq ms)
                              (str "multiple " label " members matching " sym)
                              (str "no " label " member matching " sym))))
                        (wrong/wr-info))))]
    (let [m ^Match (first ms)]
      (if (and (some? m) (nil? (next ms)))
        m
        (throw (wr-info))))))

(letfn [(parse-param-tags ^Class/1 [^Object ptags ^Resolver resolver]
          (when (some? ptags)
            (let [ptags (syntax/vector ptags)
                  a (new Class/1 (count ptags))]
              (dotimes [i (alength a)]
                (let [sym (nth ptags i)]
                  (aset a i (if (= sym '_)
                              type/polymorphic
                              (parse-type-symbol resolver sym)))))
              a)))
        (resolve ^Match [^Class owner ^String nm ^Class/1 ptags]
          (if (.startsWith nm ".")
            (class-member-match false owner (.substring nm 1) ptags)
            (class-member-match true owner nm ptags)))
        (lookup ^Object [^Resolver rsv ^ExprFactory ef ^symbol sym]
          (let [nm (name sym)]
            (if-some [nmsp (namespace sym)]
              (when-some [cl (.lookup-class rsv nmsp)]
                (if-some [tp (lookup-type rsv cl nm)]
                  (.constant-entity ef tp Class) ;array type
                  (let [ptags (-> (get-param-tags (.meta sym))
                                  (parse-param-tags rsv)) m (resolve cl nm ptags)
                        ent (.class-member-entity ef m)]
                    (if (and (nil? ptags) (resolve/static-field? m))
                      (.invoke* ent context/fctx-none nil nil 0
                                (.new-exprs ef 0))
                      ent))))
              (when-some [cl (.lookup-class rsv nm)]
                (.constant-entity ef cl Class)))))]
  
  (defn lookup-class-entity ^Entity [^Parser parser ^symbol sym]
    (let [x (lookup (.resolver parser) (.expr-factory parser) sym)]
      (when (instance? Entity x)        ;filter out getstatic
        x)))
  (defn lookup-class-expr ^Expr [^Parser parser ^symbol sym]
    (let [ef (.expr-factory parser)
          x (lookup (.resolver parser) ef sym)]
      (if (instance? Entity x)
        (.value-of ef x sym)
        x))))                           ;pass through getstatic

;;; ------------------------------------------------------------------------

;;; If `paramv` is tagged with `auto-return-type`, then the arity's
;;; return type is set to the temporary `auto-return-marker`.
(defn parse-arity-type
  (^ArityType [^Resolver rsv paramv]
   (let [paramv (syntax/vector paramv)
         n (count paramv)
         ptypes (new Class/1 n)
         pnames (new String/1 n)
         varargs? false]               ;FIXME...
     (assert (not= '& (nth paramv (- n 2) nil)))
     (dotimes [i (alength ptypes)]
       (let [param (nth paramv i)
             psym (syntax/simple-symbol param)]
         (aset ptypes i (resolve-tag rsv psym))
         (aset pnames i (name psym))))
     (let [return-tag (tag-of paramv)]
       (-> (if (= meta/auto-return-type return-tag)
             type/auto-return-marker
             (resolve-tag* rsv return-tag Object))
           (ArityType. ptypes pnames varargs?)))))
  (^ArityType [^Resolver rsv ^long fctx paramv
               ^seq error-context]
   (context/with-line-from-list [fctx error-context]
     (parse-arity-type rsv paramv))))
