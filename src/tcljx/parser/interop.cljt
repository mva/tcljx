(ns tcljx.parser.interop
  (:require
   (tcljx.data [meta :as meta] [type :as type] [resolve :as resolve]
               [wrong :as wrong] [context :as context] [model :as model])
   (tcljx.parser [syntax :as syntax]))
  (:import
   (tcljx.data.resolve Match)
   (tcljx.data.model Resolver Expr Entity ExprFactory Parser ArityType)
   (clojure.lang IMeta)
   (java.lang.reflect Method)))

(defn array-rank ^int [^String nm] ;returns 0 if not in [1-9]
  (when (= (.length nm) 1)
    (let [ch (int (.charAt nm 0))]
      (when (<= (int \1) ch (int \9))
        (- ch (int \0))))))

;;; Returns nil if lookup fails.  The three argument arity returns an
;;; array type if class `cl` is provided and `nm` is a digit
;;; matching [1-9].
(defn lookup-type
  (^Class [^Resolver rsv ^symbol tp]
   (let [nm (name tp)]
     (if-some [nmsp (namespace tp)]
       (lookup-type rsv (.lookup-class rsv nmsp) nm)
       (.lookup-class rsv nm))))
  (^Class [^Resolver rsv ^Class cl ^String nm] ;nil if `cl` is nil
   (when (some? cl)
     (let [n (array-rank nm)]
       (when (pos? n)
         (type/array-type-of-class cl n))))))

;;; ------------------------------------------------------------------------

(defn resolve-class
  (^Class [^Resolver rsv ^symbol sym]
   (or (lookup-type rsv sym)
       (throw (wrong/info-class-not-found sym))))
  (^Class [^Resolver rsv ^symbol sym ^Class or-else]
   (if (some? sym) (resolve-class rsv sym) or-else)))
(defn resolve-interface ^Class [^Resolver rsv ^symbol sym]
  (let [tp (resolve-class rsv sym)]
    (if (.isInterface tp)
      tp
      (wrong/other "not an interface class" tp))))

(defn untagged? ^boolean [form]
  (nil? (meta/get-tag (meta form))))
(defn tag-of ^symbol [form]
  (when-some [tag (meta/get-tag (meta form))]
    (syntax/symbol tag)))
(defn resolve-tag
  (^Class [^Resolver rsv ^IMeta form]
   (resolve-tag rsv form Object))
  (^Class [^Resolver rsv ^IMeta form ^Class or-else]
   (resolve-class rsv (tag-of form) or-else)))

(defn get-param-tags ^Object [^map form-meta] ;nil if no param tags are given
  (when (some? form-meta)
    (.valAt form-meta :param-tags nil)))
(defn param-tags-of ^vector [form]
  (when-some [ptags (get-param-tags (meta form))]
    (syntax/vector ptags)))

;;; ------------------------------------------------------------------------

(defn parse-type-symbol ^Class [^Resolver resolver form]
  (let [sym (syntax/symbol form)]
    (or (lookup-type resolver sym)
        (throw (syntax/info "expected type expression" form)))))

(defn cast-to-tag ^Expr [^Expr x ^Parser parser ^long fctx tag]
  (let [tp (parse-type-symbol (.resolver parser) tag)]
    (.type-cast (.expr-factory parser) fctx tp x)))

(defn- class-member-match ^Match [^boolean static? ^Class owner ^String mnm
                                  ^Class/1 ptags]
  (let [ms (resolve/members-by-param-tags static? owner mnm ptags)
        wr-info (fn ^Throwable []
                  (let [sym (wrong/q-as-symbol owner mnm)]
                    (-> (if (and static? (= resolve/constructor-name mnm))
                          (if (seq ms)
                            (str "multiple constructors matching " sym)
                            (str "no constructor matching " sym))
                          (let [label (if static? "static" "virtual")]
                            (if (seq ms)
                              (str "multiple " label " members matching " sym)
                              (str "no " label " member matching " sym))))
                        (wrong/wr-info))))]
    (let [m ^Match (first ms)]
      (if (and (some? m) (nil? (next ms)))
        m
        (throw (wr-info))))))

(letfn [(parse-param-tags ^Class/1 [^Object ptags ^Resolver resolver]
          (when (some? ptags)
            (let [ptags (syntax/vector ptags)
                  a (new Class/1 (count ptags))]
              (dotimes [i (alength a)]
                (let [sym (nth ptags i)]
                  (aset a i (if (= sym '_)
                              type/polymorphic
                              (parse-type-symbol resolver sym)))))
              a)))
        (resolve ^Match [^Class owner ^String nm ^Class/1 ptags]
          (if (.startsWith nm ".")
            (class-member-match false owner (.substring nm 1) ptags)
            (class-member-match true owner nm ptags)))
        (lookup ^Object [^Resolver rsv ^ExprFactory ef ^symbol sym]
          (let [nm (name sym)]
            (if-some [nmsp (namespace sym)]
              (when-some [cl (.lookup-class rsv nmsp)]
                (if-some [tp (lookup-type rsv cl nm)]
                  (.entity-constant ef tp Class) ;array type
                  (let [ptags (-> (get-param-tags (.meta sym))
                                  (parse-param-tags rsv)) m (resolve cl nm ptags)
                        ent (.entity-class-member ef m)]
                    (if (and (nil? ptags) (resolve/static-field? m))
                      (.invoke* ent context/fctx-none nil nil 0
                                (.new-exprs ef 0))
                      ent))))
              (when-some [cl (.lookup-class rsv nm)]
                (.entity-constant ef cl Class)))))]
  
  (defn lookup-class-entity ^Entity [^Parser parser ^symbol sym]
    (let [x (lookup (.resolver parser) (.expr-factory parser) sym)]
      (when (instance? Entity x)        ;filter out getstatic
        x)))
  (defn lookup-class-expr ^Expr [^Parser parser ^symbol sym]
    (let [ef (.expr-factory parser)
          x (lookup (.resolver parser) ef sym)]
      (if (instance? Entity x)
        (.value-of ef x sym)
        x))))                           ;pass through getstatic

;;; ------------------------------------------------------------------------

;;; If `paramv` is tagged with `auto-return-type`, then the arity's
;;; return type is set to the temporary `auto-return-marker`.
(defn parse-arity-type
  (^ArityType [^Resolver rsv paramv]
   (parse-arity-type rsv paramv Object))
  (^ArityType [^Resolver rsv paramv ^Class or-else-type]
   (let [paramv (syntax/vector paramv)
         n (count paramv)
         ptypes (new Class/1 n)
         pnames (new String/1 n)
         varargs? false]                ;FIXME...
     (assert (not= '& (nth paramv (- n 2) nil)))
     (dotimes [i (alength ptypes)]
       (let [param (nth paramv i)
             psym (syntax/simple-symbol param)]
         (aset ptypes i (resolve-tag rsv psym or-else-type))
         (aset pnames i (name psym))))
     (let [return-tag (tag-of paramv)]
       (-> (if (= meta/auto-return-type return-tag)
             type/auto-return-marker
             (resolve-class rsv return-tag or-else-type))
           (ArityType. ptypes pnames varargs?)))))
  (^ArityType [^Resolver rsv ^long fctx paramv ^Class or-else-type
               ^seq error-context]
   (context/with-line-from-list [fctx error-context]
     (parse-arity-type rsv paramv or-else-type))))

(defn unhinted-arity-type? ^boolean [^ArityType at ^int start]
  (and (nil? (.return-type at))
       (let [a (.parameter-types at)]
         (loop [i (dec (alength a))]
           (cond (< i start) true
                 (some? (aget a i)) false
                 :else (recur (dec i)))))))

(defn parse-method-type ^ArityType [^Resolver rsv ^Class owner
                                    ^symbol method-name paramv]
  (let [at (parse-arity-type rsv paramv nil)
        mnm (name method-name)
        n (dec (.parameter-count at))]
    (letfn [(select-method-by-arity ^Method [^ArityType at]
              (if-some [ms (seq (resolve/itf-methods-with-name owner mnm n))]
                (if (nil? (next ms))
                  (first ms)
                  (-> (str "multiple virtual " n "-parameter methods matching ")
                      (wrong/other method-name)))
                (-> (str "no virtual " n "-parameter method matching ")
                    (wrong/other method-name))))
            (unhinted-to-Object ^Class [^Class tp]
              (or tp Object))
            (select-matching-method ^Method [^ArityType at]
              (let [rt (.return-type at) ;inferred if unhinted
                    pts (new Class/1 n)]
                (dotimes [i (alength pts)]
                  (aset pts i (-> (aget (.parameter-types at) (inc i))
                                  (unhinted-to-Object))))
                (if-some [m (resolve/itf-method-exact owner mnm rt pts)]
                  m
                  (wrong/other "no virtual method matching " method-name))))]
      
      (when-not (untagged? (first paramv))
        (throw (syntax/info "no type tag allowed for receiver parameter")))
      (aset (.parameter-types at) 0 owner) ;type of receiver
      (model/with-method-type at (if (unhinted-arity-type? at 1)
                                   (select-method-by-arity at)
                                   (select-matching-method at))))))
