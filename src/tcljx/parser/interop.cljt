(ns tcljx.parser.interop
  (:require
   (tcljx.data [meta :as meta] [type :as type] [wrong :as wrong]
               [context :as context] [model :as model])
   (tcljx.parser [syntax :as syntax]))
  (:import
   (tcljx.data.model Resolver ExprFactory Scope Entity ArityType ArityTypeImpl)
   (clojure.lang IMeta)))

;;; Returns nil if lookup fails.  The three argument arity returns an
;;; array type if class `cl` is provided and `nm` is a digit
;;; matching [1-9].
(defn lookup-type
  (^Class [^Resolver rsv ^symbol tp]
   (let [nm (name tp)]
     (if-some [nmsp (namespace tp)]
       (lookup-type rsv (.lookup-class rsv nmsp) nm)
       (.lookup-class rsv nm))))
  (^Class [^Resolver rsv ^Class cl ^String nm] ;nil if `cl` is nil
   (when (and (some? cl) (= (.length nm) 1))
     (let [n (- (int (.charAt nm 0)) (int \0))]
       (when (<= 1 n 9)
         (type/array-type-of-class cl n))))))

;;; ------------------------------------------------------------------------

(defn tag-of ^symbol [form]
  (when-some [tag (meta/get-tag (meta form))]
    (syntax/symbol tag)))
(defn resolve-tag* ^Class [^Resolver rsv ^symbol tag ^Class or-else]
  (if (some? tag)
    (or (lookup-type rsv tag) (throw (wrong/info-class-not-found tag)))
    or-else))
(defn resolve-tag
  (^Class [^Resolver rsv ^IMeta form]
   (resolve-tag rsv form Object))
  (^Class [^Resolver rsv ^IMeta form ^Class or-else]
   (resolve-tag* rsv (tag-of form) or-else)))

(defn get-param-tags ^Object [^map form-meta] ;nil if no param tags are given
  (when (some? form-meta)
    (.valAt form-meta :param-tags nil)))
(defn param-tags-of ^vector [form]
  (when-some [ptags (get-param-tags (meta form))]
    (syntax/vector ptags)))

;;; ------------------------------------------------------------------------

(defn parse-type-symbol ^Class [^Resolver resolver form]
  (let [sym (syntax/symbol form)]
    (or (lookup-type resolver sym)
        (throw (syntax/info "expected type expression" form)))))

(defn lookup-class-entity
  (^Entity [^Scope scope ^symbol sym]
   (lookup-class-entity (.resolver scope) (.expr-factory scope) sym))
  (^Entity [^Resolver resolver ^ExprFactory expr-factory ^symbol sym]
   (letfn [(parse-param-tags ^Class/1 [^Resolver resolver ^Object ptags]
             (when (some? ptags)
               (let [ptags (syntax/vector ptags)
                     a (new Class/1 (count ptags))]
                 (dotimes [i (alength a)]
                   (let [sym (nth ptags i)]
                     (aset a i (if (= sym '_)
                                 type/polymorphic
                                 (parse-type-symbol resolver sym)))))
                 a)))
           
           (resolve-class-qualified-symbol ^Entity [^Class owner ^String nm
                                                    ^Object ptags]
             (if-some [tp (lookup-type resolver owner nm)]
               (.constant-entity expr-factory tp Class) ;array type
               (let [ptags (parse-param-tags resolver ptags)]
                 (if (.startsWith nm ".")
                   (.class-member-entity expr-factory false owner
                                         (.substring nm 1) ptags)
                   (.class-member-entity expr-factory true owner nm ptags)))))]
     (if-some [nmsp (namespace sym)]
       (when-some [cl (.lookup-class resolver nmsp)]
         (let [ptags (get-param-tags (.meta sym))]
           (resolve-class-qualified-symbol cl (name sym) ptags)))
       (when-some [cl (.lookup-class resolver (name sym))]
         (.constant-entity expr-factory cl Class))))))

;;; ------------------------------------------------------------------------

;;; If `paramv` is tagged with `auto-return-type`, then the arity's
;;; return type is set to the temporary `auto-return-marker`.
(defn parse-arity-type
  (^ArityType [^Resolver rsv paramv]
   (let [paramv (syntax/vector paramv)
         n (count paramv)
         ptypes (new Class/1 n)
         pnames (new String/1 n)
         varargs? false]               ;FIXME...
     (assert (not= '& (nth paramv (- n 2) nil)))
     (dotimes [i (alength ptypes)]
       (let [param (nth paramv i)
             psym (syntax/simple-symbol param)]
         (aset ptypes i (resolve-tag rsv psym))
         (aset pnames i (name psym))))
     (let [return-tag (tag-of paramv)]
       (-> (if (= meta/auto-return-type return-tag)
             type/auto-return-marker
             (resolve-tag* rsv return-tag Object))
           (ArityTypeImpl. ptypes pnames varargs?)))))
  (^ArityType [^Resolver rsv ^long fctx paramv
               ^seq error-context]
   (context/with-line-from-list [fctx error-context]
     (parse-arity-type rsv paramv))))
