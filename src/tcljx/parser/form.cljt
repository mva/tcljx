(ns tcljx.parser.form
  (:require
   (tcljx.data
    [meta :as meta] [wrong :as wrong] [type :as type] [context :as context]
    [model :as model])
   (tcljx.parser
    [interop :as interop] [syntax :as syntax] [parse :as parse] [def :as def]
    [let :as let] [loop :as loop] [fn :as fn] [new :as new]
    [constant :as constant] [trycatch :as trycatch]))
  (:import
   (tcljx.data.model Resolver Expr Exprs ExprFactory Entity Invocable Parser)
   (clojure.lang IMeta)))

(deftype ParserImpl [^ExprFactory expr-factory
                     ^Resolver resolver
                     ^map bindings*]
  java.lang.Record
  
  Parser
  (parse-form [this fctx form]
    #_(binding [*print-meta* #_false true]
        (prn :parse-expression form))
    
    (letfn [(parse-meta ^Expr [^long fctx ^map form-meta]
              (when form-meta
                (parse-collection-literal fctx form-meta (meta form-meta))))
            (parse-collection-literal ^Expr [^long fctx form ^map form-meta]
              (let [x-meta (parse-meta fctx form-meta)
                    coll-tp (cond
                              (vector? form) type/vector
                              (map? form) type/map
                              (set? form) type/set
                              (seq? form) type/list
                              :else (throw (IllegalStateException.)))
                    x (->> (if (identical? type/map coll-tp)
                             (mapcat identity form)
                             (seq form))
                           (parse/args this fctx)
                           (.new-collection expr-factory coll-tp))]
                (if (some? x-meta)
                  (.attach-meta-to expr-factory x-meta x)
                  x)))

            (parse-quoted-form ^Expr [form]
              (if (instance? IMeta form)
                ;; symbol, list, vector, map, set
                (let [tp (type/of-quoted-form form)]
                  (.new-loadable expr-factory form tp))
                ;; adjust type to primitive if possible
                (constant/parse-constant-nometa this form)))
            (parse-quote ^Expr [[_ & args]]
              (syntax/empty-tail (next args))
              (parse-quoted-form (syntax/first args)))

            (parse-if ^Expr [^long fctx [_ & formr]]
              (syntax/first (next formr)) ;test and first path exist?
              (syntax/empty-tail 3 formr) ;nothing after test and two paths?
              (let [xs (.new-exprs expr-factory (count formr))]
                (.set xs 0 (parse/arg this fctx (first formr)))
                (.set xs 1 (parse/form this fctx (first (next formr))))
                (when (= (.length xs) 3)
                  (.set xs 2 (parse/form this fctx (first (nnext formr)))))
                (.if-expr expr-factory fctx xs)))
            (parse-case*-guard ^Exprs [form]
              (if (seq? form)           ;accept empty list!
                (let [gs (.new-exprs expr-factory (count form))]
                  (loop [xs form, i 0]
                    (when (< i (.length gs))
                      (.set gs i (parse-quoted-form (first xs)))
                      (recur (rest xs) (inc i))))
                  gs)
                (doto (.new-exprs expr-factory 1)
                  (.set 0 (parse-quoted-form form)))))
            (parse-case* ^Expr [^long fctx [_ & formr :as form]]
              (let [select (parse/arg this fctx (syntax/first formr))
                    n (- (count formr) 1)
                    has-default? (odd? n)
                    n-paths (quot n 2)
                    gs (new Exprs/1 n-paths)
                    ps (.new-exprs expr-factory (+ n-paths (int has-default?)))
                    ecs (new seq/1 n-paths)]
                (loop [[g p & gpr :as gps] (next formr), i 0]
                  (if (< i n-paths)
                    (do (aset gs i (parse-case*-guard g))
                        (.set ps i (parse/form this fctx p))
                        (aset ecs i (or (when (seq? g) g) (when (seq? p) p)
                                        form))
                        (recur gpr (inc i)))
                    (do (when has-default?
                          (.set ps i (parse/form this fctx g)))
                        (.case-expr expr-factory select gs ps fctx ecs))))))
            (parse-do ^Expr [^long fctx [_ & forms]]
              (parse/progn this fctx forms))
            
            (parse-throw ^Expr [^long fctx [_ & args]]
              (let [x (parse/arg this fctx (syntax/first args))]
                (syntax/empty-tail (next args))
                (.throw-expr expr-factory fctx x)))
            (parse-instanceof* ^Expr [^long fctx [_ & args]]
              (let [xs (parse/args this fctx args)]
                (syntax/empty-tail 2 args)
                (if-some [tp (model/type-literal (.get xs 0) (first args))]
                  (.instanceof-expr expr-factory fctx tp (.get xs 1))
                  (.invoke-virtual-member expr-factory fctx (.get xs 0)
                                          nil "isInstance" (.drop xs 1)))))
            
            (parse-import* ^Expr [[_ & formr :as form]]
              (let [specs (map syntax/strip-quote formr)
                    rimports (syntax/flatten-imports nil "" specs form)]
                (.process-imports (parse/namespace-builder this)
                                  (reverse rimports))
                (.empty-expr expr-factory)))
            
            (unpack-member-args ^seq [^seq formr]
              (if (seq? (first formr))
                (do (syntax/empty-tail (next formr))
                    (first formr))
                formr))
            (parse-dot ^Expr [^long fctx [_ owner & formr]]
              (let [[member & args] (unpack-member-args formr)
                    mnm (syntax/simple-symbol-str member) ;implies owner exists
                    owner-expr (parse/arg this fctx owner)
                    xs (parse/args this fctx args)
                    fnm (when (and (> (.length mnm) 1) (= (.charAt mnm 0) \-)
                                   (.empty? xs))
                          (.substring mnm 1))]
                (if-some [owner (model/type-literal owner-expr owner)]
                  (if fnm
                    (.get-static-field expr-factory fctx owner fnm)
                    (.invoke-static-member expr-factory fctx false owner mnm xs))
                  (if fnm
                    (.get-virtual-field expr-factory fctx owner-expr fnm)
                    (.invoke-virtual-member expr-factory fctx owner-expr
                                            nil mnm xs)))))
            (parse-dot-dot-or-member ^Expr [^String nm ^long fctx [_ & formr]]
              (if (= nm "..")
                (->> (reduce #(list '. %1 %2)
                             (list '. (syntax/first formr)
                                   (syntax/first (next formr)))
                             (nnext formr))
                     (parse-dot fctx))
                (let [mnm (.substring nm 1)
                      receiver (parse/arg this fctx (syntax/first formr))
                      xs (parse/args this fctx (rest formr))]
                  (.invoke-virtual-member expr-factory fctx receiver
                                          nil mnm xs))))
            (parse-class-dot ^Expr [^String nm ^long fctx [_ & formr]]
              (let [clnm (.substring nm 0 (dec (.length nm)))]
                (parse-dot fctx (list* \. (symbol nil clnm) 'new formr))))
            
            (wr-info-unresolved-qualified-sym ^Throwable [^symbol op]
              (wrong/wr-info
               (if (parse/lookup-namespace this (namespace op))
                 ;; namespace exists: def lookup must have failed
                 (str "no public def " (wrong/q op))
                 (str "no namespace or class " (wrong/q-namespace op)))))
            (parse-invocation-binding ^Expr [^symbol op ^long fctx ^seq form]
              ;; `op` is a unqualified symbol without leading or
              ;; trailing dot
              (if-some [ent (parse/lookup this op)]
                (let [args (parse/args this fctx (rest form))]
                  (if (model/invocable? ent)
                    (.invoke expr-factory fctx form ent args)
                    (let [f* (.value-of expr-factory ent op)]
                      (.invoke-value expr-factory fctx f* args))))
                (throw (wrong/info-unresolved op))))
            (parse-invocation-qname ^Expr [^symbol op ^long fctx ^seq form
                                           ^String nmsp ^String nm]
              ;; `op` is qualified symbol: either a reference to
              ;; a namespace def, a static class member, or an
              ;; instance member
              (if-some [cl (parse/lookup-class this nmsp)]
                (if-some [ent (when (some? (interop/param-tags-of op))
                                (interop/lookup-class-entity this op))]
                  (.invoke expr-factory fctx form ent
                           (parse/args this fctx (rest form)))
                  (if (= (.charAt nm 0) \.) ;syntax is Class/.member
                    (.invoke-virtual-member
                     expr-factory fctx
                     (parse/arg this fctx (syntax/second form))
                     cl (.substring nm 1)
                     (parse/args this fctx (nnext form)))
                    (.invoke-static-member
                     expr-factory fctx true cl nm
                     (parse/args this fctx (rest form)))))
                (condp = op
                  tcljx.data.config/sym-regex-literal
                  ;; FIXME... drop this later
                  (constant/regex-literal this (syntax/second form))

                  'tinyclj.lang.primitive/list
                  ;; FIXME... drop this later
                  (parse-collection-literal fctx (rest form) nil)
                  
                  #_else
                  (throw (wr-info-unresolved-qualified-sym op)))))
            (parse-invocation-other ^Expr [op ^long fctx ^seq form]
              ;; any non-symbol `op`
              (let [op (parse/arg this fctx (first form))
                    ce (.emitter op)
                    args (parse/args this fctx (rest form))]
                (if (model/invocable? ce)
                  (.invoke expr-factory fctx form ce args)
                  (.invoke-value expr-factory fctx op args))))
            (parse-invocation ^Expr [op ^long fctx ^seq form] ;discards meta
              (if (symbol? op)
                (let [nm (name op), nmsp (namespace op)]
                  (if (nil? nmsp)
                    (case nm
                      ;; FIXME... implement these as proper primitive
                      ;; functions
                      "identity" (parse/arg this fctx (syntax/second form))
                      
                      "def" (def/parse-def this fctx form)
                      "loop*" (loop/parse-loop* this fctx form)
                      "recur" (loop/parse-recur this fctx form)
                      "if" (parse-if fctx form)
                      "case*" (parse-case* fctx form)
                      "let*" (let/parse-let* this fctx form)
                      ;; letfn* (letfn*-form form)
                      "do" (parse-do fctx form)
                      "fn*" (fn/parse-fn* this fctx form)
                      "quote" (parse-quote form)
                      ;; var (var-form form)
                      "import*" (parse-import* form)
                      "." (parse-dot fctx form)
                      ;; set! (set!-form form)
                      ;; deftype* (deftype*-form form)
                      ;; reify* (reify*-form form)
                      "try" (trycatch/parse-try this fctx form)
                      "throw" (parse-throw fctx form)
                      ;; monitor-enter (monitor-form Opcode/MONITORENTER form)
                      ;; monitor-exit (monitor-form Opcode/MONITOREXIT form)
                      ;; catch is only special within `try-form`
                      ;; finally is only special within `try-form`
                      "new" (let [arg (syntax/second form)
                                  tp (interop/parse-type-symbol resolver arg)]
                              (new/parse-new this tp fctx form))
                      ;; & is only special within arity signature
                      
                      ;; special forms that are not special in Clojure:
                      ;; "definterface*" (definterface*-form form)
                      "instanceof*" (parse-instanceof* fctx form)
                      #_else (cond
                               (= (.charAt nm 0) \.)
                               (parse-dot-dot-or-member nm fctx form)
                               (= (.charAt nm (dec (.length nm))) \.)
                               (parse-class-dot nm fctx form)
                               :else (parse-invocation-binding op fctx form)))
                    (parse-invocation-qname op fctx form nmsp nm)))
                (parse-invocation-other op fctx form)))
            
            (parse-symbol ^Expr [^symbol sym]
              (if-some [ent (parse/lookup this sym)]
                (.value-of expr-factory ent sym)
                (if-some [x (interop/lookup-class-expr this sym)]
                  x
                  (throw (wrong/info-unresolved sym)))))
            
            (apply-type-hint ^Expr [^Expr x ^long fctx form-tag]
              ;; pre: (some? form-tag)
              (let [tp (interop/parse-type-symbol resolver form-tag)]
                (.type-cast expr-factory fctx tp x)))]

      (if (instance? IMeta form)
        (let [form-meta (.meta ^IMeta form)
              form-tag (meta/get-tag form-meta)]
          (-> (cond
                ;; reference to global def, local binding, defined
                ;; class, class member, or instance field (when in a
                ;; deftype); close to 90% hit rate for "is a symbol"
                (symbol? form) (parse-symbol form)
                
                ;; special form, macro form, or some function call variant
                (and (seq? form) (some? (seq form)))
                (context/with-line-from-meta [fctx form-meta]
                  (parse-invocation (first form) fctx form))
                
                ;; vector, map, set, or empty list
                :else (parse-collection-literal fctx form form-meta))
              (cond-> (some? form-tag) (apply-type-hint fctx form-tag))))
        
        ;; keyword, pattern, number, character, string, boolean, nil,
        ;; or (via expansion) a class instance
        (constant/parse-constant-nometa this form))))

  (with-bindings* [_ bindings]
    (ParserImpl. expr-factory resolver bindings))
  (with-recur-parameters [_ parameters]
    (-> (.with-recur-parameters expr-factory parameters)
        (ParserImpl. resolver bindings*)))
  (with-expr-factory [_ expr-factory]
    (ParserImpl. expr-factory resolver bindings*)))

(def mk-parser ParserImpl/new)
