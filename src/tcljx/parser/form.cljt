(ns tcljx.parser.form
  (:require
   (tcljx [model :as model])
   (tcljx.parser [meta :as meta] [interop :as interop] [wrong :as wrong]
                 [syntax :as syntax] [context :as context] [def :as def]
                 [constant :as constant]))
  (:import
   (tcljx.model Resolver ExprFactory Expr Scope)
   (clojure.lang IMeta)))

(deftype ScopeImpl [^ExprFactory expr-factory
                    ^Resolver resolver
                    ^map bindings*]
  java.lang.Record
  
  Scope
  (parse-form [this form]
    #_(binding [*print-meta* #_false true]
        (prn :parse-expression form))
    
    (letfn [(parse-args ^Expr/1 [args]
              (let [a (.new-array expr-factory (count args))]
                (loop [args args, i 0]
                  (when (< i (alength a))
                    (aset a i (.parse-form this (first args)))
                    (recur (rest args) (inc i))))
                a))
            (parse-collection-literal ^Expr [form ^map form-meta]
              (.mk-expr expr-factory form))

            (resolves-as-class-name ^Class [form]
              (when (syntax/simple-symbol? form)
                (when (nil? (context/lookup this form))
                  (context/lookup-class this (name form)))))
            (unpack-member-args ^seq [^seq formr]
              (if (seq? (first formr))
                (do (syntax/empty-tail (next formr))
                    (first formr))
                formr))
            (parse-dot [[_ owner & formr]]
              (let [[member & args] (unpack-member-args formr)
                    mnm (syntax/simple-symbol-str member)] ;implies owner exists
                (if-some [owner (resolves-as-class-name owner)]
                  (.invoke-static-member expr-factory owner mnm
                                         (parse-args args))
                  (assert false))))
            
            (wr-info-unresolved-qualified-sym ^Throwable [^symbol op]
              (wrong/wr-info
               (if (context/lookup-namespace this (namespace op))
                 ;; namespace exists: def lookup must have failed
                 (str "no public def " (wrong/q op))
                 (str "no namespace or class " (wrong/q-namespace op)))))
            (parse-invocation ^Expr [op ^seq form] ;discards meta
              (if (symbol? op)
                (let [nm (name op), nmsp (namespace op)]
                  (if (nil? nmsp)
                    (case nm
                      "def" (def/parse-def this form)
                      "." (parse-dot form)
                      #_else (.mk-expr expr-factory form))

                    ;; `op` is qualified symbol: either a reference to
                    ;; a namespace ref, or a static class member
                    (if-some [bnd (context/lookup this op)]
                      bnd
                      (if-some [cl (context/lookup-class this nmsp)]
                        (.invoke-static-member expr-factory cl nm
                                               (parse-args (rest form)))
                        (throw (wr-info-unresolved-qualified-sym op))))))
                (.mk-expr expr-factory form)))
            
            (wrong-unresolved ^Expr [^symbol sym]
              (wrong/unresolved "undefined symbol " sym))
            (parse-symbol ^Expr [^symbol sym] ;discards meta
              (if-some [bnd (context/lookup this sym)]
                (-> expr-factory (.bound-value bnd))
                (wrong-unresolved sym)))
            
            (apply-type-hint ^Expr [^Expr x form-tag] ;pre: (some? form-tag)
              (assert false))]

      (if (instance? IMeta form)
        (let [form-meta (.meta ^IMeta form)
              form-tag (interop/get-tag form-meta)]
          (-> (cond
                ;; reference to global def, local binding, defined
                ;; class, or instance field (when in a deftype)
                (symbol? form) (parse-symbol form)
                
                ;; special form, macro form, or some function call variant
                (and (seq? form) (some? (seq form)))
                (let [line (meta/get-line form-meta)]
                  (->> (wrong/with-line-context line
                         (parse-invocation (first form) form))
                       (.line-number expr-factory line)))
                
                ;; vector, map, set, or empty list
                :else (parse-collection-literal form form-meta))
              (cond-> (some? form-tag) (apply-type-hint form-tag))))
        
        ;; keyword, pattern, number, character, string, boolean, nil,
        ;; or (via expansion) a class instance
        (constant/parse-constant this form)))))

(def mk-scope ScopeImpl/new)
