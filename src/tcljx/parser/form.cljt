(ns tcljx.parser.form
  (:require
   (tcljx.data
    [meta :as meta] [wrong :as wrong] [type :as type] [context :as context]
    [model :as model])
   (tcljx.parser
    [interop :as interop] [syntax :as syntax] [def :as def]
    [let :as let] [fn :as fn] [new :as new] [constant :as constant]
    [trycatch :as trycatch]))
  (:import
   (tcljx.data.model Resolver Expr Exprs ExprFactory Invocable Scope)
   (clojure.lang IMeta)))

(deftype ScopeImpl [^ExprFactory expr-factory
                    ^Resolver resolver
                    ^map bindings*]
  java.lang.Record
  
  Scope
  (parse-form [this fctx form]
    #_(binding [*print-meta* #_false true]
        (prn :parse-expression form))
    
    (letfn [(parse-meta ^Expr [^long fctx ^map form-meta]
              (when form-meta
                (parse-collection-literal fctx form-meta (meta form-meta))))
            (parse-collection-literal-nometa ^Expr [^long fctx form]
              (cond
                (vector? form)
                (.new-vector expr-factory (context/parse-args this fctx (seq form)))
                (map? form)
                (let [forms (mapcat identity form)]
                  (.new-map expr-factory (context/parse-args this fctx forms)))
                (set? form)
                (.new-set expr-factory (context/parse-args this fctx (seq form)))
                (seq? form)
                (.new-list expr-factory (context/parse-args this fctx (seq form)))
                :else
                (throw (IllegalStateException. (str (class form))))))
            (parse-collection-literal ^Expr [^long fctx form ^map form-meta]
              (let [x-meta (parse-meta fctx form-meta)
                    x (parse-collection-literal-nometa fctx form)]
                (if (some? x-meta)
                  (.attach-meta-to expr-factory x-meta x)
                  x)))

            (parse-quoted-form ^Expr [form]
              (if (instance? IMeta form)
                ;; symbol, list, vector, map, set
                (let [tp (type/of-quoted-form form)]
                  (.new-loadable expr-factory tp form))
                ;; adjust type to primitive if possible
                (constant/parse-constant-nometa this form)))
            (parse-quote ^Expr [[_ & args]]
              (syntax/empty-tail (next args))
              (parse-quoted-form (syntax/some-first args)))

            (parse-if ^Expr [^long fctx [_ & formr]]
              (syntax/some-first (next formr)) ;test and first path exist?
              (syntax/empty-tail 3 formr) ;nothing after test and two paths?
              (let [xs (.new-exprs expr-factory (count formr))]
                (.set xs 0 (context/parse-arg this fctx (first formr)))
                (.set xs 1 (context/parse-form this fctx (first (next formr))))
                (when (= (.length xs) 3)
                  (.set xs 2 (context/parse-form this fctx (first (nnext formr)))))
                (.if-expr expr-factory fctx xs)))
            (parse-case*-guard ^Exprs [form]
              (if (seq? form)           ;accept empty list!
                (let [gs (.new-exprs expr-factory (count form))]
                  (loop [xs form, i 0]
                    (when (< i (.length gs))
                      (.set gs i (parse-quoted-form (first xs)))
                      (recur (rest xs) (inc i))))
                  gs)
                (doto (.new-exprs expr-factory 1)
                  (.set 0 (parse-quoted-form form)))))
            (parse-case* ^Expr [^long fctx [_ & formr :as form]]
              (let [select (context/parse-arg this fctx (syntax/some-first formr))
                    n (- (count formr) 1)
                    has-default? (odd? n)
                    n-paths (quot n 2)
                    gs (new Exprs/1 n-paths)
                    ps (.new-exprs expr-factory (+ n-paths (int has-default?)))
                    ecs (new seq/1 n-paths)]
                (loop [[g p & gpr :as gps] (next formr), i 0]
                  (if (< i n-paths)
                    (do (aset gs i (parse-case*-guard g))
                        (.set ps i (context/parse-form this fctx p))
                        (aset ecs i (or (when (seq? g) g) (when (seq? p) p)
                                        form))
                        (recur gpr (inc i)))
                    (do (when has-default?
                          (.set ps i (context/parse-form this fctx g)))
                        (.case-expr expr-factory select gs ps fctx ecs))))))
            (parse-do ^Expr [^long fctx [_ & forms]]
              (context/parse-progn this fctx forms))
            
            (parse-throw ^Expr [^long fctx [_ & args]]
              (let [x (context/parse-arg this fctx (syntax/some-first args))]
                (syntax/empty-tail (next args))
                (.throw-expr expr-factory fctx x)))
            (parse-instanceof* ^Expr [^long fctx [_ & args]]
              (let [xs (context/parse-args this fctx args)]
                (syntax/empty-tail 2 args)
                (if-some [tp (model/type-expression (.get xs 0) (first args))]
                  (.instanceof-expr expr-factory fctx tp (.get xs 1))
                  (.invoke-virtual-member expr-factory fctx (.get xs 0)
                                          "isInstance" (.drop xs 1)))))
            
            (parse-import* ^Expr [[_ & formr :as form]]
              (let [specs (map syntax/strip-quote formr)
                    rimports (syntax/flatten-imports nil "" specs form)]
                (.process-imports (context/namespace-builder this)
                                  (reverse rimports))
                (.empty-expr expr-factory)))
            
            (unpack-member-args ^seq [^seq formr]
              (if (seq? (first formr))
                (do (syntax/empty-tail (next formr))
                    (first formr))
                formr))
            (parse-dot ^Expr [^long fctx [_ owner & formr]]
              (let [[member & args] (unpack-member-args formr)
                    mnm (syntax/simple-symbol-str member) ;implies owner exists
                    owner-expr (context/parse-arg this fctx owner)
                    xs (context/parse-args this fctx args)
                    fnm (when (and (> (.length mnm) 1) (= (.charAt mnm 0) \-)
                                   (.empty? xs))
                          (.substring mnm 1))]
                (if-some [owner (model/type-expression owner-expr owner)]
                  (if fnm
                    (.get-static-field expr-factory fctx owner fnm)
                    (.invoke-static-member expr-factory fctx false owner mnm xs))
                  (if fnm
                    (.get-virtual-field expr-factory fctx owner-expr fnm)
                    (.invoke-virtual-member expr-factory fctx owner-expr mnm xs)))))
            (parse-dot-dot-or-member ^Expr [^String nm ^long fctx [_ & formr]]
              (if (= nm "..")
                (->> (reduce #(list '. %1 %2)
                             (list '. (syntax/some-first formr)
                                   (syntax/some-first (next formr)))
                             (nnext formr))
                     (parse-dot fctx))
                (let [mnm (.substring nm 1)
                      receiver (context/parse-arg this fctx (syntax/some-first formr))
                      xs (context/parse-args this fctx (rest formr))]
                  (.invoke-virtual-member expr-factory fctx receiver mnm xs))))
            (parse-class-dot ^Expr [^String nm ^long fctx [_ & formr]]
              (let [clnm (.substring nm 0 (dec (.length nm)))]
                (parse-dot fctx (list* \. (symbol nil clnm) 'new formr))))
            
            (wr-info-unresolved-qualified-sym ^Throwable [^symbol op]
              (wrong/wr-info
               (if (context/lookup-namespace this (namespace op))
                 ;; namespace exists: def lookup must have failed
                 (str "no public def " (wrong/q op))
                 (str "no namespace or class " (wrong/q-namespace op)))))
            (parse-invocation ^Expr [op ^long fctx ^seq form] ;discards meta
              (if (symbol? op)
                (let [nm (name op), nmsp (namespace op)]
                  (if (nil? nmsp)
                    (case nm
                      ;; FIXME... implement these as proper primitive
                      ;; functions
                      "identity" (context/parse-arg this fctx (second form))
                      
                      "def" (def/parse-def this fctx form)
                      ;; loop* (loop*-form form)
                      ;; recur (recur-form form)
                      "if" (parse-if fctx form)
                      "case*" (parse-case* fctx form)
                      "let*" (let/parse-let* this fctx form)
                      ;; letfn* (letfn*-form form)
                      "do" (parse-do fctx form)
                      "fn*" (fn/parse-fn* this fctx form)
                      "quote" (parse-quote form)
                      ;; var (var-form form)
                      "import*" (parse-import* form)
                      "." (parse-dot fctx form)
                      ;; set! (set!-form form)
                      ;; deftype* (deftype*-form form)
                      ;; reify* (reify*-form form)
                      "try" (trycatch/parse-try this fctx form)
                      "throw" (parse-throw fctx form)
                      ;; monitor-enter (monitor-form Opcode/MONITORENTER form)
                      ;; monitor-exit (monitor-form Opcode/MONITOREXIT form)
                      ;; catch is only special within `try-form`
                      ;; finally is only special within `try-form`
                      "new" (let [sym (syntax/symbol (second form))]
                              (new/parse-new this (parse-type-symbol sym)
                                             fctx form))
                      ;; & is only special within arity signature
                      
                      ;; special forms that are not special in Clojure:
                      ;; "definterface*" (definterface*-form form)
                      "instanceof*" (parse-instanceof* fctx form)
                      #_else
                      (cond
                        (= (.charAt nm 0) \.)
                        (parse-dot-dot-or-member nm fctx form)
                        
                        (= (.charAt nm (dec (.length nm))) \.)
                        (parse-class-dot nm fctx form)
                        
                        :else
                        (if-some [bnd (context/lookup this op)]
                          (if-some [inv (model/bound-invocable bnd)]
                            (.invoke expr-factory fctx form inv
                                     (context/parse-args this fctx (rest form)))
                            (assert false))
                          (throw (wrong/info-unresolved op)))))

                    ;; `op` is qualified symbol: either a reference to
                    ;; a namespace ref, or a static class member
                    (if-some [bnd (context/lookup this op)]
                      bnd
                      (if-some [cl (context/lookup-class this nmsp)]
                        (.invoke-static-member expr-factory fctx true cl nm
                                               (context/parse-args this fctx (rest form)))
                        (condp = op
                          tcljx.data.config/sym-regex-literal
                          ;; FIXME... drop this later
                          (constant/regex-literal this (second form))

                          'tinyclj.lang.primitive/list
                          ;; FIXME... drop this later
                          (parse-collection-literal fctx (rest form) nil)
                          
                          #_else
                          (throw (wr-info-unresolved-qualified-sym op)))))))
                (.mk-expr expr-factory form)))
            
            (parse-class-qualified-symbol ^Expr [^Class nmsp ^String nm]
              (if-some [tp (interop/lookup-type resolver nmsp nm)]
                (.new-constant expr-factory Class tp)
                (.get-static-field expr-factory fctx nmsp nm)))
            (lookup-class-symbol ^Expr [^symbol sym]
              (if-some [nmsp (namespace sym)]
                (when-some [cl (.lookup-class resolver nmsp)]
                  (parse-class-qualified-symbol cl (name sym)))
                (when-some [cl (.lookup-class resolver (name sym))]
                  (.new-constant expr-factory Class cl))))
            (parse-symbol ^Expr [^symbol sym] ;discards meta
              (if-some [bnd (context/lookup this sym)]
                (.bound-value bnd)
                (or (lookup-class-symbol sym)
                    (throw (wrong/info-unresolved sym)))))
            (wr-info-unresolved-type ^Throwable [^symbol sym]
              (wrong/info-unresolved "undefined type symbol " sym))
            (parse-type-symbol ^Class [^symbol sym]
              (if-some [x (lookup-class-symbol sym)]
                (if-some [tp (model/type-expression x sym)]
                  tp
                  (throw (syntax/info "expected type expression" sym)))
                (throw (wr-info-unresolved-type sym))))
            
            (apply-type-hint ^Expr [^Expr x ^long fctx form-tag]
              ;; pre: (some? form-tag)
              (.type-cast expr-factory fctx
                          (parse-type-symbol (syntax/symbol form-tag)) x))]

      (if (instance? IMeta form)
        (let [form-meta (.meta ^IMeta form)
              form-tag (meta/get-tag form-meta)]
          (-> (cond
                ;; reference to global def, local binding, defined
                ;; class, or instance field (when in a deftype)
                (symbol? form) (parse-symbol form)
                
                ;; special form, macro form, or some function call variant
                (and (seq? form) (some? (seq form)))
                (context/with-line-from-meta [fctx form-meta]
                  (parse-invocation (first form) fctx form))
                
                ;; vector, map, set, or empty list
                :else (parse-collection-literal fctx form form-meta))
              (cond-> (some? form-tag) (apply-type-hint fctx form-tag))))
        
        ;; keyword, pattern, number, character, string, boolean, nil,
        ;; or (via expansion) a class instance
        (constant/parse-constant-nometa this form))))

  (with-bindings* [_ bindings]
    (ScopeImpl. expr-factory resolver bindings)))

(def mk-scope ScopeImpl/new)
