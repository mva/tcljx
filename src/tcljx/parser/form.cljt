(ns tcljx.parser.form
  (:require
   (tcljx [model :as model])
   (tcljx.parser [meta :as meta] [wrong :as wrong] [interop :as interop]
                 [syntax :as syntax] [context :as context] [def :as def]
                 [fn :as fn] [new :as new] [constant :as constant]))
  (:import
   (tcljx.model Resolver ExprFactory Expr Scope)
   (clojure.lang IMeta)))

(deftype ScopeImpl [^ExprFactory expr-factory
                    ^Resolver resolver
                    ^map bindings*]
  java.lang.Record
  
  Scope
  (parse-form [this form]
    #_(binding [*print-meta* #_false true]
        (prn :parse-expression form))
    
    (letfn [(parse-args ^Expr/1 [args]
              (context/parse-args this args))
            (parse-collection-literal ^Expr [form ^map form-meta]
              (.mk-expr expr-factory form))

            (type-expression ^Class [^Expr x form] ;nil if no type expression
              (when-some [value (model/const-value x)]
                (when (and (class? value) (syntax/simple-symbol? form))
                  value)))
            (parse-type-expression ^Class [form]
              (let [x (.parse-form this form)]
                (or (type-expression x form)
                    (throw (syntax/info "expected type expression" form)))))
            
            (unpack-member-args ^seq [^seq formr]
              (if (seq? (first formr))
                (do (syntax/empty-tail (next formr))
                    (first formr))
                formr))
            (parse-dot [[_ owner & formr]]
              (let [[member & args] (unpack-member-args formr)
                    mnm (syntax/simple-symbol-str member) ;implies owner exists
                    owner-expr (.parse-form this owner)
                    xs (parse-args args)]
                (if-some [owner (type-expression owner-expr owner)]
                  (.invoke-static-member expr-factory false owner mnm xs)
                  (.invoke-virtual-member expr-factory owner-expr mnm xs))))
            
            (wr-info-unresolved-qualified-sym ^Throwable [^symbol op]
              (wrong/wr-info
               (if (context/lookup-namespace this (namespace op))
                 ;; namespace exists: def lookup must have failed
                 (str "no public def " (wrong/q op))
                 (str "no namespace or class " (wrong/q-namespace op)))))
            (parse-invocation ^Expr [op ^seq form] ;discards meta
              (if (symbol? op)
                (let [nm (name op), nmsp (namespace op)]
                  (if (nil? nmsp)
                    (case nm ;FIXME... implement identity as primitive function
                      "identity" (.parse-form this (second form))
                      
                      "def" (def/parse-def this form)
                      "fn*" (fn/parse-fn* this form)
                      "." (parse-dot form)
                      "new" (new/parse-new this (parse-type-expression (second form)) form)
                      
                      #_else (.mk-expr expr-factory form))

                    ;; `op` is qualified symbol: either a reference to
                    ;; a namespace ref, or a static class member
                    (if-some [bnd (context/lookup this op)]
                      bnd
                      (if-some [cl (context/lookup-class this nmsp)]
                        (.invoke-static-member expr-factory true cl nm
                                               (parse-args (rest form)))
                        (throw (wr-info-unresolved-qualified-sym op))))))
                (.mk-expr expr-factory form)))
            
            (wrong-unresolved ^Expr [^symbol sym]
              (wrong/unresolved "undefined symbol " sym))
            (parse-symbol ^Expr [^symbol sym] ;discards meta
              (if-some [bnd (context/lookup this sym)]
                (.bound-value bnd)
                (if-some [cl (interop/lookup-type resolver sym)]
                  (.new-constant expr-factory Class cl)
                  (wrong-unresolved sym))))
            
            (apply-type-hint ^Expr [^Expr x form-tag] ;pre: (some? form-tag)
              (assert false))]

      (if (instance? IMeta form)
        (let [form-meta (.meta ^IMeta form)
              form-tag (interop/get-tag form-meta)]
          (-> (cond
                ;; reference to global def, local binding, defined
                ;; class, or instance field (when in a deftype)
                (symbol? form) (parse-symbol form)
                
                ;; special form, macro form, or some function call variant
                (and (seq? form) (some? (seq form)))
                (let [line (meta/get-line form-meta)]
                  (->> (wrong/with-line-context line
                         (parse-invocation (first form) form))
                       (.line-number expr-factory line)))
                
                ;; vector, map, set, or empty list
                :else (parse-collection-literal form form-meta))
              (cond-> (some? form-tag) (apply-type-hint form-tag))))
        
        ;; keyword, pattern, number, character, string, boolean, nil,
        ;; or (via expansion) a class instance
        (constant/parse-constant this form))))

  (with-bindings* [_ bindings]
    (ScopeImpl. expr-factory resolver bindings)))

(def mk-scope ScopeImpl/new)
