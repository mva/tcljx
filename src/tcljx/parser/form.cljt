(ns tcljx.parser.form
  (:require
   (tcljx.data
    [meta :as meta] [wrong :as wrong] [type :as type] [model :as model])
   (tcljx.parser
    [interop :as interop] [syntax :as syntax] [context :as context] [def :as def]
    [let :as let] [fn :as fn] [new :as new] [constant :as constant]
    [trycatch :as trycatch]))
  (:import
   (tcljx.data.model Resolver Expr Exprs ExprFactory Invocable Scope)
   (clojure.lang IMeta)))

(deftype ScopeImpl [^ExprFactory expr-factory
                    ^Resolver resolver
                    ^map bindings*]
  java.lang.Record
  
  Scope
  (parse-form [this form]
    #_(binding [*print-meta* #_false true]
        (prn :parse-expression form))
    
    (letfn [(parse-args ^Exprs [^seq args]
              (context/parse-args this args))
            (parse-forms ^Exprs [^seq forms] ;FIXME... expand this later?
              (context/parse-args this forms))
            (parse-meta ^Expr [^map form-meta]
              (when form-meta
                (parse-collection-literal form-meta (meta form-meta))))
            (parse-collection-literal-nometa ^Expr [form]
              (cond
                (vector? form)
                (.new-vector expr-factory (parse-args (seq form)))
                (map? form)
                (let [forms (mapcat identity form)]
                  (.new-map expr-factory (parse-args forms)))
                (set? form)
                (.new-set expr-factory (parse-args (seq form)))
                (seq? form)
                (.new-list expr-factory (parse-args (seq form)))
                :else
                (throw (IllegalStateException. (str (class form))))))
            (parse-collection-literal ^Expr [form ^map form-meta]
              (let [x-meta (parse-meta form-meta)
                    x (parse-collection-literal-nometa form)]
                (if (some? x-meta)
                  (.attach-meta-to expr-factory x-meta x)
                  x)))

            (parse-quoted-form ^Expr [form]
              (if (instance? IMeta form)
                ;; symbol, list, vector, map, set
                (let [tp (type/of-quoted-form form)]
                  (.new-loadable expr-factory tp form))
                ;; adjust type to primitive if possible
                (constant/parse-constant-nometa this form)))
            (parse-quote ^Expr [[_ & args]]
              (syntax/empty-tail (next args))
              (parse-quoted-form (syntax/some-first args)))

            (parse-if ^Expr [[_ & formr]]
              (syntax/some-first (next formr)) ;test and first path exist?
              (syntax/empty-tail 3 formr) ;nothing after test and two paths?
              (.if-expr expr-factory (parse-forms formr)))
            (parse-case*-guard ^Exprs [form]
              (if (seq? form)           ;accept empty list!
                (let [gs (.new-exprs expr-factory (count form))]
                  (loop [xs form, i 0]
                    (when (< i (.length gs))
                      (.set gs i (parse-quoted-form (first xs)))
                      (recur (rest xs) (inc i))))
                  gs)
                (doto (.new-exprs expr-factory 1)
                  (.set 0 (parse-quoted-form form)))))
            (parse-case* ^Expr [[_ & formr :as form]]
              (let [select (.parse-form this (syntax/some-first formr))
                    n (- (count formr) 1)
                    has-default? (odd? n)
                    n-paths (quot n 2)
                    gs (new Exprs/1 n-paths)
                    ps (.new-exprs expr-factory (+ n-paths (int has-default?)))
                    ecs (new seq/1 n-paths)]
                (loop [[g p & gpr :as gps] (next formr), i 0]
                  (if (< i n-paths)
                    (do (aset gs i (parse-case*-guard g))
                        (.set ps i (.parse-form this p))
                        (aset ecs i (or (when (seq? g) g) (when (seq? p) p)
                                        form))
                        (recur gpr (inc i)))
                    (do (when has-default?
                          (.set ps i (.parse-form this g)))
                        (.case-expr expr-factory select gs ps ecs))))))
            (parse-do ^Expr [[_ & forms]]
              (if (nil? forms)
                (.empty-expr expr-factory)
                (let [n (count forms)
                      prefix (.new-exprs expr-factory (dec n))]
                  (loop [i 0, [form & formr] forms]
                    (let [x (.parse-form this form)]
                      (if (some? formr)
                        (do (.set prefix i x) (recur (inc i) formr))
                        (.progn-expr expr-factory prefix x)))))))
            
            (parse-throw ^Expr [[_ & args]]
              (let [x (.parse-form this (syntax/some-first args))]
                (syntax/empty-tail (next args))
                (.throw-expr expr-factory x)))
            (parse-instanceof* ^Expr [[_ & args]]
              (let [xs (context/parse-args this args)]
                (syntax/empty-tail 2 args)
                (if-some [tp (model/type-expression (.get xs 0) (first args))]
                  (.instanceof-expr expr-factory tp (.get xs 1))
                  (.invoke-virtual-member expr-factory (.get xs 0) "isInstance"
                                          (.drop xs 1)))))
            
            (parse-import* ^Expr [[_ & formr :as form]]
              (let [specs (map syntax/strip-quote formr)
                    rimports (syntax/flatten-imports nil "" specs form)]
                (.process-imports (context/namespace-builder this)
                                  (reverse rimports))
                (.empty-expr expr-factory)))
            
            (unpack-member-args ^seq [^seq formr]
              (if (seq? (first formr))
                (do (syntax/empty-tail (next formr))
                    (first formr))
                formr))
            (parse-dot ^Expr [[_ owner & formr]]
              (let [[member & args] (unpack-member-args formr)
                    mnm (syntax/simple-symbol-str member) ;implies owner exists
                    owner-expr (.parse-form this owner)
                    xs (parse-args args)
                    fnm (when (and (> (.length mnm) 1) (= (.charAt mnm 0) \-)
                                   (.empty? xs))
                          (.substring mnm 1))]
                (if-some [owner (model/type-expression owner-expr owner)]
                  (if fnm
                    (.get-static-field expr-factory owner fnm)
                    (.invoke-static-member expr-factory false owner mnm xs))
                  (if fnm
                    (.get-virtual-field expr-factory owner-expr fnm)
                    (.invoke-virtual-member expr-factory owner-expr mnm xs)))))
            (parse-dot-dot-or-member ^Expr [^String nm [_ & formr]]
              (if (= nm "..")
                (parse-dot (reduce #(list '. %1 %2)
                                   (list '. (syntax/some-first formr)
                                         (syntax/some-first (next formr)))
                                   (nnext formr)))
                (let [mnm (.substring nm 1)
                      receiver (.parse-form this (syntax/some-first formr))
                      xs (parse-args (rest formr))]
                  (.invoke-virtual-member expr-factory receiver mnm xs))))
            (parse-class-dot ^Expr [^String nm [_ & formr]]
              (let [clnm (.substring nm 0 (dec (.length nm)))]
                (parse-dot (list* \. (symbol nil clnm) 'new formr))))
            
            (wr-info-unresolved-qualified-sym ^Throwable [^symbol op]
              (wrong/wr-info
               (if (context/lookup-namespace this (namespace op))
                 ;; namespace exists: def lookup must have failed
                 (str "no public def " (wrong/q op))
                 (str "no namespace or class " (wrong/q-namespace op)))))
            (parse-invocation ^Expr [op ^seq form] ;discards meta
              (if (symbol? op)
                (let [nm (name op), nmsp (namespace op)]
                  (if (nil? nmsp)
                    (case nm
                      ;; FIXME... implement these as proper primitive
                      ;; functions
                      "identity" (.parse-form this (second form))
                      
                      "def" (def/parse-def this form)
                      ;; loop* (loop*-form form)
                      ;; recur (recur-form form)
                      "if" (parse-if form)
                      "case*" (parse-case* form)
                      "let*" (let/parse-let* this form)
                      ;; letfn* (letfn*-form form)
                      "do" (parse-do form)
                      "fn*" (fn/parse-fn* this form)
                      "quote" (parse-quote form)
                      ;; var (var-form form)
                      "import*" (parse-import* form)
                      "." (parse-dot form)
                      ;; set! (set!-form form)
                      ;; deftype* (deftype*-form form)
                      ;; reify* (reify*-form form)
                      "try" (trycatch/parse-try this form) ;no finally or catch
                      "throw" (parse-throw form)
                      ;; monitor-enter (monitor-form Opcode/MONITORENTER form)
                      ;; monitor-exit (monitor-form Opcode/MONITOREXIT form)
                      ;; catch is only special within `try-form`
                      ;; finally is only special within `try-form`
                      "new" (let [sym (syntax/symbol (second form))]
                              (new/parse-new
                               this (parse-type-symbol sym) form))
                      ;; & is only special within arity signature
                      
                      ;; special forms that are not special in Clojure:
                      ;; "definterface*" (definterface*-form form)
                      "instanceof*" (parse-instanceof* form)
                      #_else
                      (cond
                        (= (.charAt nm 0) \.)
                        (parse-dot-dot-or-member nm form)
                        
                        (= (.charAt nm (dec (.length nm))) \.)
                        (parse-class-dot nm form)
                        
                        :else
                        (if-some [bnd (context/lookup this op)]
                          (if-some [inv (model/bound-invocable bnd)]
                            (.invoke expr-factory form inv
                                     (parse-args (rest form)))
                            (assert false))
                          (throw (wrong/info-unresolved op)))))

                    ;; `op` is qualified symbol: either a reference to
                    ;; a namespace ref, or a static class member
                    (if-some [bnd (context/lookup this op)]
                      bnd
                      (if-some [cl (context/lookup-class this nmsp)]
                        (.invoke-static-member expr-factory true cl nm
                                               (parse-args (rest form)))
                        (condp = op
                          tcljx.data.config/sym-regex-literal
                          ;; FIXME... drop this later
                          (constant/regex-literal this (second form))

                          'tinyclj.lang.primitive/list
                          ;; FIXME... drop this later
                          (parse-collection-literal (rest form) nil)
                          
                          #_else
                          (throw (wr-info-unresolved-qualified-sym op)))))))
                (.mk-expr expr-factory form)))
            
            (parse-class-qualified-symbol ^Expr [^Class nmsp ^String nm]
              (if-some [tp (interop/lookup-type resolver nmsp nm)]
                (.new-constant expr-factory Class tp)
                (.get-static-field expr-factory nmsp nm)))
            (lookup-class-symbol ^Expr [^symbol sym]
              (if-some [nmsp (namespace sym)]
                (when-some [cl (.lookup-class resolver nmsp)]
                  (parse-class-qualified-symbol cl (name sym)))
                (when-some [cl (.lookup-class resolver (name sym))]
                  (.new-constant expr-factory Class cl))))
            (parse-symbol ^Expr [^symbol sym] ;discards meta
              (if-some [bnd (context/lookup this sym)]
                (.bound-value bnd)
                (or (lookup-class-symbol sym)
                    (throw (wrong/info-unresolved sym)))))
            (wr-info-unresolved-type ^Throwable [^symbol sym]
              (wrong/info-unresolved "undefined type symbol " sym))
            (parse-type-symbol ^Class [^symbol sym]
              (if-some [x (lookup-class-symbol sym)]
                (if-some [tp (model/type-expression x sym)]
                  tp
                  (throw (syntax/info "expected type expression" sym)))
                (throw (wr-info-unresolved-type sym))))
            
            (apply-type-hint ^Expr [^Expr x form-tag] ;pre: (some? form-tag)
              (.type-cast expr-factory (parse-type-symbol (syntax/symbol form-tag)) x))]

      (if (instance? IMeta form)
        (let [form-meta (.meta ^IMeta form)
              form-tag (interop/get-tag form-meta)]
          (-> (cond
                ;; reference to global def, local binding, defined
                ;; class, or instance field (when in a deftype)
                (symbol? form) (parse-symbol form)
                
                ;; special form, macro form, or some function call variant
                (and (seq? form) (some? (seq form)))
                (let [line (meta/get-line form-meta)]
                  (->> (wrong/with-line-context line
                         (parse-invocation (first form) form))
                       (.line-number expr-factory line)))
                
                ;; vector, map, set, or empty list
                :else (parse-collection-literal form form-meta))
              (cond-> (some? form-tag) (apply-type-hint form-tag))))
        
        ;; keyword, pattern, number, character, string, boolean, nil,
        ;; or (via expansion) a class instance
        (constant/parse-constant-nometa this form))))

  (with-bindings* [_ bindings]
    (ScopeImpl. expr-factory resolver bindings)))

(def mk-scope ScopeImpl/new)
