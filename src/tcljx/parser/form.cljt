(ns tcljx.parser.form
  (:require
   (tcljx [model :as model])
   (tcljx.parser [meta :as meta] [interop :as interop] [wrong :as wrong]
                 [context :as context] [def :as def] [constant :as constant]))
  (:import
   (tcljx.model Resolver ExprFactory Expr Scope)
   (clojure.lang IMeta)))

(deftype ScopeImpl [^ExprFactory expr-factory
                    ^Resolver resolver
                    ^map bindings*]
  java.lang.Record
  
  Scope
  (parse-form [this form]
    #_(binding [*print-meta* #_false true]
        (prn :parse-expression form))
    
    (letfn [(parse-collection-literal ^Expr [form ^map form-meta]
              (.mk-expr expr-factory form))
            
            (parse-invocation ^Expr [op ^seq form ^int line] ;discards meta
              (if (symbol? op)
                (let [nm (name op), nmsp (namespace op)]
                  (if (nil? nmsp)
                    (case nm
                      "def" (def/parse-def this form line)
                      #_else (.mk-expr expr-factory form))
                    (.mk-expr expr-factory form)))
                (.mk-expr expr-factory form)))
            
            (wrong-unresolved ^Expr [^symbol sym]
              (wrong/unresolved "undefined symbol " sym))
            (parse-symbol ^Expr [^symbol sym] ;discards meta
              (if-some [bnd (context/lookup this sym)]
                (-> expr-factory (.bound-value bnd))
                (wrong-unresolved sym)))
            
            (apply-type-hint ^Expr [^Expr x form-tag] ;pre: (some? form-tag)
              (assert false))]

      (if (instance? IMeta form)
        (let [form-meta (.meta ^IMeta form)
              form-tag (interop/get-tag form-meta)]
          (-> (cond
                ;; reference to global def, local binding, defined
                ;; class, or instance field (when in a deftype)
                (symbol? form) (parse-symbol form)
                
                ;; special form, macro form, or some function call variant
                (and (seq? form) (some? (next form)))
                (wrong/with-line-context form
                  (parse-invocation (first form) form (meta/get-line form-meta)))
                
                ;; vector, map, set, or empty list
                :else (parse-collection-literal form form-meta))
              (cond-> (some? form-tag) (apply-type-hint form-tag))))
        
        ;; keyword, pattern, number, character, string, boolean, nil,
        ;; or (via expansion) a class instance
        (constant/parse-constant this form)))))
