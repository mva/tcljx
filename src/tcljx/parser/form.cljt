(ns tcljx.parser.form
  (:require
   (tcljx.data
    [meta :as meta] [wrong :as wrong] [type :as type] [model :as model])
   (tcljx.parser
    [interop :as interop] [syntax :as syntax] [context :as context] [def :as def]
    [fn :as fn] [new :as new] [constant :as constant]))
  (:import
   (tcljx.data.model Resolver Expr Exprs ExprFactory Scope)
   (clojure.lang IMeta)))

(deftype ScopeImpl [^ExprFactory expr-factory
                    ^Resolver resolver
                    ^map bindings*]
  java.lang.Record
  
  Scope
  (parse-form [this form]
    #_(binding [*print-meta* #_false true]
        (prn :parse-expression form))
    
    (letfn [(parse-args ^Exprs [^seq args]
              (context/parse-args this args))
            (parse-meta ^Expr [^map form-meta]
              (when form-meta
                (parse-collection-literal form-meta (meta form-meta))))
            (parse-collection-literal ^Expr [form ^map form-meta]
              (let [opt-meta (parse-meta form-meta)]
                (cond
                  (vector? form)
                  (.new-vector expr-factory opt-meta (parse-args (seq form)))
                  (map? form)
                  (let [forms (mapcat identity form)]
                    (.new-map expr-factory opt-meta (parse-args forms)))
                  (set? form)
                  (.new-set expr-factory opt-meta (parse-args (seq form)))
                  (seq? form)
                  (.new-list expr-factory opt-meta (parse-args (seq form)))
                  :else
                  (throw (IllegalStateException. (str (class form)))))))

            (parse-quoted-form ^Expr [form]
              (if (instance? IMeta form) ;symbol, list, vector, map, set
                (let [tp (if (seq? form) type/list (class form))]
                  (.new-constant expr-factory tp form))
                (constant/parse-constant this form))) ;adjust type to primitive
            (parse-quote ^Expr [[_ & args]]
              (syntax/empty-tail (next args))
              (parse-quoted-form (syntax/some-first args)))
            
            (type-expression ^Class [^Expr x form] ;nil if no type expression
              (when-some [value (model/const-value x)]
                (when (and (class? value) (syntax/simple-symbol? form))
                  value)))
            (parse-type-expression ^Class [form]
              (let [x (.parse-form this form)]
                (or (type-expression x form)
                    (throw (syntax/info "expected type expression" form)))))

            (unpack-member-args ^seq [^seq formr]
              (if (seq? (first formr))
                (do (syntax/empty-tail (next formr))
                    (first formr))
                formr))
            (parse-dot [[_ owner & formr]]
              (let [[member & args] (unpack-member-args formr)
                    mnm (syntax/simple-symbol-str member) ;implies owner exists
                    owner-expr (.parse-form this owner)
                    xs (parse-args args)]
                (if-some [owner (type-expression owner-expr owner)]
                  (.invoke-static-member expr-factory false owner mnm xs)
                  (.invoke-virtual-member expr-factory owner-expr mnm xs))))
            
            (wr-info-unresolved-qualified-sym ^Throwable [^symbol op]
              (wrong/wr-info
               (if (context/lookup-namespace this (namespace op))
                 ;; namespace exists: def lookup must have failed
                 (str "no public def " (wrong/q op))
                 (str "no namespace or class " (wrong/q-namespace op)))))
            (parse-invocation ^Expr [op ^seq form] ;discards meta
              (if (symbol? op)
                (let [nm (name op), nmsp (namespace op)]
                  (if (nil? nmsp)
                    (case nm
                      ;; FIXME... implement these as proper primitive
                      ;; functions
                      "identity" (.parse-form this (second form))
                      "int" (.parse-form this (.intValue ^Number (second form)))
                      "long" (.parse-form this (.longValue ^Number (second form)))
                      "float" (.parse-form this (.floatValue ^Number (second form)))
                      "double" (.parse-form this (.doubleValue ^Number (second form)))
                      "char" (.parse-form this (char (.intValue ^Number (second form))))
                      "byte" (.parse-form this (.byteValue ^Number (second form)))
                      "short" (.parse-form this (.shortValue ^Number (second form)))
                      
                      "def" (def/parse-def this form)
                      "fn*" (fn/parse-fn* this form)
                      "quote" (parse-quote form)
                      "." (parse-dot form)
                      "new" (new/parse-new this (parse-type-expression (second form)) form)
                      
                      #_else (.mk-expr expr-factory form))

                    ;; `op` is qualified symbol: either a reference to
                    ;; a namespace ref, or a static class member
                    (if-some [bnd (context/lookup this op)]
                      bnd
                      (if-some [cl (context/lookup-class this nmsp)]
                        (.invoke-static-member expr-factory true cl nm
                                               (parse-args (rest form)))
                        (condp = op
                          tcljx.data.config/sym-regex-literal
                          ;; FIXME... drop this later
                          (constant/regex-literal this (second form))

                          'tinyclj.lang.primitive/list
                          ;; FIXME... drop this later
                          (parse-collection-literal (rest form) nil)
                          
                          #_else
                          (throw (wr-info-unresolved-qualified-sym op)))))))
                (.mk-expr expr-factory form)))
            
            (wrong-unresolved ^Expr [^symbol sym]
              (wrong/unresolved "undefined symbol " sym))
            (parse-class-qualified-symbol ^Expr [^Class nmsp ^String nm]
              (if-some [tp (interop/lookup-type resolver nmsp nm)]
                (.new-constant expr-factory Class tp)
                (.get-static-field expr-factory nmsp nm)))
            (parse-symbol ^Expr [^symbol sym] ;discards meta
              (if-some [bnd (context/lookup this sym)]
                (.bound-value bnd)
                (or (if-some [nmsp (namespace sym)]
                      (when-some [cl (.lookup-class resolver nmsp)]
                        (parse-class-qualified-symbol cl (name sym)))
                      (when-some [cl (.lookup-class resolver (name sym))]
                        (.new-constant expr-factory Class cl)))
                    (wrong-unresolved sym))))
            
            (apply-type-hint ^Expr [^Expr x form-tag] ;pre: (some? form-tag)
              (assert false))]

      (if (instance? IMeta form)
        (let [form-meta (.meta ^IMeta form)
              form-tag (interop/get-tag form-meta)]
          (-> (cond
                ;; reference to global def, local binding, defined
                ;; class, or instance field (when in a deftype)
                (symbol? form) (parse-symbol form)
                
                ;; special form, macro form, or some function call variant
                (and (seq? form) (some? (seq form)))
                (let [line (meta/get-line form-meta)]
                  (->> (wrong/with-line-context line
                         (parse-invocation (first form) form))
                       (.line-number expr-factory line)))
                
                ;; vector, map, set, or empty list
                :else (parse-collection-literal form form-meta))
              (cond-> (some? form-tag) (apply-type-hint form-tag))))
        
        ;; keyword, pattern, number, character, string, boolean, nil,
        ;; or (via expansion) a class instance
        (constant/parse-constant this form))))

  (with-bindings* [_ bindings]
    (ScopeImpl. expr-factory resolver bindings)))

(def mk-scope ScopeImpl/new)
