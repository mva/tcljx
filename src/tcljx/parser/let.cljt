(ns tcljx.parser.let
  (:require
   (tcljx.data [wrong :as wrong] [context :as context] [model :as model])
   (tcljx.parser [syntax :as syntax] [interop :as interop]))
  (:import
   (tcljx.data.model Expr ExprFactory Binding Entity Scope)))

(letfn [(binding-for-entity ^Expr [^ExprFactory expr-factory ^long fctx
                                   ^String name ^Entity ent ^Object ent-form]
          (if (model/alias-when-let-value? ent)
            (.binding-alias expr-factory fctx name ent)
            (let [x (.value-of expr-factory ent ent-form)]
              (.binding-fresh expr-factory fctx nil name x))))

        (binding-for-init ^Expr [^ExprFactory expr-factory ^long fctx
                                 ^Class opt-type ^String name ^Expr init]
          (if (and (nil? opt-type) (model/alias-when-let-value? (.emitter init)))
            (.binding-alias expr-factory fctx name (.emitter init))
            (.binding-fresh expr-factory fctx opt-type name init)))]

  (defn parse-let* ^Expr [^Scope scope ^long fctx [_ bindings & body :as form]]
    (let [bindings (syntax/vector bindings true)
          n (quot (count bindings) 2)
          ef (.expr-factory scope)
          bnd-xs (.new-exprs ef n)]
      (loop [scope scope, i 0]
        (if (< i n)
          (let [nm-sym (nth bindings (* i 2))
                nm (syntax/simple-symbol-str nm-sym)
                init (nth bindings (inc (* i 2)))
                opt-type (interop/resolve-tag (.resolver scope) nm-sym nil)
                ent (when (and (nil? opt-type) (symbol? init))
                      (or (context/lookup scope init)
                          (interop/lookup-class-entity scope init)))
                bnd-x (if (some? ent)
                        (binding-for-entity ef fctx nm ent init)
                        (binding-for-init ef fctx opt-type nm
                                          (context/parse-arg scope fctx init)))]
            (.set bnd-xs i bnd-x)
            (recur (context/with-local-binding scope bnd-x) (inc i)))
          (.block-let ef fctx bnd-xs (context/parse-progn scope fctx body)))))))
