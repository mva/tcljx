(ns tcljx.parser.signature
  (:require
   (tcljx [model :as model] [reflect :as reflect])
   (tcljx.parser [interop :as interop] [wrong :as wrong] [syntax :as syntax]))
  (:import (tcljx.model ArityType Resolver Scope Expr)
           (clojure.lang IMeta)))

(defn get-tag [^map form-meta]
  (when (some? form-meta)
    ;; Note: using `valAt` is slightly more direct than IFn.invoke()
    ;; or RT.get().
    (.valAt form-meta :tag nil)))
(defn tag-of ^symbol [form]
  (when-some [tag (get-tag (meta form))]
    (syntax/symbol tag)))
(defn resolve-tag
  (^Class [^Resolver rsv ^IMeta form]
   (resolve-tag rsv form Object))
  (^Class [^Resolver rsv ^IMeta form ^Class or-else]
   (if-some [tag (tag-of form)]
     (or (interop/lookup-type rsv tag) (wrong/class-not-found tag))
     or-else)))

(defn get-param-tags [^map form-meta]
  (when (some? form-meta)
    (.valAt form-meta :param-tags nil)))
(defn param-tags-of ^vector [form]
  (when-some [ptags (get-param-tags (meta form))]
    (syntax/vector ptags)))


(defn parse-arity-type ^ArityType [^Resolver rsv paramv ^seq error-context]
  (letfn [(type-of ^Class [^IMeta form]
            (resolve-tag rsv form))]
    (wrong/with-line-context error-context
      (let [paramv (syntax/vector paramv)
            n (count paramv)
            ptypes (new Class/1 n)
            pnames (new String/1 n)]
        (assert (not= '& (nth paramv (- n 2) nil)))
        (dotimes [i (alength ptypes)]
          (let [param (nth paramv i)
                psym (syntax/simple-symbol param)]
            (aset ptypes i (type-of psym))
            (aset pnames i (name psym))))
        (tcljx.model.ArityTypeImpl. (type-of ^IMeta paramv) ptypes pnames)))))

(defn parameter-bindings ^Expr/1 [^Scope scope ^ArityType at]
  (let [ef (.expr-factory scope)
        xs (.new-array ef (.parameter-count at))]
    (dotimes [i (alength xs)]
      (aset xs i (.new-parameter ef i (.parameter-name at i)
                                 (.parameter-type at i))))
    xs))
