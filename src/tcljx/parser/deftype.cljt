(ns tcljx.parser.deftype
  (:require
   (tcljx.data [config :as cfg] [meta :as meta] [wrong :as wrong]
               [context :as context] [reflect :as reflect] [ir :as ir]
               [code :as code])
   (tcljx.parser [syntax :as syntax] [interop :as interop] [parse :as parse]))
  (:import
   (tcljx.data.ir Expr Binding ArityType AritySpec MethodSpec FieldSpec NmspClass
                  Parser Resolver ExprFactory EntityFactory)
   (java.lang.constant ClassDesc MethodTypeDesc ConstantDescs)
   (java.lang.classfile ClassFile ClassBuilder MethodBuilder CodeBuilder)
   (java.lang.classfile.attribute RecordAttribute RecordComponentInfo)
   (java.util List ArrayList HashMap)
   (java.util.function Consumer)))

(defn- with-abstract-method ^ClassBuilder [^ClassBuilder cb ^String name
                                           ^MethodTypeDesc mtd ^int flags]
  (.withMethod cb name mtd (bit-or (ir/acc* abstract) flags)
               (^Consumer fn ^void [^MethodBuilder mb] #_none)))

(defn- parse-opts ^vector [^seq s]
  (loop [opts {} [k v & rs :as s] s]
    (if (keyword? k)
      (recur (assoc opts k v) rs)
      [opts (into-array clojure.lang.ISeq s)])))

(defn- type-desc-of ^ClassDesc [^Resolver rsv ^symbol tag ^boolean void?
                                ^ClassDesc no-hint]
  (letfn [(class-desc-of ^ClassDesc [^String x]
            (try
              (ClassDesc/of x)
              (catch IllegalArgumentException _
                (throw (syntax/info "invalid class name" x)))))
          (symbol-class-desc ^ClassDesc [^symbol tag]
            (or (some-> (interop/lookup-type rsv tag) (reflect/describe-class))
                (let [nm (.toString tag)]
                  (class-desc-of (cond->> nm
                                   (neg? (.indexOf nm (int \.)))
                                   (str (.ns-str rsv) "."))))))]
    
    (if (some? tag)
      (let [n (interop/array-rank (name tag))]
        (when (and (not void?) (= tag 'void))
          (throw (syntax/info "`void` tag not applicable in this context")))
        (if (zero? n)
          (symbol-class-desc tag)
          (-> (symbol nil (namespace tag))
              (symbol-class-desc)
              (.arrayType n))))
      no-hint)))
(defn- tag-desc-of ^ClassDesc [^Resolver rsv form ^boolean void?
                                ^ClassDesc no-hint]
  (type-desc-of rsv (interop/tag-of form) void? no-hint))

(defn- method-lookup-type ^MethodTypeDesc [^Resolver rsv msig]
  (loop [acc []
         [p :as params] (seq msig)]
    (cond
      (nil? params)
      (-> (tag-desc-of rsv msig true ConstantDescs/CD_Object)
          (MethodTypeDesc/of ^List acc))
                
      (= p '&)
      (let [p (syntax/varargs-parameter params)
            tp (tag-desc-of rsv p false nil)
            tp (cond
                 (nil? tp)
                 (throw (syntax/info "method cannot have rest parameter"))
                 (not (.isArray tp))
                 (throw (wrong/wr-info "type of vararg parameter must be array"))
                 :else tp)]
        (if (nnext params)
          (throw (syntax/info "junk after vararg parameter"))
          (recur (conj acc tp) nil)))   ;VARARGS flag is set by caller

      :else
      (let [tp (tag-desc-of rsv p false ConstantDescs/CD_Object)]
        (recur (conj acc tp) (next params))))))

(defn parse-definterface* ^Expr [^Resolver rsv ^EntityFactory etf ^long fctx
                                 [_ itf-nm & opts+sigs]]
  (letfn [(lookup-interface ^ClassDesc [^symbol sym]
            (reflect/describe-class (interop/resolve-interface rsv sym)))
          
          (method-cbh ^Consumer [[mname msig & methodr]]
            (let [mname (syntax/simple-symbol mname)
                  msig (syntax/vector msig)]
              (syntax/empty-tail methodr)
              (when-some [tag (interop/tag-of mname)]
                (wrong/other (str "method result tag " (wrong/q tag) " must "
                                  "be placed on the parameter vector, not the "
                                  "method name")))
              (let [mnm (name mname)
                    mtd (method-lookup-type rsv msig)
                    flags (cond-> (ir/acc* public)
                            (< (.parameterCount mtd) (count msig))
                            (bit-or (ir/acc* varargs)))]
                (^Consumer fn ^void [^ClassBuilder cb]
                 (with-abstract-method cb mnm mtd flags)))))]
    
    (let [[opts methods] (parse-opts opts+sigs)
          itf-nm (syntax/simple-symbol itf-nm)
          this-class (ClassDesc/of (.ns-str rsv) (name itf-nm))
          extends-itfs (mapv lookup-interface (:extends opts))
          method-cbhs (mapv method-cbh methods)
          cbh (^Consumer fn ^void [^ClassBuilder cb]
               (-> (cfg/with-class-version cb)
                   (.withInterfaceSymbols ^List extends-itfs)
                   (.withFlags (ir/acc* public interface abstract)))
               (doseq [^Consumer cbh method-cbhs]
                 (.accept cbh cb)))]
      (let [bs (.build (ClassFile/of) this-class cbh)
            eph-cl ^Class (.invokeExact (.ephemeral-factory rsv) bs)]
        (.import-class rsv eph-cl)
        (.expr-definterface etf (NmspClass. this-class nil cbh nil eph-cl))))))

;;; ------------------------------------------------------------------------

(deftype Supers [^ClassDesc super-class
                 ^ClassDesc/1 interfaces
                 ^boolean java-record?])

(defn- supers-of
  (^Supers [implements]                 ;`implements` is unordered!
   (loop [super nil
          interfaces ^seq ()
          [^Class cl & clr] (seq implements)]
     (cond
       (nil? cl)
       (supers-of super (reverse interfaces))
       (.isInterface cl)
       (recur super (cons cl interfaces) clr)
       (.isArray cl)
       (throw (wrong/wr-info "class cannot implement array type"))
       (.isPrimitive cl)
       (throw (wrong/wr-info "class cannot implement primitive type"))
       (some? super)
       (throw (wrong/wr-info "class can only extend a single class"))
       :else
       (recur cl interfaces clr))))
  (^Supers [^Class super ^seq interfaces]
   ;; Right now, this does not check whether a constructor with this
   ;; signature exists.  This check is complicated by the fact that
   ;; the constructor may be non-public, like PrintWriter-on in
   ;; core_print.cljt using the protected constructor of Writer.
   (Supers. (reflect/describe-class (or super Object))
            (reflect/describe-class* (into-array Class interfaces))
            (identical? java.lang.Record super))))

(defn- constructor-n ^ClassBuilder [^ClassBuilder cb ^ClassDesc this-class
                                    ^FieldSpec/1 fields ^int n]
  (let [mtd-0 (code/mtd-of-fields fields)]
    (->> (^Consumer fn ^void [^CodeBuilder xb]
          (.aload xb (.receiverSlot xb))
          (dotimes [i (- (alength fields) n)]
            (code/load-parameter xb (aget fields i) i))
          (cond-> xb
            (>= n 4) (-> (.aconst_null) (.aconst_null))
            (>= n 2) (-> (.iconst_0) (.iconst_0)))
          (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME mtd-0)
              (.return_)))
         (.withMethodBody cb ConstantDescs/INIT_NAME
                          (.dropParameterTypes mtd-0 (- (alength fields) n)
                                               (alength fields))
                          (ir/acc* public synthetic)))))

(defn- record-attribute ^ClassBuilder [^ClassBuilder cb ^FieldSpec/1 fields]
  (let [a (new RecordComponentInfo/1 (alength fields))]
    (dotimes [i (alength a)]
      (let [spec (aget fields i)]
        (->> (RecordComponentInfo/of (.field-name spec) (.type-desc spec))
             (aset a i))))
    (.with cb (RecordAttribute/of a))))

;;; See JLS "8.10.1 Record Components": It is a compile-time error for
;;; a record declaration to declare a record component with the name
;;; `clone`, `finalize`, `getClass`, `hashCode`, `notify`,
;;; `notifyAll`, `toString`, or `wait`.
(def ^:private prohibited-record-fields
  #{"clone" "finalize" "getClass" "hashCode" "notify" "notifyAll"
    "toString" "wait"})

(defn- parse-fields ^FieldSpec/1 [^Resolver rsv ^ClassDesc owner
                                  ^boolean java-record? ^vector fieldv]
  (letfn [(parse-field ^FieldSpec [form]
            (let [sym (syntax/simple-symbol form)
                  tag (interop/tag-of sym)
                  tpd (type-desc-of rsv tag false ConstantDescs/CD_Object)
                  nm (name sym)
                  m (meta sym)
                  flags (cond
                          (:unsynchronized-mutable m) (ir/acc* private)
                          (:volatile-mutable m) (ir/acc* private volatile)
                          java-record? (ir/acc* private final)
                          :else (ir/acc* public final))]
              (when java-record?
                (when (zero? (bit-and flags (ir/acc* final)))
                  (wrong/other (str "java.lang.Record cannot have mutable field "
                                    (wrong/q sym))))
                (when (contains? prohibited-record-fields nm)
                  (wrong/other (str "java.lang.Record cannot declare field with name "
                                    "of no-arg Object method " (wrong/q (symbol nm))))))
              (FieldSpec. owner nm tag flags tpd nil)))]
    (let [a (new FieldSpec/1 (count fieldv))]
      (dotimes [i (alength a)]
        (aset a i (parse-field (nth fieldv i))))
      a)))

(def ^:private defrecord-tail (doto (new String/1 4)
                                (aset 0 "__meta") (aset 1 "__extmap")
                                (aset 2 "__hash") (aset 3 "__hasheq")))
(defn- defrecord-tail? ^boolean [^FieldSpec/1 specs]
  (let [base (- (alength specs) (alength defrecord-tail))]
    (letfn [(match? ^boolean [^int i]
            (= (.field-name (aget specs (+ base i))) (aget defrecord-tail i)))]
      (and (>= base 0) (match? 0) (match? 1) (match? 2) (match? 3)))))

(defn- arity-spec-of ^AritySpec [^Resolver rsv ^long fctx ^Class eph-cl
                                 [nm paramv & body :as form]]
  (context/with-line-from-list [fctx form]
    (-> (interop/parse-method-type rsv eph-cl (syntax/simple-symbol nm)
                                   paramv)
        (AritySpec. body form))))

(defn- method-name ^String [^AritySpec aspec]
  (-> aspec .error-context (first) (name)))

(defn- complete-methods ^MethodSpec/1 [^Parser parser ^Class eph-cl
                                       ^String unique-nm ^long fctx
                                       ^int n-fields ^seq/1 methods
                                       ^HashMap owner-e2d ^ArrayList parts]
  (let [arity-methods (new MethodSpec/1 (alength methods))]
    (dotimes [i (alength arity-methods)]
      (let [aspec (arity-spec-of (.resolver parser) fctx eph-cl (aget methods i))
            mspec* (parse/method-spec-template aspec i (method-name aspec))
            etf' (.method-etf (.entity-factory parser) unique-nm n-fields
                              owner-e2d parts)
            parser' (.with-entity-factory parser etf')
            mspec (parse/body-into mspec* true parser' fctx aspec)]
        (aset arity-methods i mspec)))
    arity-methods))

;; Note: Only do rudimentary error messages because this form is
;; produced by a macro.
(defn parse-deftype* ^Expr [^Parser parser ^long fctx
                            [_ ^symbol fq-sym ^symbol binary-sym ^vector fieldv
                             & opts+specs]]
  (let [rsv (.resolver parser)
        etf (.entity-factory parser)
        short-sym (symbol nil (name fq-sym))
        [opts ^seq/1 methods] (parse-opts opts+specs)
        this-class (ClassDesc/of (name binary-sym))
        supers (->> (:implements opts)
                    (mapv #(interop/resolve-class rsv %)) ;eager
                    (supers-of))
        fields (parse-fields rsv this-class (.java-record? supers) fieldv)
        defrecord? (defrecord-tail? fields)
        cbh-0 (^Consumer fn ^void [^ClassBuilder cb]
               (-> (cfg/with-class-version cb)
                   (.withSuperclass (.super-class supers))
                   (.withInterfaceSymbols (.interfaces supers))
                   (.withFlags (cond-> (ir/acc* public final)
                                 (:abstract opts)
                                 (bit-xor (ir/acc* final abstract)))))
               (when (.java-record? supers)
                 (record-attribute cb fields))
               (code/with-field* cb fields)
               (code/constructor cb fields (.super-class supers)
                                 (ir/acc* public synthetic))
               (when defrecord?
                 (constructor-n cb this-class fields 4)
                 (constructor-n cb this-class fields 2)))
        cbh-1 (^Consumer fn ^void [^ClassBuilder cb]
               (when (.java-record? supers)
                 (doseq [^FieldSpec spec fields]
                   (code/with-getter cb spec))))
        bs (.build (ClassFile/of) this-class (.andThen cbh-0 cbh-1))
        eph-cl ^Class (.invokeExact (.ephemeral-factory rsv) bs)
        fbnds (new Binding/1 (alength fields))]
    
    (.import-class rsv eph-cl)
    (dotimes [i (alength fields)]
      (let [fspec* (aget fields i)
            tp (interop/resolve-class rsv (.type-tag fspec*) Object)
            fspec (ir/with-field-type fspec* tp)
            ent-id (ir/entity-id-of (inc (.closure-level etf)) i)]
        (aset fields i fspec)
        (aset fbnds i (-> (.deftype-field etf ent-id fspec)
                          (ir/mk-binding (.field-name fspec) false)))))
    
    (let [eph-ncl (NmspClass. this-class (.super-class supers) cbh-0 nil eph-cl)
          dt-e2d (HashMap.)     ;should remain empty!
          deftype-parts (ArrayList.)]
          ;; note: can call Resolver.globals() only on namespace thread
      (->> (complete-methods (-> (.with-bindings* parser (.globals rsv))
                                 (ir/with-local-bindings fbnds)) eph-cl
                             (.unique-name! etf (.displayName this-class))
                             fctx (alength fields) methods dt-e2d
                             deftype-parts)
           (.expr-deftype etf eph-ncl fields (.java-record? supers)
                          defrecord? deftype-parts)))))

;;; ------------------------------------------------------------------------

(defn parse-reify* ^Expr [^Parser parser ^long fctx ^Expr meta
                          [_ ^vector implementv & methods :as form]]
  (let [rsv (.resolver parser)
        etf (.entity-factory parser)
        this-class (.class-name-for-reify etf)
        supers (->> (map #(interop/resolve-class rsv %) implementv)
                    (cons clojure.lang.IObj)
                    (supers-of))
        methods ^seq/1 (into-array clojure.lang.ISeq methods)
        cbh (^Consumer fn ^void [^ClassBuilder cb]
             (-> (cfg/with-class-version cb)
                 (.withSuperclass (.super-class supers))
                 (.withInterfaceSymbols (.interfaces supers))
                 (.withFlags (ir/acc* public final))))
        bs (.build (ClassFile/of) this-class cbh)
        eph-cl ^Class (.invokeExact (.ephemeral-factory rsv) bs)
        
        eph-ncl (NmspClass. this-class (.super-class supers) cbh nil eph-cl)
        reify-e2d (HashMap.)
        reify-parts (ArrayList.)
        ms (complete-methods parser eph-cl (.displayName this-class) fctx 0
                             methods reify-e2d reify-parts)]
    (.expr-reify etf eph-ncl (.interfaces supers) (.emitter meta)
                 ms reify-e2d reify-parts)))
