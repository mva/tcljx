(ns tcljx.parser.def
  (:require
   (tcljx.data [wrong :as wrong] [model :as model])
   (tcljx.parser [syntax :as syntax] [context :as context]))
  (:import
   (tcljx.data.model Expr Binding Scope)))

(defn parse-def ^Expr [^Scope scope ^long fctx [_ nm-sym & args]]
  (letfn [(aliased-def ^Binding [init]
            (if-some [bnd (context/lookup-if-alias nm-sym scope init)]
              (when (model/global? bnd)
                bnd)))
          (new-def ^Expr [^String nm ^seq init-forms]
            ;; pre: `init-forms` is nil when empty
            ;; post: throws `wrong` when outside namespace context
            (let [nmsp (context/namespace-builder scope)]
              (if (some? init-forms)
                (let [init (first init-forms)]
                  (if-some [bnd (aliased-def init)]
                    (.new-def-alias nmsp nm bnd)
                    (.new-def-init nmsp nm (context/parse-arg scope fctx init))))
                (.new-def-init nmsp nm nil))))
          (assign-to-def ^Expr [^Binding bnd ^seq init-forms]
            (let [init (syntax/some-first init-forms)]
              (-> (.expr-factory scope)
                  (.assignment bnd (context/parse-arg scope fctx init)))))]
    
    (let [nm (syntax/simple-symbol-str nm-sym)
          prior-def (.lookup-def (.resolver scope) nil nm)]
      (syntax/empty-tail (next args))
      (if (some? prior-def)
        (assign-to-def prior-def args)
        (new-def nm args)))))
