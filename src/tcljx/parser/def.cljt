(ns tcljx.parser.def
  (:require
   (tcljx.data [meta :as meta] [wrong :as wrong] [context :as context]
               [model :as model] [type :as type])
   (tcljx.parser [syntax :as syntax] [interop :as interop] [parse :as parse]))
  (:import
   (tcljx.data.model Expr Entity Parser)))

(defn parse-def ^Expr [^Parser parser ^long fctx [_ nm-sym & [init :as args]]]
  (let [nm (syntax/simple-symbol-str nm-sym)
        nm-meta (meta nm-sym)
        nm-tag (meta/get-tag nm-meta)
        x-init (cond-> (if (some? args)
                         (parse/form parser (context/of-progn-prefix fctx) init)
                         (.empty-expr (.expr-factory parser)))
                 (some? nm-tag) (interop/cast-to-tag parser fctx nm-tag))]
    (syntax/empty-tail (next args))
    
    (letfn [(of-immutable-def? ^boolean [^Entity ent] ;pre: `init` is symbol
              (and (model/immediate-entity? ent)
                   (model/alias-when-let-value? ent)
                   (nil? (.meta ^symbol init))
                   (nil? (meta/get-tag nm-meta))
                   (identical? ent (.lookup-def (.resolver parser)
                                                (namespace init) nm))))
            (init-namespace ^String [] ;pre: `init` is symbol
              (when-some [x (namespace init)]
                (.lookup-namespace (.resolver parser) (namespace init))))]
      (if-some [prior-def (.lookup-def (.resolver parser) nil nm)]
        (.assignment (.expr-factory parser) prior-def x-init)

        (let [nmsp (parse/namespace-builder parser)]
          (cond
            (:redef nm-meta)
            (.new-def-mutable nmsp nm x-init)

            (symbol? init)
            (let [ent ^Entity (.emitter x-init)]
              (if (of-immutable-def? ent)
                (.new-def-alias nmsp nm ent (init-namespace) (name init))
                (.new-def-immutable nmsp nm x-init)))

            :else
            (.new-def-immutable nmsp nm x-init)))))))
