(ns tcljx.parser.def
  (:require
   (tcljx.data [wrong :as wrong] [model :as model])
   (tcljx.parser [syntax :as syntax] [context :as context]))
  (:import
   (tcljx.data.model Expr Binding Global Scope)))

(defn parse-def ^Expr [^Scope scope [_ nm & args]]
  (letfn [(aliased-def ^Global [^symbol init]
            (if-some [bnd (context/lookup scope init)]
              (when (model/global? bnd)
                bnd)))
          (new-def ^Expr [^String nm ^seq init-forms]
            ;; pre: `init-forms` is nil when empty
            ;; post: throws `wrong` when outside namespace context
            (let [nmsp (context/namespace-builder scope)
                  ef (.expr-factory scope)]
              (if (some? init-forms)
                (let [init (first init-forms)]
                  (if-some [bnd (when (symbol? init) (aliased-def init))]
                    (.new-def-alias ef nmsp nm bnd)
                    (.new-def-init ef nmsp nm (context/parse-form scope init))))
                (.new-def-init ef nmsp nm nil))))
          (assign-to-def ^Expr [^Binding bnd ^seq init-forms]
            (let [init (syntax/some-first init-forms)]
              (-> (.expr-factory scope)
                  (.assignment bnd (context/parse-form scope init)))))]
    
    (let [nm (syntax/simple-symbol-str nm)
          prior-def (.lookup-def (.resolver scope) nil nm)]
      (syntax/empty-tail (next args))
      (if (some? prior-def)
        (assign-to-def prior-def args)
        (new-def nm args)))))
