(ns tcljx.parser.def
  (:require
   (tcljx [model :as model])
   (tcljx.parser [wrong :as wrong] [syntax :as syntax] [context :as context]))
  (:import
   (tcljx.model Expr Binding Scope)))

(defn parse-def ^Expr [^Scope scope [_ nm & args]]
  (letfn [(aliased-def ^Binding [^symbol init]
            (if-some [bnd (context/lookup scope init)]
              (when (model/def? bnd)
                bnd)))
          (new-def ^Expr [^String nm ^seq init-forms]
            ;; pre: `init-forms` is nil when empty
            ;; post: throws `wrong` when outside namespace context
            (let [init (first init-forms)
                  init-x (when (some? init-forms)
                           (or (when (symbol? init)
                                 (aliased-def init))
                               (context/parse-form scope init)))
                  nmsp (context/namespace-builder scope)]
              (.add-def nmsp nm (-> (.expr-factory scope) 
                                    (.new-def (.ns-str nmsp) nm init-x)))))
          (assign-to-def ^Expr [^Binding bnd ^seq init-forms]
            (let [init (syntax/some-first init-forms)]
              (-> (.expr-factory scope)
                  (.assignment bnd (context/parse-form scope init)))))]
    
    (let [nm (syntax/simple-symbol-str nm)
          prior-def (.lookup-def (.resolver scope) nil nm)]
      (syntax/empty-tail (next args))
      (if (some? prior-def)
        (assign-to-def prior-def args)
        (new-def nm args)))))
