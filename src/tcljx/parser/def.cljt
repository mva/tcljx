(ns tcljx.parser.def
  (:require
   (tcljx.data [meta :as meta] [wrong :as wrong] [context :as context]
               [model :as model])
   (tcljx.parser [syntax :as syntax]))
  (:import
   (tcljx.data.model Expr Entity Scope)))

(defn parse-def ^Expr [^Scope scope ^long fctx [_ nm-sym & args]]
  (letfn [(aliased-def ^Entity [init]
            (when (and (symbol? init)
                       (nil? (.meta ^symbol init))
                       (nil? (meta/get-tag (.meta ^symbol nm-sym))))
              (when-some [ent (context/lookup scope init)]
                (when (model/global? ent)
                  ent))))
          (new-def ^Expr [^String nm ^seq init-forms]
            ;; pre: `init-forms` is nil when empty
            ;; post: throws `wrong` when outside namespace context
            (let [nmsp (context/namespace-builder scope)]
              (if (some? init-forms)
                (let [init (first init-forms)]
                  (if-some [bnd (aliased-def init)]
                    (.new-def-alias nmsp nm bnd)
                    (.new-def-init nmsp nm (context/parse-arg scope fctx init))))
                (.new-def-init nmsp nm (.empty-expr (.expr-factory scope))))))
          (assign-to-def ^Expr [^Entity ent ^seq init-forms]
            (let [init (syntax/first init-forms)]
              (-> (.expr-factory scope)
                  (.assignment ent (context/parse-arg scope fctx init)))))]
    
    (let [nm (syntax/simple-symbol-str nm-sym)
          prior-def (.lookup-def (.resolver scope) nil nm)]
      (syntax/empty-tail (next args))
      (if (some? prior-def)
        (assign-to-def prior-def args)
        (new-def nm args)))))
