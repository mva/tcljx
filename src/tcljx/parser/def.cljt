(ns tcljx.parser.def
  (:require
   (tcljx.data [meta :as meta] [wrong :as wrong] [context :as context]
               [ir :as ir] [type :as type])
   (tcljx.parser [syntax :as syntax] [interop :as interop] [parse :as parse]))
  (:import
   (tcljx.data.ir Expr Entity Parser)))

(defn parse-def ^Expr [^Parser parser ^long fctx [_ nm-sym & [init :as args]]]
  (let [nm (syntax/simple-symbol-str nm-sym)
        nm-meta (meta nm-sym)
        macro? (boolean (:macro nm-meta))
        nm-tag (meta/get-tag nm-meta)
        x-init (cond-> (if (some? args)
                         (parse/form parser (context/of-progn-prefix fctx) init)
                         (.empty-expr (.expr-factory parser)))
                 (some? nm-tag) (interop/cast-to-tag parser fctx nm-tag))]
    (syntax/empty-tail (next args))
    
    (letfn [(of-immutable-def? ^boolean [^Entity ent] ;pre: `init` is symbol
              (and (ir/immediate-entity? ent)
                   (= (ir/binding-mode-let ent) ir/bound-as-alias)
                   (nil? (.meta ^symbol init))
                   (nil? (meta/get-tag nm-meta))
                   (identical? ent (.lookup-def (.resolver parser)
                                                (namespace init) (name init)))))]
      (if-some [prior-def (.lookup-def (.resolver parser) nil nm)]
        (.assignment (.expr-factory parser) prior-def x-init)

        (let [nmsp (parse/namespace-builder parser)]
          (cond
            (:redef nm-meta)
            (do (when macro?
                  (wrong/other ":macro and :redef are mutually exclusive"))
                (.new-def-mutable nmsp nm x-init))

            (symbol? init)
            (let [ent ^Entity (.emitter x-init)]
              (if (of-immutable-def? ent)
                (let [ns (.lookup-namespace (.resolver parser) (namespace init))]
                  (.new-def-alias nmsp nm ent (str ns "/" (name init))))
                (.new-def-immutable nmsp macro? nm x-init)))

            :else
            (.new-def-immutable nmsp macro? nm x-init)))))))
