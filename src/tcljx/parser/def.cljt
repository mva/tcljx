(ns tcljx.parser.def
  (:require
   (tcljx.data [meta :as meta] [wrong :as wrong] [context :as context]
               [ir :as ir] [type :as type])
   (tcljx.parser [syntax :as syntax] [interop :as interop] [parse :as parse]))
  (:import
   (tcljx.data.ir Expr Entity ImmediateEntity Parser)))

(defn parse-def ^Expr [^Parser parser ^long fctx [_ nm-sym & [init :as args]]]
  (let [nm (syntax/simple-symbol-str nm-sym)
        nm-meta (meta nm-sym)
        macro? (boolean (:macro nm-meta))
        nm-tag (meta/get-tag nm-meta)]
    (syntax/empty-tail (next args))
    
    (letfn [(x-init ^Expr []
              (cond-> (if (some? args)
                        (parse/form parser (context/of-progn-prefix fctx) init)
                        (.empty-expr (.expr-factory parser)))
                (some? nm-tag) (interop/cast-to-tag parser fctx nm-tag)))
            (of-immutable-def? ^boolean [^Entity ent] ;pre: `init` is symbol
              (and (ir/immediate-entity? ent)
                   (= (ir/binding-mode-let ent) ir/bound-as-alias)
                   (nil? (.meta ^symbol init))
                   (nil? (meta/get-tag nm-meta))
                   (identical? ent (.lookup-def (.resolver parser)
                                                (namespace init) (name init)))))
            (prior-definition ^Entity [^String nm]
              (when-some [ent (.lookup-def (.resolver parser) nil nm)]
                (when (ir/def-from-this-namespace? ent parser)
                  ent)))]
      (if-some [prior-def (prior-definition nm)]
        (.assignment (.expr-factory parser) prior-def (x-init))

        (let [nmsp (parse/namespace-builder parser)]
          (cond
            (:redef nm-meta)
            (do (when macro?
                  (wrong/other ":macro and :redef are mutually exclusive"))
                (.new-def-mutable nmsp nm (x-init)))

            (symbol? init)
            (let [ent (or (parse/lookup parser init)
                          (interop/lookup-class-entity parser init))]
              (if (of-immutable-def? ent)
                (let [ns (.lookup-namespace (.resolver parser) (namespace init))]
                  (.new-def-alias nmsp nm ent (str ns "/" (name init))))
                (.new-def-immutable nmsp macro? nm (x-init))))

            :else
            (.new-def-immutable nmsp macro? nm (x-init))))))))
