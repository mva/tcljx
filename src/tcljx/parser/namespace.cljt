(ns tcljx.parser.namespace
  (:require (tcljx [config :as cfg] [wrong :as wrong])
            [tcljx.parser.reader :as reader]
            [tcljx.model :as model])
  (:import (tcljx.parser.reader FormBuilder)
           (tcljx.model NamespaceBuilder ProvidedNamespace Require)))

(letfn [(simple-sym-str ^String [form]
          (name (wrong/ensure-simple-sym form)))
        (prefixed-nmsp-str ^String [form ^String prefix]
          (str prefix (simple-sym-str form)))
        
        (second-vector ^vector [^seq xs]
          (let [x (second xs)]
            (if (vector? x)
              (mapv simple-sym-str x)
              (wrong/syntax "expect vector" x))))
        (second-map ^map [^seq xs]
          (let [x (second xs)]
            (if (map? x)
              (-> (reduce (fn [acc [k v]]
                            (assoc! acc (simple-sym-str k) (simple-sym-str v)))
                          (transient {}) x)
                  (persistent!))
              (wrong/syntax "expect map" x))))
        
        (parse-require-spec ^Require [^String ns-str ^seq spec
                                      ^seq error-context]
          (loop [alias nil, refer [], rename {}, exclude []
                 spec (seq spec)]
            (if (some? spec)
              (case (first spec)      ;parse like hash-map then merge 
                :as (recur (simple-sym-str (second spec)) refer rename
                           exclude (nnext spec))
                :refer (recur alias (if (identical? :all (second spec))
                                      nil
                                      (second-vector spec))
                              rename exclude (nnext spec))
                :rename (recur alias refer (second-map spec)
                               exclude (nnext spec))
                ::exclude (recur alias refer rename
                                 (second-vector spec) (nnext spec))
                #_else (wrong/syntax "expect :as, :refer, or :rename"
                                     (first spec)))
              (Require. ns-str alias refer rename exclude error-context))))
        (flatten-requires ^seq [^seq rrequires ^String prefix ^seq specs
                                ^seq error-context]
          (letfn [(flatten-require ^seq [^seq rrequires spec]
                    (cond
                      (symbol? spec)
                      (let [ns-str (prefixed-nmsp-str spec prefix)]
                        (cons
                         (model/require-refer-none ns-str error-context)
                         rrequires))
                      
                      (vector? spec)
                      (let [ns-str (prefixed-nmsp-str (first spec) prefix)]
                        (cons
                         (parse-require-spec ns-str (next spec) error-context)
                         rrequires))
                      
                      (and (= prefix "") (seq? spec))
                      (let [prefix (prefixed-nmsp-str (first spec) prefix)]
                        (flatten-requires rrequires (str prefix ".")
                                          (rest spec) spec))
                      
                      :else
                      (wrong/syntax "expect symbol, vector, or list" spec)))]
            (wrong/with-line-context error-context
              (reduce flatten-require rrequires specs))))
        
        (parse-refer-cljs ^Require [^seq rrefer-cljs]
          (when (some? (nnext rrefer-cljs))
            (wrong/syntax "multiple :refer-clojure clauses"))
          
          (let [refer-clj (first rrefer-cljs)]
            ;; pre: (first refer-clj) is :refer-clojure
            (wrong/with-line-context refer-clj
              (loop [^vector refer nil, exclude [], rename {}
                     specs (next refer-clj)]
                (if (some? specs)
                  (case (first specs) ;parse like hash-map then merge 
                    :only (recur (second-vector specs) exclude rename
                                 (nnext specs))
                    :exclude (recur refer (second-vector specs) rename
                                    (nnext specs))
                    :rename (recur refer exclude (second-map specs)
                                   (nnext specs))
                    #_else (wrong/syntax "expect :only, :exclude, or :rename"
                                         (first specs)))
                  (Require. cfg/core-lib nil refer rename exclude
                            refer-clj))))))

        (process-require ^NamespaceBuilder [^NamespaceBuilder nmsp
                                            ^Require require
                                            ^ProvidedNamespace provided]
          (wrong/with-line-context (.error-context require)
            (if (nil? provided)
              (wrong/unresolved "no such namespace:"
                                (model/required-ns-sym require))
              (.process-require nmsp require provided))))
        (process-requires ^NamespaceBuilder [^NamespaceBuilder nmsp
                                             ^seq requires]
          (let [arequires ^Require/1 (into-array Require requires)
                ans-strs (new String/1 (alength arequires))]
            (dotimes [i (alength ans-strs)]
              (aset ans-strs i (.ns-str (aget arequires i))))
            
            (let [provided (.require-namespaces nmsp ans-strs)]
              (loop [nmsp nmsp, i 0]
                (if (< i (alength provided))
                  (-> nmsp
                      (process-require (aget arequires i) (aget provided i))
                      (recur (inc i)))
                  nmsp)))))

        (flatten-imports ^seq [^seq rimports ^String prefix ^seq specs
                               ^seq error-context]
          (letfn [(flatten-import ^seq [^seq rimports spec]
                    (cond
                      (symbol? spec)
                      (cons (prefixed-nmsp-str spec prefix) rimports)
                      
                      (seq? spec)
                      (let [prefix (prefixed-nmsp-str (first spec) prefix)]
                        (flatten-imports rimports (str prefix ".")
                                         (rest spec) spec))
                      
                      :else
                      (wrong/syntax "expect symbol or list" spec)))]
            (reduce flatten-import rimports specs)))
        
        (matching-ns-sym? ^boolean [^NamespaceBuilder nmsp ns-sym]
          (and (symbol? ns-sym) (= (str ns-sym) (.ns-str nmsp))))
        (ns-form ^NamespaceBuilder [^NamespaceBuilder nmsp
                                    [_ ns-sym & formr :as ^seq form]]
          ;; pre: (first form) is 'ns
          (when-not (matching-ns-sym? nmsp ns-sym)
            (wrong/other (str "ns name mismatch, expected "
                              (wrong/q (symbol nil (.ns-str nmsp)))
                              " but got " (wrong/q ns-sym))))
          (loop [^seq rrequires nil
                 ^seq rimports nil
                 ^seq rrefer-cljs nil
                 clauses (cond-> formr (string? (first formr)) (next))]
            (if-some [[[tag :as clause] & clauses'] clauses]
              (case tag
                :require
                (recur (flatten-requires rrequires "" (next clause) clause)
                       rimports rrefer-cljs clauses')
                
                :import
                (recur rrequires
                       (flatten-imports rimports "" (next clause) clause)
                       rrefer-cljs clauses')
                
                :refer-clojure
                (recur rrequires rimports (cons clause rrefer-cljs) clauses')
                
                #_else
                (wrong/syntax "expect :require, :import, or :refer-clojure" tag))
              (let [requires (reverse rrequires)
                    requires (cond
                               (nil? rrefer-cljs)
                               (cons model/require-core-lib-default requires)
                               (= rrefer-cljs '((:refer-clojure :none)))
                               requires
                               :else
                               (cons (parse-refer-cljs rrefer-cljs) requires))]
                (-> (process-requires nmsp requires)
                    (.process-imports (reverse rimports)))))))
        (require-form ^NamespaceBuilder [^NamespaceBuilder nmsp ^seq form]
          (let [specs (map model/strip-quote (rest form))
                rrequires (flatten-requires nil "" specs form)]
            (process-requires nmsp (reverse rrequires))))
        (load-form ^NamespaceBuilder [^NamespaceBuilder nmsp ^seq form]
          (reduce NamespaceBuilder/.load-file nmsp (rest form)))
        (in-ns-form ^NamespaceBuilder [^NamespaceBuilder nmsp
                                       [_ ns-sym & formr :as ^seq form]]
          ;; pre: (first form) is 'in-ns
          (if (and (nil? formr)
                   (matching-ns-sym? nmsp (model/strip-quote ns-sym)))
            nmsp
            (wrong/other (str "in-ns argument does not match current "
                              "namespace " (wrong/q ns-sym)))))
        
        (non-namespace-form ^NamespaceBuilder [^NamespaceBuilder nmsp form]
          (.add-form nmsp form))
        (top-level-list-form ^NamespaceBuilder [^NamespaceBuilder nmsp ^seq form]
          (wrong/with-line-context form
            (case (first form)
              ns (ns-form nmsp form)
              require (require-form nmsp form)
              load (load-form nmsp form)
              in-ns (in-ns-form nmsp form)
              #_else (non-namespace-form nmsp form))))]
  
  (defn parse-top-level-form ^NamespaceBuilder [^NamespaceBuilder nmsp form]
    (if (seq? form)
      (top-level-list-form nmsp form)
      (non-namespace-form nmsp form)))

  ;; Note: Does not establish error context for the file.
  (defn parse-top-level-forms ^NamespaceBuilder [^NamespaceBuilder nmsp
                                                 ^int pos ^FormBuilder fb]
    (let [pos' (reader/push-1 pos fb (.resolver-at-point nmsp))]
      (if (neg? pos')
        nmsp
        (recur (parse-top-level-form nmsp (.pop fb)) pos' fb)))))
