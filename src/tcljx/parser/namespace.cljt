(ns tcljx.parser.namespace
  (:require (tcljx [config :as cfg])
            (tcljx.parser [meta :as meta] [wrong :as wrong] [reader :as reader]
                          [syntax :as syntax] [context :as context])
            [tcljx.model :as model])
  (:import (tcljx.parser.reader FormBuilder)
           (tcljx.model NamespaceBuilder ProvidedNamespace Require)))

;;; The parser layer handles syntax (obviously), it resolves
;;; names (managing defs and bindings in general), and it decides what
;;; to expand (if its a macro invocation) and what to evaluate (if it
;;; is a special form, a primitive function, an invocation, and so
;;; on).  What it doesn't do is deriving or working with the type of
;;; an evaluated expression.

(letfn [(prefixed-nmsp-str ^String [form ^String prefix]
          (str prefix (syntax/simple-sym-str form)))
        
        (second-vector ^vector [^seq xs]
          (mapv syntax/simple-sym-str (syntax/vector (second xs))))
        (second-map ^map [^seq xs]
          (persistent! (reduce (fn [acc [k v]]
                                 (assoc! acc (syntax/simple-sym-str k)
                                         (syntax/simple-sym-str v)))
                               (transient {})
                               (syntax/map (second xs)))))
        
        (parse-require-spec ^Require [^String ns-str ^seq spec
                                      ^seq error-context]
          (loop [alias nil, refer [], rename {}, exclude []
                 spec (seq spec)]
            (if (some? spec)
              (case (first spec)      ;parse like hash-map then merge 
                :as (recur (syntax/simple-sym-str (second spec)) refer rename
                           exclude (nnext spec))
                :refer (recur alias (if (identical? :all (second spec))
                                      nil
                                      (second-vector spec))
                              rename exclude (nnext spec))
                :rename (recur alias refer (second-map spec)
                               exclude (nnext spec))
                ::exclude (recur alias refer rename
                                 (second-vector spec) (nnext spec))
                #_else (syntax/wrong "expect :as, :refer, or :rename"
                                     (first spec)))
              (Require. ns-str alias refer rename exclude error-context))))
        (flatten-requires ^seq [^seq rrequires ^String prefix ^seq specs
                                ^seq error-context]
          (letfn [(flatten-require ^seq [^seq rrequires spec]
                    (cond
                      (symbol? spec)
                      (let [ns-str (prefixed-nmsp-str spec prefix)]
                        (cons
                         (model/require-refer-none ns-str error-context)
                         rrequires))
                      
                      (vector? spec)
                      (let [ns-str (prefixed-nmsp-str (first spec) prefix)]
                        (cons
                         (parse-require-spec ns-str (next spec) error-context)
                         rrequires))
                      
                      (and (= prefix "") (seq? spec))
                      (let [prefix (prefixed-nmsp-str (first spec) prefix)]
                        (flatten-requires rrequires (str prefix ".")
                                          (rest spec) spec))
                      
                      :else
                      (syntax/wrong "expect symbol, vector, or list" spec)))]
            (wrong/with-line-context error-context
              (reduce flatten-require rrequires specs))))
        
        (parse-refer-cljs ^Require [^seq rrefer-cljs]
          (when (some? (nnext rrefer-cljs))
            (syntax/wrong "multiple :refer-clojure clauses"))
          
          (let [refer-clj (first rrefer-cljs)]
            ;; pre: (first refer-clj) is :refer-clojure
            (wrong/with-line-context refer-clj
              (loop [^vector refer nil, exclude [], rename {}
                     specs (next refer-clj)]
                (if (some? specs)
                  (case (first specs) ;parse like hash-map then merge 
                    :only (recur (second-vector specs) exclude rename
                                 (nnext specs))
                    :exclude (recur refer (second-vector specs) rename
                                    (nnext specs))
                    :rename (recur refer exclude (second-map specs)
                                   (nnext specs))
                    #_else (syntax/wrong "expect :only, :exclude, or :rename"
                                         (first specs)))
                  (Require. cfg/core-lib nil refer rename exclude
                            refer-clj))))))

        (process-require ^NamespaceBuilder [^NamespaceBuilder nmsp
                                            ^Require require
                                            ^ProvidedNamespace provided]
          (wrong/with-line-context (.error-context require)
            (if (nil? provided)
              (wrong/unresolved "no such namespace:"
                                (model/required-ns-sym require))
              (.process-require nmsp require provided))))
        (process-requires ^NamespaceBuilder [^NamespaceBuilder nmsp
                                             ^seq requires]
          (let [arequires ^Require/1 (into-array Require requires)
                ans-strs (new String/1 (alength arequires))]
            (dotimes [i (alength ans-strs)]
              (aset ans-strs i (.ns-str (aget arequires i))))
            
            (let [provided (-> nmsp .universe (.require-namespaces ans-strs))]
              (loop [nmsp nmsp, i 0]
                (if (< i (alength provided))
                  (-> nmsp
                      (process-require (aget arequires i) (aget provided i))
                      (recur (inc i)))
                  nmsp)))))

        (flatten-imports ^seq [^seq rimports ^String prefix ^seq specs
                               ^seq error-context]
          (letfn [(flatten-import ^seq [^seq rimports spec]
                    (cond
                      (symbol? spec)
                      (cons (prefixed-nmsp-str spec prefix) rimports)
                      
                      (seq? spec)
                      (let [prefix (prefixed-nmsp-str (first spec) prefix)]
                        (flatten-imports rimports (str prefix ".")
                                         (rest spec) spec))
                      
                      :else
                      (syntax/wrong "expect symbol or list" spec)))]
            (reduce flatten-import rimports specs)))
        
        (ns-form ^NamespaceBuilder [^NamespaceBuilder nmsp
                                    [_ ns-sym & formr :as ^seq form]]
          ;; pre: (first form) is 'ns
          (when-not (= ns-sym (model/ns-sym nmsp))
            (wrong/other (str "ns name mismatch, expected "
                              (wrong/q (model/ns-sym nmsp))
                              (wrong/got-q ns-sym))))
          (loop [^seq rrequires nil
                 ^seq rimports nil
                 ^seq rrefer-cljs nil
                 clauses (syntax/next-if-string formr)]
            (if-some [[[tag :as clause] & clauses'] clauses]
              (case tag
                :require
                (recur (flatten-requires rrequires "" (next clause) clause)
                       rimports rrefer-cljs clauses')
                
                :import
                (recur rrequires
                       (flatten-imports rimports "" (next clause) clause)
                       rrefer-cljs clauses')
                
                :refer-clojure
                (recur rrequires rimports (cons clause rrefer-cljs) clauses')
                
                #_else
                (syntax/wrong "expect :require, :import, or :refer-clojure" tag))
              (let [requires (reverse rrequires)
                    requires (cond
                               (nil? rrefer-cljs)
                               (cons model/require-core-lib-default requires)
                               (= rrefer-cljs '((:refer-clojure :none)))
                               requires
                               :else
                               (cons (parse-refer-cljs rrefer-cljs) requires))]
                (-> (process-requires nmsp requires)
                    (.process-imports (reverse rimports)))))))
        (require-form ^NamespaceBuilder [^NamespaceBuilder nmsp ^seq form]
          (let [specs (map syntax/strip-quote (rest form))
                rrequires (flatten-requires nil "" specs form)]
            (process-requires nmsp (reverse rrequires))))
        (load-form ^NamespaceBuilder [^NamespaceBuilder nmsp ^seq form]
          (reduce NamespaceBuilder/.load-file nmsp (rest form)))
        (in-ns-form ^NamespaceBuilder [^NamespaceBuilder nmsp
                                       [_ ns-sym & formr :as ^seq form]]
          ;; pre: (first form) is 'in-ns
          (if (and (nil? formr)
                   (= (syntax/strip-quote ns-sym) (model/ns-sym nmsp)))
            nmsp
            (wrong/other (str "in-ns argument does not match current "
                              "namespace " (wrong/q (model/ns-sym nmsp))
                              (wrong/got-q ns-sym)))))]
  
  (defn parse-top-level-form ^NamespaceBuilder [^NamespaceBuilder nmsp form]
    ;; pre: caller provides wrong/with-line-context for `form`
    (if (seq? form)
      (wrong/with-line-context form
        (case (first form)
          ns (ns-form nmsp form)
          require (require-form nmsp form)
          load (load-form nmsp form)
          in-ns (in-ns-form nmsp form)
          #_else (.process-init-form nmsp form)))
      (.process-init-form nmsp form)))

  ;; Note: Does not establish error context for the file.
  (defn parse-top-level-forms ^NamespaceBuilder [^NamespaceBuilder nmsp
                                                 ^int pos ^FormBuilder fb]
    (let [line-at-push (.current-line fb) ;may be followed by whitespace
          pos' (reader/push-1 pos fb nmsp)]
      (letfn [(with-line-number ^Throwable [^Throwable ex form]
                (let [line-at-end (.current-line fb)
                      ln (cond
                           (seq? form) (meta/line-of form)
                           (symbol? form) line-at-end ;any single line form
                           :else line-at-push)]
                  (wrong/decorate-with-line-number* ex ln)))]
        (if (neg? pos')
          nmsp
          (let [form (.pop fb)]
            (-> (try
                  (parse-top-level-form nmsp form)
                  (catch Throwable ex
                    (throw (with-line-number ex form))))
                (recur pos' fb))))))))
