(ns tcljx.parser.syntax
  (:require (tcljx.data [config :as cfg] [wrong :as wrong]))
  (:refer-clojure :exclude [vector map symbol]))

(defn info
  (^Throwable [^String msg]
   (wrong/wr-info msg))
  (^Throwable [^String msg-prefix form]
   (wrong/wr-info-line-number (str msg-prefix (wrong/got-q form)) form)))

;;; ------------------------------------------------------------------------

(defn strip-quote [x]
  (if (and (seq? x) (= cfg/sym-quote (first x)) (nil? (nnext x)))
    (second x)
    x))

(defn next-if-string ^seq [^seq xs]
  (cond-> xs (string? (first xs)) (next)))

(defn empty-tail ^void [^seq forms]    ;pre: `forms` is nil when empty
  (when (some? forms)
    (throw (info "unexpected arguments at end" forms))))

(defn some-first [^seq forms]          ;pre: `forms` is nil when empty
  (if (some? forms)
    (first forms)
    (throw (info "missing argument"))))

;;; ------------------------------------------------------------------------

(defn simple-symbol? ^boolean [form]
  (and (symbol? form) (nil? (namespace form))))

(defn symbol ^symbol [form]
  (if (symbol? form)
    form
    (throw (info "expect symbol" form))))
(defn simple-symbol ^symbol [form]
  (if (simple-symbol? form)
    form
    (throw (info "expect unqualified symbol" form))))

(defn simple-symbol-str ^String [form]
  (name (simple-symbol form)))

(defn vector ^vector [form]
  (if (vector? form)
    form
    (throw (info "expect vector" form))))

(defn map ^map [form]
  (if (map? form)
    form
    (throw (info "expect map" form))))

