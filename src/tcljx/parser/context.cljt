(ns tcljx.parser.context
  (:require (tcljx.data [meta :as meta] [wrong :as wrong] [model :as model]))
  (:import (tcljx.data.model Resolver NamespaceBuilder Binding
                             Expr Exprs ExprFactory Scope)))

;;; Some form of "cannot do this at this position" error message.
(defn wrong [^String msg]
  (throw (wrong/wr-info msg)))

;;; ------------------------------------------------------------------------

(defn new-exprs ^Exprs [^Scope scope ^int n]
  (.new-exprs (.expr-factory scope) n))

(defn parse-form ^Expr [^Scope scope form]
  (.parse-form scope form))
(defn parse-args ^Exprs [^Scope scope ^seq forms]
  (let [xs (new-exprs scope (count forms))]
    (loop [i 0, forms (seq forms)]
      (when (some? forms)
        (.set xs i (parse-form scope (first forms)))
        (recur (inc i) (next forms))))
    xs))

(defn- parse-progn* ^Expr [^Scope scope ^seq forms] ;pre: `forms` is nil if empty
  (if (some? forms)
    (let [n (count forms), xs (new-exprs scope (dec n))]
      (loop [i 0, forms forms]
        (let [x (parse-form scope (first forms))]
          (if (< i (.length xs))
            (do (.set xs i x)
                (recur (inc i) (rest forms)))
            (.progn-expr (.expr-factory scope) xs x)))))
    (.empty-expr (.expr-factory scope))))
(defn parse-progn
  (^Expr [^Scope scope ^seq forms]
   (parse-progn* scope (seq forms)))
  (^Expr [^Scope scope ^seq error-context ^seq forms]
   (let [line (meta/line-of error-context)]
     (->> (wrong/with-line-context line
            (parse-progn* scope (seq forms)))
          (.line-number (.expr-factory scope) line)))))

;;; Anything outside of a function or a class definition (that is
;;; definterface, deftype, reify, etc.) happens in the namespace
;;; context.
;; (defn namespace? ^boolean [^Resolver rsv]
;;   (instance? tcljx.model.NamespaceResolver rsv))

;;; Returns nil if `form` does not resolve to a binding.
(defn lookup ^Binding [^Scope scope ^symbol form]
  (let [nm (name form)]
    (if-some [nmsp (namespace form)]
      ;; a qualified name always refers to a namespace-level def
      (.lookup-def (.resolver scope) nmsp nm)
      
      ;; for a simple name, the assumption is that a lookup in
      ;; `bindings*` is accurate with very high probability
      (or (.valAt (.bindings* scope) nm nil)
          (.lookup-def (.resolver scope) nil nm))))) ;to cover all defs

;;; Returns nil if `nm` does not resolve to a class name.
(defn lookup-namespace ^String [^Scope scope ^String alias]
  (.lookup-namespace (.resolver scope) alias))

;;; Returns nil if `nm` does not resolve to a class name.
(defn lookup-class ^Class [^Scope scope ^String nm]
  (.lookup-class (.resolver scope) nm))

(defn namespace-builder ^NamespaceBuilder [^Scope scope]
  (let [rsv (.resolver scope)]
    (if (instance? NamespaceBuilder rsv)
      rsv
      (wrong "cannot manipulate namespace data in this position"))))

(defn pick-unique-name ^String [^Scope scope ^String nm]
  (.pick-unique-name (.resolver scope) nm))

;;; ------------------------------------------------------------------------

(defn with-local-binding ^Scope [^Scope scope ^String name ^Expr bound]
  (.with-bindings* scope (assoc (.bindings* scope) name
                                ^Binding (model/require-entity bound))))

(defn with-local-bindings ^Scope [^Scope scope ^String/1 names ^Exprs bounds]
  (loop [locals (transient (.bindings* scope))
         i 0]
    (if (< i (.length bounds))
      (recur (assoc! locals (aget names i)
                     ^Binding (model/require-entity bounds i))
             (inc i))
      (.with-bindings* scope (persistent! locals)))))
