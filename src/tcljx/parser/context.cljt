(ns tcljx.parser.context
  (:require (tcljx [model :as model])
            (tcljx.parser [meta :as meta] [wrong :as wrong]))
  (:import (tcljx.model Resolver NamespaceBuilder Binding
                        Expr ExprFactory Scope)))

;;; Some form of "cannot do this at this position" error message.
(defn wrong [^String msg]
  (throw (wrong/wr-info msg)))

;;; ------------------------------------------------------------------------

(defn parse-form ^Expr [^Scope scope form]
  (.parse-form scope form))

(defn- expr-array ^Expr/1 [^Scope scope ^int n]
  (.new-array (.expr-factory scope) n))

#_
(defn parse-forms ^Expr [^Scope scope ^seq error-context ^seq forms]
  (let [line (meta/line-of error-context)]
    (->> (wrong/with-line-context line
           (let [a (expr-array scope (count forms))]
             (loop [i 0, xs (seq forms)]
               (when (some? xs)
                 (aset a i (parse-form scope (first xs)))
                 (recur (inc i) (next xs))))
             a))
         (.progn (.expr-factory scope))
         (.line-number (.expr-factory scope) line))))

;;; Anything outside of a function or a class definition (that is
;;; definterface, deftype, reify, etc.) happens in the namespace
;;; context.
;; (defn namespace? ^boolean [^Resolver rsv]
;;   (instance? tcljx.model.NamespaceResolver rsv))

;;; Returns nil if `form` does not resolve to a binding.
(defn lookup ^Binding [^Scope scope ^symbol form]
  (let [nm (name form)]
    (if-some [nmsp (namespace form)]
      ;; a qualified name always refers to a namespace-level def
      (.lookup-def (.resolver scope) nmsp nm)
      
      ;; for a simple name, the assumption is that a lookup in
      ;; `bindings*` is accurate with very high probability
      (or (.valAt (.bindings* scope) nm nil)
          (.lookup-def (.resolver scope) nil nm))))) ;to cover all defs

;;; Returns nil if `nm` does not resolve to a class name.
(defn lookup-namespace ^String [^Scope scope ^String alias]
  (.lookup-namespace (.resolver scope) alias))

;;; Returns nil if `nm` does not resolve to a class name.
(defn lookup-class ^Class [^Scope scope ^String nm]
  (.lookup-class (.resolver scope) nm))

(defn namespace-builder ^NamespaceBuilder [^Scope scope]
  (let [rsv (.resolver scope)]
    (if (instance? NamespaceBuilder rsv)
      rsv
      (wrong "cannot def new namespace entry in this position"))))
