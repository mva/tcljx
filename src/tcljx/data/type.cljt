(ns tcljx.data.type
  (:import (java.lang.classfile CodeBuilder TypeKind)
           (java.lang.constant ConstantDesc)
           (java.util.function BiConsumer))
  (:refer-clojure :exclude [symbol keyword vector map set list
                            byte short int long float double char boolean void]))

(defn same? ^boolean [^Class a ^Class b]
  (identical? a b))

#_(defn numeric? ^boolean [^Class tp]
    (and (.isPrimitive tp) (not (or (identical? Character/TYPE tp)
                                    (identical? Boolean/TYPE tp)
                                    (identical? Void/TYPE tp)))))

#_(defn reference? ^boolean [^Class tp]
    (not (.isPrimitive tp)))

;;; From the point of view of Clojure there are no statements, only
;;; expressions producing some value.  Accordingly, the Java type
;;; `void` has no equivalent in Clojure.  Any expression "returning
;;; void" is interpreted as returning one of nil, zero, false, or
;;; \u0000 depending on context.
;;; 
;;; For this reason, reinterpret for an expression the primitive type
;;; `void` as "can produce a value of arbitrary type depending on the
;;; context of use".  On the JVM level, these arbitrary types include
;;; the logical JVM type `void` and the type `nil` denoting an
;;; instruction that does not return.
(def polymorphic Void/TYPE)
(defn polymorphic? ^boolean [^Class expr-type]
  (identical? Void/TYPE expr-type))

(defn monomorphic-primitive? ^boolean [^Class expr-type]
  (and (.isPrimitive expr-type) (not (identical? Void/TYPE expr-type))))

;;; The type of the special reference `nil`.  Also known as nullptr.
(def poly-reference Void)
(defn poly-reference? ^boolean [^Class expr-type]
  (identical? Void expr-type))

;;; Maps a Clojure expression type to the logical Java type to be used
;;; in a class file element.  The returned value is never `void`.
(defn expr-to-logical ^Class [^Class expr-type]
  (if (or (polymorphic? expr-type)
          #_(poly-reference? expr-type))
    Object
    expr-type))

;;; ------------------------------------------------------------------------

(defn any-primitive? ^boolean [^Class/1 types]
  (loop [i (dec (alength types))]
    (cond (neg? i) false
          (.isPrimitive (aget types i)) true
          :else (recur (dec i)))))
(defn any-monomorphic-primitive? ^boolean [^Class/1 types ^int start ^int end]
  (loop [i (dec end)]
    (cond (< i start) false
          (monomorphic-primitive? (aget types i)) true
          :else (recur (dec i)))))

;;; ------------------------------------------------------------------------

(defn type-dimensions ^int [^Class tp]
  (loop [n 0, tp tp]
    (if (.isArray tp)
      (recur (inc n) (.componentType tp))
      n)))

(defn array-type-of-class ^Class [^Class cl ^int array-rank]
  (if (zero? array-rank)
    cl
    (recur (.arrayType cl) (dec array-rank))))

(defn type-symbol ^symbol [^Class tp]
  (let [n (type-dimensions tp)]
    (if (zero? n)
      (tinyclj.core/symbol nil (.getName tp))
      (tinyclj.core/symbol (loop [cl tp]
                             (if (.isArray cl)
                               (recur (.componentType cl))
                               (.getName cl)))
                           (str n)))))

;;; ------------------------------------------------------------------------

(definterface AutoReturnMarker)         ;interface implies abstract
(def auto-return-marker AutoReturnMarker)
(defn auto-return-marker? ^boolean [^Class tp] (same? AutoReturnMarker tp))

;;; ------------------------------------------------------------------------

(defn- primitive-id ^int [^Class tp]    ;pre: (.isPrimitive tp)
  ;; numbering follows xa(load|store), with the exception of boolean and void
  (condp identical? tp 
    Integer/TYPE #_int 0                ;iaload and iastore
    Long/TYPE #_long 1                  ;laload and lastore
    Float/TYPE #_float 2                ;faload and fastore
    Double/TYPE #_double 3              ;daload and dastore
    Boolean/TYPE #_boolean 4            ;takes place of aaload/aastore
    Byte/TYPE #_byte 5                  ;baload and bastore
    Character/TYPE #_char 6             ;caload and castore
    Short/TYPE #_short 7                ;saload and sastore
    Void/TYPE #_void 8                  ;arbitrary
    #_else (throw (IllegalArgumentException.))))

;;; Like the primitive equivalent, the reference class of a box type
;;; is final.  This means, that an `isAssignableFrom` check reduces to
;;; an identity test.
;;; 
;;; Note: `convert-from` does not get any line number information.
;;; Therefore the conversion functions must only emit bytecodes that
;;; cannot throw.  Conversion from void produces the zero value of the
;;; target type.
(deftype Wrapper [^Class class-primitive
                  ^Class class-reference
                  ^Class class-computational
                  ^boolean numeric?
                  ^short mask-assignable-from
                  ^int primitive-id     ;4 for boolean, 8 for void
                  ^BiConsumer convert-from]
  java.lang.Record)

(letfn [(wrapper ^Wrapper [^Class class-primitive
                           ^Class class-reference
                           ^Class class-computational
                           ^Wrapper assignable-from
                           ^BiConsumer convert-to]
          (let [prim-id (primitive-id class-primitive)]
            (Wrapper. class-primitive class-reference class-computational
                      (.isAssignableFrom Number class-reference)
                      (tinyclj.core/short
                       (cond-> (bit-set 0 prim-id)
                         (some? assignable-from)
                         (bit-or (.mask-assignable-from assignable-from))))
                      prim-id convert-to)))]
  (def byte
    (wrapper Byte/TYPE Byte Integer/TYPE nil
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.primitive-id from)
                (#_int 0 #_char 6 #_short 7) (-> xb .i2b)
                #_long 1 (-> xb .l2i .i2b)
                #_float 2 (-> xb .f2i .i2b)
                #_double 3 (-> xb .d2i .i2b)
                (#_byte 5 #_boolean 4) nil
                #_else_void (-> xb .iconst_0)))))
  (def short
    (wrapper Short/TYPE Short Integer/TYPE byte
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.primitive-id from)
                (#_int 0 #_char 6) (-> xb .i2s)
                #_long 1 (-> xb .l2i .i2s)
                #_float 2 (-> xb .f2i .i2s)
                #_double 3 (-> xb .d2i .i2s)
                (#_byte 5 #_short 7 #_boolean 4) nil
                #_else_void (-> xb .iconst_0)))))
  (def int
    (wrapper Integer/TYPE Integer Integer/TYPE short
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.primitive-id from)
                (#_int 0 #_byte 5 #_char 6 #_short 7 #_boolean 4) nil
                #_long 1 (-> xb .l2i)
                #_float 2 (-> xb .f2i)
                #_double 3 (-> xb .d2i)
                #_else_void (-> xb .iconst_0)))))
  (def long
    (wrapper Long/TYPE Long Long/TYPE int
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.primitive-id from)
                (#_int 0 #_byte 5 #_char 6 #_short 7 #_boolean 4) (-> xb .i2l)
                #_long 1 nil
                #_float 2 (-> xb .f2l)
                #_double 3 (-> xb .d2l)
                #_else_void (-> xb .lconst_0)))))
  (def float
    (wrapper Float/TYPE Float Float/TYPE long
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.primitive-id from)
                #_long 1 (-> xb .l2f)
                #_float 2 nil
                #_double 3 (-> xb .d2f)
                (#_int 0 #_byte 5 #_char 6 #_short 7 #_boolean 4) (-> xb .i2f)
                #_else_void (-> xb .fconst_0)))))
  (def double
    (wrapper Double/TYPE Double Double/TYPE float
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.primitive-id from)
                (#_int 0 #_byte 5 #_char 6 #_short 7 #_boolean 4) (-> xb .i2d)
                #_long 1 (-> xb .l2d)
                #_float 2 (-> xb .f2d)
                #_double 3 nil
                #_else_void (-> xb .dconst_0)))))
  
  (def boolean
    (wrapper Boolean/TYPE Boolean Integer/TYPE nil
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (letfn [#_(mask-int ^CodeBuilder [^CodeBuilder xb]
                          (-> xb (.iconst_1) (.iand)))]
                (case (.primitive-id from)
                  #_boolean 4 nil
                  ;; #_float 2 (-> xb .f2i (mask-int))
                  ;; #_double 3 (-> xb .d2i (mask-int))
                  ;; (#_char 6 #_byte 5 #_short 7 #_int 0) (-> xb (mask-int))
                  ;; #_long 1 (-> xb .l2i (mask-int))
                  #_else_void (-> xb .iconst_0))))))
  
  (def char
    (wrapper Character/TYPE Character Integer/TYPE nil ;not numeric in Clojure
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.primitive-id from)
                (#_int 0 #_byte 5 #_short 7 #_boolean 4) (-> xb .i2c)
                #_long 1 (-> xb .l2i .i2c)
                #_float 2 (-> xb .f2i .i2c)
                #_double 3 (-> xb .d2i .i2c)
                #_char 6 nil
                #_else_void (-> xb .iconst_0)))))
  (def void
    (Wrapper. Void/TYPE Void Void/TYPE false (tinyclj.core/short -1) 9
              nil #_(^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
                     (assert false)))))

(def primitive-types   ;arbitrary, follow `aload-astore-delta` for now
  [void int long float double #_reference byte char short boolean])

(defn primitive-assignable-from? ^boolean [^Wrapper ptype ^Wrapper atype]
  (bit-test (.mask-assignable-from ptype) (.primitive-id atype)))

(defn of ^Wrapper [^Class cl]           ;pre: `cl` is primitive
  (condp identical? cl
    Integer/TYPE int
    Long/TYPE long
    Boolean/TYPE boolean
    Short/TYPE short
    Byte/TYPE byte
    Character/TYPE char
    Float/TYPE float
    Double/TYPE double
    Void/TYPE void))

(defn convert-from-constant ^ConstantDesc [^Class target-type ^Number n]
  (if (identical? target-type (.getClass n))
    n
    (let [prim-id (primitive-id target-type)]
      (case prim-id
        #_int 0 (object (.intValue n))
        #_long 1 (object (.longValue n))
        #_float 2 (object (.floatValue n))
        #_double 3 (object (.doubleValue n))
        #_else
        (-> (case prim-id     ;conversion to computationally int type
              #_boolean 4 (tinyclj.core/int (not= (.intValue n) 0))
              #_byte 5 (tinyclj.core/int (.byteValue n))
              #_character 6 (tinyclj.core/int (tinyclj.core/char (.intValue n)))
              #_short 7 (tinyclj.core/int (.shortValue n)))
            (object))))))

#_(defn of-descriptor ^Wrapper [^TypeDescriptor$OfField tpd]
    (case (.charAt (.descriptorString tpd) 0)
      \L generic-reference
      \I int
      \J long
      \Z boolean
      \S short
      \B byte
      \C char
      \F float
      \D double
      \V void))

#_(defn primitive? ^boolean [^Wrapper tp]
    (not (identical? generic-reference tp)))

#_(defn default-value-of ^Expr [^Class tp]
    (if (jb/reference? tp)
      (x/const tp nil)
      (.default-value (of* tp nil))))

;;; Is an argument of type `atype` assignable to a parameter of type
;;; `ptype`?  This predicate works on the level Clojure expression
;;; types, whose semantics differ from the Java and JVM type system.
;;; The other part of the equation is implemented by `emit/opnd`.  If
;;; an expression of `atype` is classified as assignable, then the
;;; emit function must adjust its JVM level operand type on the stack
;;; to match `ptype`.
(defn assignable-from? ^boolean [^Class ptype ^Class atype]
  #_(prn :assignable-from? ptype atype)
  (letfn [(from-primitive? ^boolean [^Wrapper awrapper]
            ;; pre: `awrapper` denotes a non-void primitive type
            (if (.isPrimitive ptype)
              ;; widening numeric type conversion?
              (primitive-assignable-from? (of ptype) awrapper)
              ;; auto-boxing the argument
              (.isAssignableFrom ptype (.class-reference awrapper))))
          (primitive-from-reference? ^boolean [^Wrapper pwrapper]
            ;; pre: `pwrapper` denotes a primitive type
            (and
             ;; cannot unbox the reference value nil
             (not (poly-reference? atype))
             ;; can assign atype to ptype's box type?
             (assignable-from? (.class-reference pwrapper) atype)))]
    (or (.isAssignableFrom ptype atype) ;by the JVM's rules
        ;; here holds: (not (identical? ptype atype))

        (polymorphic? ptype)   ;can turn any expression into statement
        ;; here holds: (not (instance? Void/TYPE ptype))
        
        (if (.isPrimitive atype)
          (or (polymorphic? atype) (from-primitive? (of atype)))

          ;; here holds: atype is a reference type and ptype is not
          ;; "isAssignableFrom" atype
          (or (.isAssignableFrom atype ptype)
              (if (.isPrimitive ptype)
                ;; auto-unboxing the non-Void reference argument
                (primitive-from-reference? (of ptype))
                ;; parameter is of reference type and argument is nil
                (poly-reference? atype)))))))

;;; ------------------------------------------------------------------------

(def symbol clojure.lang.Symbol)
(def keyword clojure.lang.Keyword)
(def vector clojure.lang.IPersistentVector)
(def map clojure.lang.IPersistentMap)
(def set clojure.lang.IPersistentSet)
(def list clojure.lang.IPersistentList)
(def seq clojure.lang.ISeq)
