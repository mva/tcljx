(ns tcljx.data.type
  (:import (java.lang.classfile CodeBuilder TypeKind)
           (java.lang.constant ConstantDesc)
           (java.util.function BiConsumer))
  (:refer-clojure :exclude [symbol keyword vector map set list]))

(defn same? ^boolean [^Class a ^Class b]
  (identical? a b))

(defn numeric? ^boolean [^Class tp]
  (and (.isPrimitive tp) (not (or (identical? Character/TYPE tp)
                                  (identical? Boolean/TYPE tp)
                                  (identical? Void/TYPE tp)))))

#_(defn reference? ^boolean [^Class tp]
    (not (.isPrimitive tp)))

;;; From the point of view of Clojure there are no statements, only
;;; expressions producing some value.  Accordingly, the Java type
;;; `void` has no equivalent in Clojure.  Any expression "returning
;;; void" is interpreted as returning one of nil, zero, false, or
;;; \u0000 depending on context.
;;; 
;;; For this reason, reinterpret for an expression the primitive type
;;; `void` as "can produce a value of arbitrary type depending on the
;;; context of use".  On the JVM level, these arbitrary types include
;;; the logical JVM type `void` and the type `nil` denoting an
;;; instruction that does not return.
(def polymorphic Void/TYPE)
(defn polymorphic? ^boolean [^Class expr-type]
  (identical? Void/TYPE expr-type))

;;; The type of the special reference `nil`.  Also known as nullptr.
(def poly-reference Void)
(defn poly-reference? ^boolean [^Class expr-type]
  (identical? Void expr-type))

;;; Maps a Clojure expression type to the logical Java type to be used
;;; in a class file element.  The returned value is never `void`.
(defn expr-to-logical ^Class [^Class expr-type]
  (if (or (polymorphic? expr-type)
          #_(poly-reference? expr-type))
    Object
    expr-type))

;;; ------------------------------------------------------------------------

(defn type-dimensions ^int [^Class tp]
  (loop [n 0, tp tp]
    (if (.isArray tp)
      (recur (inc n) (.componentType tp))
      n)))

(defn array-type-of-class ^Class [^Class cl ^int array-rank]
  (if (zero? array-rank)
    cl
    (recur (.arrayType cl) (dec array-rank))))

(defn type-symbol ^symbol [^Class tp]
  (let [n (type-dimensions tp)]
    (if (zero? n)
      (tinyclj.core/symbol nil (.getName tp))
      (tinyclj.core/symbol (loop [cl tp]
                             (if (.isArray cl)
                               (recur (.componentType cl))
                               (.getName cl)))
                           (str n)))))

;;; ------------------------------------------------------------------------

(definterface AutoReturnMarker)         ;interface implies abstract
(def auto-return-marker AutoReturnMarker)
(defn auto-return-marker? ^boolean [^Class tp] (same? AutoReturnMarker tp))

;;; ------------------------------------------------------------------------

;;; Note: `convert-from` does not get any line number information.
;;; Therefore the conversion functions must only emit bytecodes that
;;; cannot throw.  Conversion from void produces the zero value of the
;;; target type.
(deftype Wrapper [^Class class-primitive
                  ^Class class-reference
                  ^Class class-computational
                  ;; ^Expr default-value
                  ^int numeric-order

                  ;; FIXME... replace newarray-code with aload-astore-delta?
                  ^int newarray-code    ;-1 for void
                  ^boolean computational-int?
                  ^BiConsumer convert-from
                  ;; ^DirectMethodHandleDesc unboxing-mhd
                  ;; ^TypeConversion primitive-to
                  ;; ^TypeConversion unbox-exact-to
                  ;; ^TypeConversion box-of
                  ;; ^TypeConversion reference-to
                  ]
  java.lang.Record)

(letfn [(wrapper ^Wrapper [^Class class-primitive
                           ^Class class-reference
                           ^Class class-computational
                           ^int numeric-order
                           ^boolean computational-int?
                           ^BiConsumer convert-to
                           ;; ^TypeConversion primitive-to
                           ;; ^DirectMethodHandleDesc unboxing-mhd
                           ;; ^DirectMethodHandleDesc boxing-mhd
                           ;; ^DirectMethodHandleDesc converting-mhd
                           ]
          (Wrapper. class-primitive class-reference class-computational
                    #_(if (jb/same-class? jb/boolean class-primitive)
                        x/expr-false
                        (.adapt primitive-to x/expr-zero-int))
                    numeric-order
                    (.newarrayCode (TypeKind/from class-primitive))
                    computational-int? convert-to
                    #_unboxing-mhd #_primitive-to
                    #_(^TypeConversion fn [arg]
                       (x/invoke-xref (x/flags-of arg) class-primitive [arg]
                                      unboxing-mhd))
                    #_(^TypeConversion fn [arg]
                       (x/invoke-xref (x/flags-of arg) class-reference [arg]
                                      boxing-mhd))
                    #_(^TypeConversion fn [arg]
                       (x/invoke-xref (x/flags-of arg) class-primitive [arg]
                                      (if (x/type? class-reference arg)
                                        unboxing-mhd
                                        converting-mhd)))))]
  (def int
    (wrapper Integer/TYPE Integer Integer/TYPE 3 true
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.newarray-code from)
                #_T_FLOAT 6 (-> xb .f2i)
                #_T_DOUBLE 7 (-> xb .d2i)
                (#_T_BOOLEAN 4 #_T_CHAR 5 #_T_BYTE 8 #_T_SHORT 9 #_T_INT 10) nil
                #_T_LONG 11 (-> xb .l2i)
                #_else_void (-> xb .iconst_0)))
             #_primitive-to-int
             #_(rt/mhd-virtual [ConstantDescs/CD_Integer "intValue"]
                               ConstantDescs/CD_int [])
             #_(rt/mhd-static [ConstantDescs/CD_Integer "valueOf"]
                              ConstantDescs/CD_Integer [ConstantDescs/CD_int])
             #_(rt/mhd-static [rt/ClojureRT "intCast"] ConstantDescs/CD_int
                              [ConstantDescs/CD_Object])))
  (def long
    (wrapper Long/TYPE Long Long/TYPE 2 false
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.newarray-code from)
                #_T_FLOAT 6 (-> xb .f2l)
                #_T_DOUBLE 7 (-> xb .d2l)
                (#_T_BOOLEAN 4 #_T_CHAR 5 #_T_BYTE 8 #_T_SHORT 9 #_T_INT 10) (-> xb .i2l)
                #_T_LONG 11 nil
                #_else_void (-> xb .lconst_0)))
             #_(to-upper (^TypeConversion fn [arg]
                          (condp jb/same-class? (x/type arg)
                            Integer/TYPE (xf/conv jb/long arg Opcode/I2L)
                            Long/TYPE arg
                            Float/TYPE (xf/conv jb/long arg Opcode/F2L)
                            Double/TYPE (xf/conv jb/long arg Opcode/D2L)
                            #_else nil)))
             #_(rt/mhd-virtual [ConstantDescs/CD_Long "longValue"]
                               ConstantDescs/CD_long [])
             #_(rt/mhd-static [ConstantDescs/CD_Long "valueOf"]
                              ConstantDescs/CD_Long [ConstantDescs/CD_long])
             #_(rt/mhd-static [rt/ClojureRT "longCast"] ConstantDescs/CD_long
                              [ConstantDescs/CD_Object])))
  (def boolean
    (wrapper Boolean/TYPE Boolean Integer/TYPE -1 true
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (letfn [#_(mask-int ^CodeBuilder [^CodeBuilder xb]
                          (-> xb (.iconst_1) (.iand)))]
                (case (.newarray-code from)
                  #_T_BOOLEAN 4 nil
                  ;; #_T_FLOAT 6 (-> xb .f2i (mask-int))
                  ;; #_T_DOUBLE 7 (-> xb .d2i (mask-int))
                  ;; (#_T_CHAR 5 #_T_BYTE 8 #_T_SHORT 9 #_T_INT 10) (-> xb (mask-int))
                  ;; #_T_LONG 11 (-> xb .l2i (mask-int))
                  #_else_void (-> xb .iconst_0))))
             #_nil  ;conversion to boolean is not a thing for Java/JVM
             #_(rt/mhd-virtual [ConstantDescs/CD_Boolean "booleanValue"]
                               ConstantDescs/CD_boolean [])
             #_(rt/mhd-static [ConstantDescs/CD_Boolean "valueOf"]
                              ConstantDescs/CD_Boolean [ConstantDescs/CD_boolean])
             #_(rt/mhd-static [rt/ClojureRT "booleanCast"] ConstantDescs/CD_boolean
                              [ConstantDescs/CD_Object])))
  (def short
    (wrapper Short/TYPE Short Integer/TYPE 4 true
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.newarray-code from)
                #_T_FLOAT 6 (-> xb .f2i .i2s)
                #_T_DOUBLE 7 (-> xb .d2i .i2s)
                (#_T_CHAR 5 #_T_INT 10) (-> xb .i2s)
                (#_T_BOOLEAN 4 #_T_BYTE 8 #_T_SHORT 9) nil
                #_T_LONG 11 (-> xb .l2i .i2s)
                #_else_void (-> xb .iconst_0)))
             #_(to-lower jb/short Opcode/I2S)
             #_(rt/mhd-virtual [ConstantDescs/CD_Short "shortValue"]
                               ConstantDescs/CD_short [])
             #_(rt/mhd-static [ConstantDescs/CD_Short "valueOf"]
                              ConstantDescs/CD_Short [ConstantDescs/CD_short])
             #_(rt/mhd-static [rt/ClojureRT "shortCast"] ConstantDescs/CD_short
                              [ConstantDescs/CD_Object])))
  (def byte
    (wrapper Byte/TYPE Byte Integer/TYPE 5 true
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.newarray-code from)
                #_T_FLOAT 6 (-> xb .f2i .i2b)
                #_T_DOUBLE 7 (-> xb .d2i .i2b)
                (#_T_CHAR 5 #_T_SHORT 9 #_T_INT 10) (-> xb .i2b)
                (#_T_BOOLEAN 4 #_T_BYTE 8) nil
                #_T_LONG 11 (-> xb .l2i .i2b)
                #_else_void (-> xb .iconst_0)))
             #_(to-lower jb/byte Opcode/I2B)
             #_(rt/mhd-virtual [ConstantDescs/CD_Byte "byteValue"]
                               ConstantDescs/CD_byte [])
             #_(rt/mhd-static [ConstantDescs/CD_Byte "valueOf"]
                              ConstantDescs/CD_Byte [ConstantDescs/CD_byte])
             #_(rt/mhd-static [rt/ClojureRT "byteCast"] ConstantDescs/CD_byte
                              [ConstantDescs/CD_Object])))
  (def char
    (wrapper Character/TYPE Character Integer/TYPE -1 true ;not numeric in Clojure
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.newarray-code from)
                #_T_CHAR 5 nil
                #_T_FLOAT 6 (-> xb .f2i .i2c)
                #_T_DOUBLE 7 (-> xb .d2i .i2c)
                (#_T_BOOLEAN 4 #_T_BYTE 8 #_T_SHORT 9 #_T_INT 10) (-> xb .i2c)
                #_T_LONG 11 (-> xb .l2i .i2c)
                #_else_void (-> xb .iconst_0)))
             #_(to-lower jb/char Opcode/I2C)
             #_(rt/mhd-virtual [ConstantDescs/CD_Character "charValue"]
                               ConstantDescs/CD_char [])
             #_(rt/mhd-static [ConstantDescs/CD_Character "valueOf"]
                              ConstantDescs/CD_Character [ConstantDescs/CD_char])
             #_(rt/mhd-static [rt/ClojureRT "charCast"] ConstantDescs/CD_char
                              [ConstantDescs/CD_Object])))
  (def float
    (wrapper Float/TYPE Float Float/TYPE 1 false
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.newarray-code from)
                #_T_FLOAT 6 nil
                #_T_DOUBLE 7 (-> xb .d2f)
                (#_T_BOOLEAN 4 #_T_CHAR 5 #_T_BYTE 8 #_T_SHORT 9 #_T_INT 10) (-> xb .i2f)
                #_T_LONG 11 (-> xb .l2f)
                #_else_void (-> xb .fconst_0)))
             #_(to-upper (^TypeConversion fn [arg]
                          (condp jb/same-class? (x/type arg)
                            Integer/TYPE (xf/conv jb/float arg Opcode/I2F)
                            Long/TYPE (xf/conv jb/float arg Opcode/L2F)
                            Float/TYPE arg
                            Double/TYPE (xf/conv jb/float arg Opcode/D2F)
                            #_else nil)))
             #_(rt/mhd-virtual [ConstantDescs/CD_Float "floatValue"]
                               ConstantDescs/CD_float [])
             #_(rt/mhd-static [ConstantDescs/CD_Float "valueOf"]
                              ConstantDescs/CD_Float [ConstantDescs/CD_float])
             #_(rt/mhd-static [rt/ClojureRT "floatCast"] ConstantDescs/CD_float
                              [ConstantDescs/CD_Object])))
  (def double
    (wrapper Double/TYPE Double Double/TYPE 0 false
             (^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
              (case (.newarray-code from)
                #_T_FLOAT 6 (-> xb .f2d)
                #_T_DOUBLE 7 nil
                (#_T_BOOLEAN 4 #_T_CHAR 5 #_T_BYTE 8 #_T_SHORT 9 #_T_INT 10) (-> xb .i2d)
                #_T_LONG 11 (-> xb .l2d)
                #_else_void (-> xb .dconst_0)))
             #_(to-upper (^TypeConversion fn [arg]
                          (condp jb/same-class? (x/type arg)
                            Integer/TYPE (xf/conv jb/double arg Opcode/I2D)
                            Long/TYPE (xf/conv jb/double arg Opcode/L2D)
                            Float/TYPE (xf/conv jb/double arg Opcode/F2D)
                            Double/TYPE arg
                            #_else nil)))
             #_(rt/mhd-virtual [ConstantDescs/CD_Double "doubleValue"]
                               ConstantDescs/CD_double [])
             #_(rt/mhd-static [ConstantDescs/CD_Double "valueOf"]
                              ConstantDescs/CD_Double [ConstantDescs/CD_double])
             #_(rt/mhd-static [rt/ClojureRT "doubleCast"] ConstantDescs/CD_double
                              [ConstantDescs/CD_Object])))
  
  (def void
    (let [#_#_discard-result (^TypeConversion fn [arg] (pop arg))]
      (Wrapper. Void/TYPE Void Void/TYPE #_x/expr-empty -1 -1 false
                nil #_(^BiConsumer fn ^void [^CodeBuilder xb ^Wrapper from]
                       (assert false))
                #_nil                   ;no class-reference Void
                #_discard-result        ;primitive-to
                #_nil                   ;unbox-to
                #_(^TypeConversion fn [arg] x/expr-nil-object) ;box-of
                #_discard-result)))     ;reference-to

  )

;;; True if `atype` widens to numeric type `ptype`.
(defn widens-from-numeric? ^boolean [^Wrapper ptype ^Wrapper atype]
  (>= (.numeric-order atype) (.numeric-order ptype) (.numeric-order double)))

(defn of ^Wrapper [^Class cl]           ;pre: `cl` is primitive
  (condp identical? cl
    Integer/TYPE int
    Long/TYPE long
    Boolean/TYPE boolean
    Short/TYPE short
    Byte/TYPE byte
    Character/TYPE char
    Float/TYPE float
    Double/TYPE double
    Void/TYPE void))

#_(defn of-expr ^Wrapper [^Expr x]
    (of* (x/type x) generic-reference))

#_(defn of-descriptor ^Wrapper [^TypeDescriptor$OfField tpd]
    (case (.charAt (.descriptorString tpd) 0)
      \L generic-reference
      \I int
      \J long
      \Z boolean
      \S short
      \B byte
      \C char
      \F float
      \D double
      \V void))

#_(defn primitive? ^boolean [^Wrapper tp]
    (not (identical? generic-reference tp)))

#_(defn default-value-of ^Expr [^Class tp]
    (if (jb/reference? tp)
      (x/const tp nil)
      (.default-value (of* tp nil))))

;;; Is an argument of type `atype` assignable to a parameter of type
;;; `ptype`?  This predicate works on the level Clojure expression
;;; types, whose semantics differ from the Java and JVM type system.
;;; The other part of the equation is implemented by `emit/opnd`.  If
;;; an expression of `atype` is classified as assignable, then the
;;; emit function must adjust its JVM level operand type on the stack
;;; to match `ptype`.
(defn assignable-from? ^boolean [^Class ptype ^Class atype]
  #_(prn :assignable-from? ptype atype)
  (letfn [(from-primitive? ^boolean [^Wrapper awrapper]
            ;; pre: `awrapper` denotes a non-void primitive type
            (if (.isPrimitive ptype)
              ;; widening numeric type conversion?
              (widens-from-numeric? (of ptype) awrapper)
              ;; auto-boxing the argument
              (.isAssignableFrom ptype (.class-reference awrapper))))
          (primitive-from-reference? ^boolean [^Wrapper pwrapper]
            ;; pre: `pwrapper` denotes a primitive type
            (and
             ;; cannot unbox the reference value nil
             (not (poly-reference? atype))
             ;; can assign atype to ptype's box type?
             (assignable-from? (.class-reference pwrapper) atype)))]
    (or (.isAssignableFrom ptype atype) ;by the JVM's rules
        ;; here holds: (not (identical? ptype atype))

        (polymorphic? ptype)   ;can turn any expression into statement
        ;; here holds: (not (instance? Void/TYPE ptype))
        
        (if (.isPrimitive atype)
          (or (polymorphic? atype) (from-primitive? (of atype)))

          ;; here holds: atype is a reference type and ptype is not
          ;; "isAssignableFrom" atype
          (or (.isAssignableFrom atype ptype)
              (if (.isPrimitive ptype)
                ;; auto-unboxing the non-Void reference argument
                (primitive-from-reference? (of ptype))
                ;; parameter is of reference type and argument is nil
                (poly-reference? atype)))))))

(defn aload-astore-delta ^int [^Class tp]
  (if (.isPrimitive tp)
    ;; numbering follows xa(load|store), with the exception of boolean and void
    (condp identical? tp 
      Integer/TYPE #_int 0     ;iaload and iastore
      Long/TYPE #_long 1       ;laload and lastore
      Float/TYPE #_float 2     ;faload and fastore
      Double/TYPE #_double 3   ;daload and dastore
      Boolean/TYPE #_boolean 8 ;reference is assigned a delta of 4 below
      Byte/TYPE #_byte 5       ;baload and bastore
      Character/TYPE #_char 6  ;caload and castore
      Short/TYPE #_short 7     ;saload and sastore
      Void/TYPE #_void -1)     ;arbitrary, pick negative for now
    #_reference 4))                     ;aaload and aastore

(defn convert-from-constant ^ConstantDesc [^Class target-type ^Number n]
  (if (identical? target-type (.getClass n))
    n
    (case (aload-astore-delta target-type)
      #_int 0 (object (.intValue n))
      #_long 1 (object (.longValue n))
      #_float 2 (object (.floatValue n))
      #_double 3 (object (.doubleValue n))
      ;; conversion to computationally int type:
      #_byte 5 (object (tinyclj.core/int (.byteValue n)))
      #_character 6 (object (tinyclj.core/int (tinyclj.core/char (.intValue n))))
      #_short 7 (object (tinyclj.core/int (.shortValue n))))))

;;; ------------------------------------------------------------------------

(def symbol clojure.lang.Symbol)
(def keyword clojure.lang.Keyword)
(def vector clojure.lang.IPersistentVector)
(def map clojure.lang.IPersistentMap)
(def set clojure.lang.IPersistentSet)
(def list clojure.lang.IPersistentList)
