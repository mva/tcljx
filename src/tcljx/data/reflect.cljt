(ns tcljx.data.reflect
  (:import
   (java.lang.classfile ClassFile Opcode #_TypeKind ClassBuilder #_MethodBuilder
                        CodeBuilder #_Label)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc MethodHandleDesc
                       DirectMethodHandleDesc DirectMethodHandleDesc$Kind
                       Constable ConstantDescs)
   #_(java.lang.invoke MethodHandle TypeDescriptor$OfField MethodHandles$Lookup)
   (java.lang.reflect Method Constructor Executable Field Member Modifier)))

(defn describe ^ConstantDesc [^Constable x]
  (.get (.describeConstable x)))

;;; FIXME... Does it make sense to use java.lang.ClassValue to cache
;;; generated ClassDesc values?  The cache should be wiped (or shrunk,
;;; or replaced with empty) after each build to prevent stale classes
;;; from piling up in its key set.  Either use a simple redefinable
;;; def or a scoped value for the ClassValue instance.
(defn describe-class ^ClassDesc [^Class tp]
  (.get (.describeConstable tp)))
(defn describe-class* ^ClassDesc/1 [^Class/1 atp]
  (let [a (new ClassDesc/1 (alength atp))]
    (dotimes [i (alength a)]
      (aset a i (describe-class (aget atp i))))
    a))

(defn mtd-of-method ^MethodTypeDesc [^Method m]
  (MethodTypeDesc/of (describe-class (.getReturnType m))
                     (describe-class* (.getParameterTypes m))))
(defn mtd-of-constructor ^MethodTypeDesc [^Constructor c]
  (MethodTypeDesc/of ConstantDescs/CD_void
                     (describe-class* (.getParameterTypes c))))

;;; ------------------------------------------------------------------------

(letfn [(owner-desc ^ClassDesc [^Class owner]
          (if (.isArray owner)
            ConstantDescs/CD_Object
            (describe-class owner)))
        (method-kind ^DirectMethodHandleDesc$Kind [^Method m ^Class owner]
          (let [static? (Modifier/isStatic (.getModifiers m))]
            (if (.isInterface owner)
              (if static?
                DirectMethodHandleDesc$Kind/INTERFACE_STATIC
                DirectMethodHandleDesc$Kind/INTERFACE_VIRTUAL)
              (if static?
                DirectMethodHandleDesc$Kind/STATIC
                DirectMethodHandleDesc$Kind/VIRTUAL))))
        (field-kind ^DirectMethodHandleDesc$Kind [^Field f]
          (let [static? (Modifier/isStatic (.getModifiers f))]
            (if static?
              DirectMethodHandleDesc$Kind/STATIC_GETTER
              DirectMethodHandleDesc$Kind/GETTER)))]

  ;; Note: All of the `mhd-of` methods explictly take the owner class
  ;; of the new MethodHandleDesc.  The member's declaring class cannot
  ;; be used for this purpose: The class file must denote the class
  ;; from which the member was resolved (i.e. where the search
  ;; started) and not the class where the member was found (i.e. where
  ;; the search ended).
  
  (defn mhd-of-field 
    (^DirectMethodHandleDesc [^Class owner ^Field f]
     (MethodHandleDesc/ofField (field-kind f) (owner-desc owner) (.getName f)
                               (describe-class (.getType f)))))
  (defn mhd-of-method ^DirectMethodHandleDesc [^Class owner ^Method m]
    (MethodHandleDesc/ofMethod (method-kind m owner) (owner-desc owner)
                               (.getName m) (mtd-of-method m)))
  (defn mhd-of-constructor ^DirectMethodHandleDesc [^Class owner ^Constructor c]
    (MethodHandleDesc/ofConstructor (owner-desc owner)
                                    (describe-class* (.getParameterTypes c))))
  
  #_(defn mhd-of-member ^DirectMethodHandleDesc [^Class owner ^Member m]
      (condp instance? m
        Method (mhd-of-method owner m)
        Field (mhd-of-field owner m)
        Constructor (mhd-of-constructor owner m))))

;;; ------------------------------------------------------------------------

(defn virtual? ^boolean [^Member member] ;also true for constructor
  (not (Modifier/isStatic (.getModifiers member))))

(defn parameter-types ^Class/1 [^Member member]
  (if (instance? Executable member)
    (.getParameterTypes ^Executable member)
    (new Class/1 0)))

(defn invoke-member ^CodeBuilder [^CodeBuilder xb ^Class owner ^Member member]
  (let [cld (describe-class owner)
        v? (virtual? member)]
    (condp instance? member
      Method
      (.invoke xb (if v?
                    (if (.isInterface owner)
                      Opcode/INVOKEINTERFACE
                      Opcode/INVOKEVIRTUAL)
                    Opcode/INVOKESTATIC)
               cld (.getName member) (mtd-of-method member) (.isInterface owner))
      Constructor
      (.invokespecial xb cld ConstantDescs/INIT_NAME
                      (mtd-of-constructor member))
      Field
      (.fieldAccess xb (if v? Opcode/GETFIELD Opcode/GETSTATIC) cld
                    (.getName member) (describe-class (.getType ^Field member))))))

(defn invoke-member-type ^Class [^Class owner ^Member member]
  (condp instance? member
    Method (.getReturnType ^Method member)
    Constructor owner
    Field (.getType ^Field member)))
