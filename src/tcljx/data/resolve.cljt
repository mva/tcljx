;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.data.resolve
  (:require
   (tcljx.data [member :as member] [type :as type]))
  (:import
   (tcljx.data.member MemberHandle)
   (java.lang.constant ClassDesc)
   (java.lang.invoke MethodHandles$Lookup)
   (java.lang.reflect Method Constructor Executable Field Member Modifier)
   (java.util Arrays)))

;; Third party Java libraries cannot have a static method called
;; `new`, because in Java `new` is a keyword and not an identifier.
;; Clojure's deftype does not support static methods at all.  Taking
;; this into account, there is little downside to having the dot form
;; supporting `new` as symbolic constructor name as well.  So all of
;; Classname/new, (Classname/new ...) and (. Classname new ...) are
;; supported.
(def constructor-name "new")

(def ^:private jvm-primitive-types ;arbitrary, follow xaload/xastore for now
  [Void/TYPE Integer/TYPE Long/TYPE Float/TYPE Double/TYPE
   #_reference Byte/TYPE Character/TYPE Short/TYPE Boolean/TYPE])

(def ^:private java-base-classes    ;almost all from package java.lang
  [Boolean Byte Character Class ClassLoader #_clojure.lang.Compiler Double
   Enum Float InheritableThreadLocal Integer Long Math Number Object
   Package Process ProcessBuilder Runtime RuntimePermission
   Short StackTraceElement StrictMath String
   #_StringBuffer StringBuilder System Thread ThreadGroup ThreadLocal
   Throwable Void Appendable CharSequence Cloneable Comparable
   Iterable Readable Runnable java.util.concurrent.Callable
   BigInteger BigDecimal
             
   ArithmeticException ArrayIndexOutOfBoundsException
   ArrayStoreException ClassCastException ClassNotFoundException
   CloneNotSupportedException EnumConstantNotPresentException
   Exception IllegalAccessException IllegalArgumentException
   IllegalMonitorStateException IllegalStateException
   IllegalThreadStateException IndexOutOfBoundsException
   InstantiationException  NegativeArraySizeException
   NoSuchFieldException NoSuchMethodException NullPointerException
   NumberFormatException RuntimeException SecurityException
   StringIndexOutOfBoundsException TypeNotPresentException
   UnsupportedOperationException AbstractMethodError AssertionError
   ClassCircularityError ClassFormatError Error
   ExceptionInInitializerError IllegalAccessError
   IncompatibleClassChangeError InstantiationError InternalError
   LinkageError NoClassDefFoundError NoSuchFieldError
   NoSuchMethodError OutOfMemoryError StackOverflowError
   UnknownError UnsatisfiedLinkError
   UnsupportedClassVersionError VerifyError VirtualMachineError
             
   Thread$UncaughtExceptionHandler Thread$State
   Deprecated Override SuppressWarnings])

(def imported-long-name Class/.getName)
(defn imported-short-name ^String [^Class cl]
  (let [s (.getName cl)] ;want "Thread$State" for j.l.Thread.State
    (.substring s (inc (.lastIndexOf s (int \.))))))

;;; `rt-lookup` is used to resolve class names of the Clojure runtime.
(defn predefined-imports ^map [^MethodHandles$Lookup rt-lookup]
  (let [m (java.util.HashMap.)]
    ;; by default, import certain java.base classes using their
    ;; short name; references using the long name are resolved on
    ;; demand and refer to the same JVM-level class instance
    (doseq [^Class cl java-base-classes]
      (.put m (imported-short-name cl) cl)
      (.put m (imported-long-name cl) cl))
    
    ;; pseudo-import of primitive types types by their lower-case Java
    ;; name
    (doseq [^Class cl jvm-primitive-types]
      (.put m (.getSimpleName cl) cl))

    (letfn [(put-alias ^void [^String nm ^Class compiler-class]
              (.put m nm (.findClass rt-lookup (.getName compiler-class))))]
      ;; shorthand names for Clojure building blocks
      (put-alias "symbol" type/symbol)
      (put-alias "keyword" type/keyword)
      (put-alias "vector" type/vector)
      (put-alias "map" type/map)
      (put-alias "set" type/set)
      (put-alias "list" type/list)
      (put-alias "seq" type/seq))
    
    (into {} m)))

;;; ------------------------------------------------------------------------

(defn- maybe-class-name? ^boolean [^String nm] ;format must be pkgName.className
  (pos? (.indexOf nm (int \.))))

;; nil if no match
(defn class-for-desc ^Class [^MethodHandles$Lookup l ^ClassDesc cld]
  (try
    (.resolveConstantDesc cld l)
    (catch ClassNotFoundException _
      nil)))
(defn class-for-name ^Class [^MethodHandles$Lookup l ^String nm]
  (when (maybe-class-name? nm)
    (class-for-desc l (ClassDesc/of nm))))

;;; ------------------------------------------------------------------------

(defn- static-member?
  (^boolean [^Member m]
   (Modifier/isStatic (.getModifiers m)))
  (^boolean [^boolean expected? ^Member m]
   (= (static-member? m) expected?)))

;;; Problem: class MethodHandle.PolymorphicSignature is not public
(def ^:private ann-polymorphic-signature
  (Class/forName "java.lang.invoke.MethodHandle$PolymorphicSignature"
                 false (ClassLoader/getPlatformClassLoader)))

(defn- cons-executable-exact
  (^seq [^Class owner ^Method m ^seq acc]
   (cons-executable-exact owner m (.getReturnType m) acc))
  (^seq [^Class owner ^Executable e ^Class return-type ^seq acc]
   (cond->> acc
     (or (not (.isVarArgs e))
         (not (.isAnnotationPresent e ann-polymorphic-signature)))
     (cons (member/mk-match owner e (.getParameterTypes e) return-type
                            member/invoke-standard)))))

(defn- cons-executable-candidate ^seq [^Class owner ^Executable e
                                       ^Class return-type ^seq acc]
  (let [mode (if (.isVarArgs e)
               (if (.isAnnotationPresent e ann-polymorphic-signature)
                 member/invoke-polymorphic
                 member/invoke-tail-into-array) ;preliminary, subject to arg types
               member/invoke-standard)
        rt (if (= mode member/invoke-polymorphic)
             type/polymorphic ;polymorphic return determined by context
             return-type)]
    (cons (member/mk-match owner e (.getParameterTypes e) rt mode) acc)))

(defn method-exact ^seq [^seq acc ^boolean static? ^Class owner ^String nm
                         ^Class/1 atypes]
  (letfn [(method-or-throw ^seq [^Class lookup] ;throws NoSuchMethodException
            (let [m (.getMethod lookup nm atypes)] ;works for class and array
              (cond->> acc
                (static-member? static? m)
                (cons-executable-exact owner m))))]
    (try
      (method-or-throw owner)
      (catch NoSuchMethodException _
        (try     ;if owner is an interface, then try again with Object
          (if (.isInterface owner)      ;FIXME... what about array?
            (method-or-throw Object)
            acc)
          (catch NoSuchMethodException _
            acc))))))

(defn method-candidates ^seq [^seq acc ^boolean static? ^Class owner ^String nm]
  (let [ms (.getMethods owner)]
    (loop [acc acc, i (dec (alength ms))]
      (if (neg? i)
        acc
        (recur (let [m (aget ms i)]
                 (cond->> acc
                   (and (= nm (.getName m))
                        (static-member? static? m)
                        (not (.isBridge m)))
                   (cons-executable-candidate owner m (.getReturnType m))))
               (dec i))))))


;;; Returns `acc` for PolymorphicSignature constructor.
(defn constructor-exact ^seq [^seq acc ^Class owner ^Class/1 atypes]
  (try
    (let [c (.getConstructor owner atypes)]
      (cons-executable-exact owner c owner acc))
    (catch NoSuchMethodException _
      acc)))

(defn constructor-candidates ^seq [^seq acc ^Class owner]
  (let [cs (.getConstructors owner)]
    (loop [acc acc, i (dec (alength cs))]
      (if (neg? i)
        acc
        (recur (cons-executable-candidate owner (aget cs i) owner acc)
               (dec i))))))


(def empty-class-array (new Class/1 0))
(defn- cons-field-candidate ^seq [^Class owner ^Field f ^seq acc]
  (cons (member/mk-match owner f empty-class-array (.getType f) member/invoke-standard) acc))

(defn field-exact ^seq [^seq acc ^boolean static? ^Class owner ^String nm
                        ^Class/1 atypes]
  (try
    (let [f (.getField owner nm)]
      (cond->> acc
        (and (static-member? static? f) (zero? (alength atypes)))
        (cons-field-candidate owner f)))
    (catch NoSuchFieldException _
      acc)))


(defn member-exact ^seq [^seq acc ^boolean static? ^Class owner ^String mnm
                         ^Class/1 exact-types]
  (if (some? exact-types)
    (or (if (= mnm constructor-name)
          (constructor-exact acc owner exact-types)
          (method-exact acc static? owner mnm exact-types))
        (field-exact acc static? owner mnm exact-types))
    (field-exact acc static? owner mnm empty-class-array)))

(defn member-candidates ^seq [^seq acc ^boolean static? ^Class owner ^String mnm]
  (if (= mnm constructor-name)
    (constructor-candidates acc owner)
    (method-candidates acc static? owner mnm)))

;;; ------------------------------------------------------------------------

;;; `ptags` of nil does not constrain arity or parameter types of
;;; constructors, methods, or virtual fields.  Returns nil if there is
;;; no match.
(defn members-by-param-tags ^seq [^boolean static? ^Class owner ^String mnm
                                  ^Class/1 ptags]
  (letfn [(matches-ptags? ^boolean [^MemberHandle candidate] ;pre: (some? ptags)
            (let [ptypes (.parameter-types candidate)]
              (and (= (alength ptypes) (alength ptags))
                   (loop [i (dec (alength ptypes))]
                     (cond
                       (neg? i) true
                       
                       (let [ptag (aget ptags i)]
                         (or (type/same? ptag (aget ptypes i))
                             (type/polymorphic? ptag)))
                       (recur (dec i))
                       
                       :else false)))))
          (filter-by-ptags* ^seq [^seq acc ^seq candidates] ;pre: (some? ptags)
            (if (nil? candidates)
              acc
              (let [candidate (first candidates)]
                (recur (cond->> acc (matches-ptags? candidate) (cons candidate))
                       (next candidates)))))
          (filter-by-ptags ^seq [^seq acc ^seq candidates]
            (if (nil? ptags)
              candidates
              (filter-by-ptags* acc (seq candidates))))]

    (or (member-exact nil static? owner mnm ptags)
        (filter-by-ptags nil (member-candidates nil static? owner mnm)))))

;;; ------------------------------------------------------------------------

(defn- cons-atypes-match ^seq [^Class/1 atypes ^MemberHandle candidate ^seq acc]
  (letfn [(argument-compatible? ^boolean [^Class ptype ^Class atype]
            (type/assignable-from? ptype atype))
          (fixed-arguments-compatible? ^boolean [^Class/1 ptypes ^int end]
            (loop [i 0]
              (cond
                (>= i end)
                true
                (argument-compatible? (aget ptypes i) (aget atypes i))
                (recur (inc i))
                :else
                false)))
          (var-arguments-compatible? ^boolean [^Class va-ptype ^int start]
            (let [va-type (.getComponentType va-ptype)]
              (loop [i start]
                #_(prn :va-type va-type :i i)
                (cond
                  (>= i (alength atypes))
                  true
                  (argument-compatible? va-type (aget atypes i))
                  (recur (inc i))
                  :else
                  false))))]
    
    (let [ptypes (.parameter-types candidate)
          an (alength atypes)
          fixed (member/end-of-fixed-parameters candidate)]
      (if (and (<= fixed an) (fixed-arguments-compatible? ptypes fixed))
        (cond
          (= fixed an)           ;fixed parameters cover all arguments
          (cons candidate acc)

          (= (.invocation-mode candidate) member/invoke-standard)
          acc       ;parameter/argument count mismatch but not varargs
          
          (and (= (inc fixed) an)     ;directly pass array to varargs?
               (= (.invocation-mode candidate) member/invoke-tail-into-array)
               (argument-compatible? (aget ptypes fixed)
                                     (aget atypes fixed)))
          (cons (member/with-invocation-mode candidate member/invoke-standard) acc)

          (let [varargs-type (member/varargs-parameter-type candidate)]
            (or (= member/invoke-polymorphic (.invocation-mode candidate))
                (var-arguments-compatible? varargs-type fixed)))
          (cons candidate acc)

          :else acc)
        acc))))

(letfn [#_(parameter-count-match? ^boolean [^MemberHandle as ^MemberHandle e]
            (let [n-p (parameter-count e)
                  n-a (parameter-count as)]
              (or (= n-p n-a)
                  (and (not= (.invocation-mode e) invoke-standard)
                       (>= n-a (dec n-p))))))
        (compatible-args? ^boolean [^MemberHandle as ^MemberHandle e]
          (and #_(parameter-count-match? as e)
               (some? (cons-atypes-match (.parameter-types as) e nil))))]
  
  (defn- filter-dominators [es]
    (letfn [(dominates-all? ^boolean [^MemberHandle e]
              (every? #(compatible-args? e %) es))]
      (if (next es) ;nothing to do if there are less than two elements
        (or (seq (filter dominates-all? es)) es)
        es)))
  
  (defn- dominating-matches ^seq [^seq ms]
    (letfn [(dominates-all? ^boolean [^MemberHandle m]
              (every? #(compatible-args? m %) ms))]
      (if (next ms) ;nothing to do if there are less than two elements
        (or (seq (filter dominates-all? ms)) ms)
        ms))))

;;; ------------------------------------------------------------------------

(defn members-by-arg-types ^seq [^boolean static? ^Class owner ^String mnm
                                 ^Class/1 atypes]
  (letfn [(filter-by-atypes ^seq [^seq acc ^seq candidates]
            (if (nil? candidates)
              acc
              (recur (cons-atypes-match atypes (first candidates) acc)
                     (next candidates))))]
    
    (or (member-exact nil static? owner mnm atypes)
        (->> (member-candidates nil static? owner mnm)
             (filter-by-atypes nil)
             (dominating-matches)))))

;;; ------------------------------------------------------------------------

(defn- runtime-method* ^MemberHandle [^boolean static? ^Class owner
                                      ^String method-name ^Class/1 ptypes]
  ;; match excatly on varargs array type, and then adjust invocation
  ;; mode of the returned match
  (let [ms (method-exact nil static? owner method-name ptypes)
        m ^MemberHandle (first ms)]
    (cond-> m
      (.isVarArgs ^Method (.member m))
      (member/with-invocation-mode member/invoke-tail-into-array))))
(defn static-method ^MemberHandle [^Class owner ^String method-name
                                   & ^Class/1 ptypes]
  (runtime-method* true owner method-name ptypes))
(defn virtual-method ^MemberHandle [^Class owner ^String method-name
                                   & ^Class/1 ptypes]
  (runtime-method* false owner method-name ptypes))

;;; ------------------------------------------------------------------------

(letfn [(functional-itf? ^boolean [^Class cl]
          (some? (.getAnnotation cl java.lang.FunctionalInterface)))
        (object-method? ^boolean [^Method m]
          (try
            (let [m* (.getMethod Object (.getName m) (.getParameterTypes m))]
              (and (type/same? (.getReturnType m) (.getReturnType m*))
                   (= (.isVarArgs m) (.isVarArgs m*))))
            (catch NoSuchMethodException _
              false)))
        (abstract-method? ^boolean [^Method m]
          (Modifier/isAbstract (.getModifiers m)))]
  (defn itf-methods [^Class itf]
    (let [ms (.getMethods itf)]
      (if (functional-itf? itf)
        (let [abs-ms (->> (filter abstract-method? ms)
                          (remove object-method?))]
          (assert (= (count abs-ms) 1))
          abs-ms)
        (filter abstract-method? ms)))))

;;; ------------------------------------------------------------------------

(letfn [(vp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (Modifier/isProtected mods)
                 (not (.isBridge m)))))
        (protected-methods [^Class cl]
          (when (some? cl)
            (lazy-seq (concat (filter vp? (.getDeclaredMethods cl))
                              (protected-methods (.getSuperclass cl))))))
        (vpp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (or (Modifier/isPublic mods) (Modifier/isProtected mods))
                 (not (.isBridge m)))))
        (public-or-protected-methods [^Class cl]
          (concat
           (filter vpp? (.getMethods cl)) ;all public methods (incl. inherited)
           (protected-methods cl))) ;protected methods from superclass chain

        ;; Picks up any matching virtual method, public *or*
        ;; protected.  Used to override protected method in reify*.
        (method-exact-pp ^MemberHandle [^Class owner ^String nm ^Class/1 ptypes]
          (letfn [(pred ^boolean [^Method m]
                    (and (= (.getName m) nm)
                         (Arrays/equals (.getParameterTypes m) ptypes)))]
            (when-some [m (-> (filter pred (public-or-protected-methods owner))
                              (first))]
              (-> (cons-executable-exact owner m nil)
                  (first)))))

        (drop-equal-parameters [ms]
          ;; get rid of any matches with different owners but equal
          ;; parameter types, like
          ;; (.containsKey ^boolean [clojure.lang.Associative Object]
          ;; (.containsKey ^boolean [java.util.Map Object]
          (if (next ms)
            (let [m ^Method (first ms)
                  pred (fn ^boolean [^Method o]
                         (and (= (.isVarArgs m) (.isVarArgs o))
                              (Arrays/equals (.getParameterTypes m)
                                             (.getParameterTypes o))))]
              (cons m (lazy-seq (->> (remove pred (rest ms))
                                     (drop-equal-parameters)))))
            ms))]
  
  ;; Picks up public or protected virtual method.
  (defn itf-methods-with-name ^seq [^Class owner ^String nm ^int arity]
    (->> (public-or-protected-methods owner)
         (filter (fn ^boolean [^Method m]
                   (and (= nm (.getName m))
                        (= arity (.getParameterCount m)))))
         (drop-equal-parameters)))

  ;; If `return-type` is not nil, then it must match the return type
  ;; of the method.
  (defn itf-method-exact ^Method [^Class owner ^String nm ^Class return-type
                                  ^Class/1 atypes]
    (when-some [^MemberHandle m (or (first (method-exact nil false owner nm atypes))
                                    (method-exact-pp owner nm atypes))]
      (when (or (nil? return-type)
                (type/same? (.return-type m) return-type))
        (.member m)))))

;;; ------------------------------------------------------------------------

(letfn [(find-factory ^MemberHandle [^String method-name]
          (static-method tinyclj.lang.Literal method-name Object/1))]
  (def literal-vector (find-factory "vector")) ;type/vector
  (def literal-map (find-factory "map"))       ;type/map
  (def literal-set (find-factory "set"))       ;type/set
  (def literal-list (find-factory "list"))     ;type/list
  (def literal-with-meta
    (static-method tinyclj.lang.Literal "with_meta"
                   clojure.lang.IObj clojure.lang.IPersistentMap))

  (def create-var-2 (static-method clojure.lang.RT "var" String String))
  (def create-var-3 (static-method clojure.lang.RT "var" String String Object))
  (def set-meta (virtual-method clojure.lang.Var "setMeta" clojure.lang.IPersistentMap))
  (def set-dynamic (virtual-method clojure.lang.Var "setDynamic")))
