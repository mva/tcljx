;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.data.resolve
  (:require
   (tcljx.data [type :as type]))
  (:import
   (java.lang.invoke MethodHandles$Lookup)
   (java.lang.reflect Method Constructor Executable Field Member Modifier)))

(def ^:private java-base-classes    ;almost all from package java.lang
  [Boolean Byte Character Class ClassLoader #_clojure.lang.Compiler Double
   Enum Float InheritableThreadLocal Integer Long Math Number Object
   Package Process ProcessBuilder Runtime RuntimePermission
   Short StackTraceElement StrictMath String
   #_StringBuffer StringBuilder System Thread ThreadGroup ThreadLocal
   Throwable Void Appendable CharSequence Cloneable Comparable
   Iterable Readable Runnable java.util.concurrent.Callable
   BigInteger BigDecimal
             
   ArithmeticException ArrayIndexOutOfBoundsException
   ArrayStoreException ClassCastException ClassNotFoundException
   CloneNotSupportedException EnumConstantNotPresentException
   Exception IllegalAccessException IllegalArgumentException
   IllegalMonitorStateException IllegalStateException
   IllegalThreadStateException IndexOutOfBoundsException
   InstantiationException  NegativeArraySizeException
   NoSuchFieldException NoSuchMethodException NullPointerException
   NumberFormatException RuntimeException SecurityException
   StringIndexOutOfBoundsException TypeNotPresentException
   UnsupportedOperationException AbstractMethodError AssertionError
   ClassCircularityError ClassFormatError Error
   ExceptionInInitializerError IllegalAccessError
   IncompatibleClassChangeError InstantiationError InternalError
   LinkageError NoClassDefFoundError NoSuchFieldError
   NoSuchMethodError OutOfMemoryError StackOverflowError
   UnknownError UnsatisfiedLinkError
   UnsupportedClassVersionError VerifyError VirtualMachineError
             
   Thread$UncaughtExceptionHandler Thread$State
   Deprecated Override SuppressWarnings])

(def predefined-imports
  (letfn [(short-name ^String [^Class cl]
            (let [s (.getName cl)] ;want "Thread$State" for j.l.Thread.State
              (.substring s (inc (.lastIndexOf s (int \.))))))]
    (let [m (java.util.HashMap.)]
      ;; by default, import certain java.base classes using their
      ;; short name; references using the long name are resolved on
      ;; demand and refer to the same JVM-level class instance
      (doseq [^Class cl java-base-classes]
        (.put m (short-name cl) cl)
        (.put m (.getName cl) cl))
      
      ;; pseudo-import of primitive types types by their lower-case Java
      ;; name
      (doseq [^Class cl [Void/TYPE Boolean/TYPE Byte/TYPE Short/TYPE
                         Character/TYPE Integer/TYPE Float/TYPE
                         Long/TYPE Double/TYPE]]
        (.put m (.getSimpleName cl) cl))
      (into {} m))))

;;; ------------------------------------------------------------------------

(defn- maybe-class-name? ^boolean [^String nm] ;format must be pkgName.className
  (pos? (.indexOf nm (int \.))))

(defn class-by-name ^Class [^MethodHandles$Lookup l ^String nm] ;nil if no match
  (when (maybe-class-name? nm)
    (try
      (.resolveConstantDesc (java.lang.constant.ClassDesc/of nm) l)
      (catch ClassNotFoundException _
        nil))))

;;; ------------------------------------------------------------------------

(def invoke-standard 0)        ;regular invocation
(def invoke-tail-into-array 1) ;invoke packs tail arguments into array
(def invoke-polymorphic-tail 2)       ;tails arguments are polymorphic

(deftype Match [^Member member          ;method, field, or constructor
                ^Class/1 parameter-types ;excluding any receiver
                ^int invocation-mode])

#_(def flag-static 0)
#_(def flag-virtual 1)
;; (def flag-field 2)
;; (def flag-method 3)
;; (def flag-no-candidate-returns-nil 4)
;; (def flag-minus-is-field 5)

#_(def opts-virtual (bit-set 0 flag-virtual))
#_(def opts-static (bit-set 0 flag-static))

(let [#_#_mask-field (bit-set 0 flag-field)
      #_#_mask-method (bit-set 0 flag-method)
      #_#_mask-member (bit-or mask-field mask-method)]
  #_(defn fields-only? ^boolean [^int opts]
      (= mask-field (bit-and mask-member opts)))
  #_(defn methods-only? ^boolean [^int opts]
      (= mask-method (bit-and mask-member opts)))
  #_(defn static-virtual-match? ^boolean [^int opts ^Member m]
    (if (Modifier/isStatic (.getModifiers m))
      (bit-test opts flag-static)
      (bit-test opts flag-virtual))))

;; (defn first-argument-index ^int [^int opts] ;skips receiver
;;   (if (bit-test opts flag-virtual) 1 0))

;; (defn starts-with-dot? ^boolean [^String s]
;;   (and  (> (.length s) 1) (= (.charAt s 0) \.)))

;;; Problem: class MethodHandle.PolymorphicSignature is not public
(def ^:private ann-polymorphic-signature
  (Class/forName "java.lang.invoke.MethodHandle$PolymorphicSignature"
                 false (ClassLoader/getPlatformClassLoader)))

(defn static-member?
  (^boolean [^Member m]
   (Modifier/isStatic (.getModifiers m)))
  (^boolean [^boolean static? ^Member m]
   (= (static-member? m) static?)))

(defn- cons-executable-candidate ^seq [^Executable e ^seq acc]
  (cons (Match. e (.getParameterTypes e)
                (if (.isVarArgs e)
                  (if (.isAnnotationPresent e ann-polymorphic-signature)
                    invoke-polymorphic-tail
                    invoke-tail-into-array) ;preliminary, subject to arg types
                  invoke-standard))
        acc))

(defn method-exact ^seq [^seq acc ^boolean static? ^Class owner ^String nm
                         ^Class/1 atypes]
  (letfn [(method-or-throw ^seq [^Class owner] ;throws NoSuchMethodException
            (let [m (.getMethod owner nm atypes)] ;works for class and array
              (cond->> acc
                (static-member? static? m)
                (cons-executable-candidate m))))]
    (try
      (method-or-throw owner)
      (catch NoSuchMethodException _
        (try     ;if owner is an interface, then try again with Object
          (if (.isInterface owner)
            (method-or-throw Object)
            acc)
          (catch NoSuchMethodException _
            acc))))))

(defn method-candidates ^seq [^seq acc ^boolean static? ^String nm ^Method/1 ms]
  (loop [acc acc, i (dec (alength ms))]
    (if (neg? i)
      acc
      (recur (let [m (aget ms i)]
               (cond->> acc
                 (and (= nm (.getName m))
                      (static-member? static? m)
                      (not (.isBridge m)))
                 (cons-executable-candidate m)))
             (dec i)))))


;;; Returns `acc` for PolymorphicSignature constructor.
(defn constructor-exact ^seq [^seq acc ^Class owner ^Class/1 atypes]
  (try
    (let [c (.getConstructor owner atypes)]
      (cons-executable-candidate c acc))
    (catch NoSuchMethodException _
      acc)))

(defn constructor-candidates ^seq [^seq acc ^Constructor/1 cs]
  (loop [acc acc, i (dec (alength cs))]
    (if (neg? i)
      acc
      (recur (cons-executable-candidate (aget cs i) acc) (dec i)))))


(def ^:private empty-parameter-types (new Class/1 0))
(defn- cons-field-candidate ^seq [^Field f ^seq acc]
  (cons (Match. f empty-parameter-types invoke-standard) acc))

(defn field-exact ^seq [^seq acc ^boolean static? ^Class owner ^String nm]
  (try
    (let [f (.getField owner nm)]
      (cond->> acc (static-member? static? f) (cons-field-candidate f)))
    (catch NoSuchFieldException _
      acc)))

;;; ------------------------------------------------------------------------

;;; `ptags` of nil does not constrain arity or parameter types of
;;; constructors, methods, or virtual fields.  Returns nil if there is
;;; no match.
(defn members-by-param-tags ^seq [^boolean static? ^Class owner ^String mnm
                                  ^Class/1 ptags]
  (letfn [(matches-ptags? ^boolean [^Match candidate] ;pre: (some? ptags)
            (let [ptypes (.parameter-types candidate)]
              (and (= (alength ptypes) (alength ptags))
                   (loop [i (dec (alength ptypes))]
                     (cond
                       (neg? i) true
                       
                       (let [ptag (aget ptags i)]
                         (or (type/same? ptag (aget ptypes i))
                             (type/polymorphic? ptag)))
                       (recur (dec i))
                       
                       :else false)))))
          (filter-by-ptags* ^seq [^seq acc ^seq candidates] ;pre: (some? ptags)
            (if (nil? candidates)
              acc
              (let [candidate (first candidates)]
                (recur (cond->> acc (matches-ptags? candidate) (cons candidate))
                       (next candidates)))))
          (filter-by-ptags ^seq [^seq acc ^seq candidates]
            (if (nil? ptags)
              candidates
              (filter-by-ptags* acc (seq candidates))))]

    (or (if (= mnm "new")
          (or (when (some? ptags) (constructor-exact nil owner ptags))
              (->> (constructor-candidates nil (.getConstructors owner))
                   (filter-by-ptags nil)))
          (or (when (some? ptags) (method-exact nil static? owner mnm ptags))
              (->> (method-candidates nil static? mnm (.getMethods owner))
                   (filter-by-ptags nil))))
        (when (or (nil? ptags) (zero? (alength ptags)))
          (field-exact nil static? owner mnm)))))

(defn methods-by-param-tags ^seq [^boolean static? ^Class owner ^String mnm
                                  ^Class/1 ptags]
  ;; FIXME... drop this later?
  (->> (members-by-param-tags static? owner mnm ptags)
       (filter #(instance? Method (.member ^Match %)))))
(defn method-by-param-tags ^Match [^boolean static? ^Class owner ^String mnm
                                   ^Class/1 ptags]
  ;; FIXME... drop this later?
  (let [ms (methods-by-param-tags static? owner mnm ptags)]
    (when (nil? (next ms))
      (first ms))))
