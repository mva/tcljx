;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.data.resolve
  (:require
   (tcljx.data [type :as type]))
  (:import
   (java.lang.constant ClassDesc)
   (java.lang.invoke MethodHandles$Lookup)
   (java.lang.reflect Method Constructor Executable Field Member Modifier)))

;; Third party Java libraries cannot have a static method called
;; `new`, because in Java `new` is a keyword and not an identifier.
;; Clojure's deftype does not support static methods at all.  Taking
;; this into account, there is little downside to having the dot form
;; supporting `new` as symbolic constructor name as well.  So all of
;; Classname/new, (Classname/new ...) and (. Classname new ...) are
;; supported.
(def constructor-name "new")

(def ^:private jvm-primitive-types ;arbitrary, follow xaload/xastore for now
  [Void/TYPE Integer/TYPE Long/TYPE Float/TYPE Double/TYPE
   #_reference Byte/TYPE Character/TYPE Short/TYPE Boolean/TYPE])

(def ^:private java-base-classes    ;almost all from package java.lang
  [Boolean Byte Character Class ClassLoader #_clojure.lang.Compiler Double
   Enum Float InheritableThreadLocal Integer Long Math Number Object
   Package Process ProcessBuilder Runtime RuntimePermission
   Short StackTraceElement StrictMath String
   #_StringBuffer StringBuilder System Thread ThreadGroup ThreadLocal
   Throwable Void Appendable CharSequence Cloneable Comparable
   Iterable Readable Runnable java.util.concurrent.Callable
   BigInteger BigDecimal
             
   ArithmeticException ArrayIndexOutOfBoundsException
   ArrayStoreException ClassCastException ClassNotFoundException
   CloneNotSupportedException EnumConstantNotPresentException
   Exception IllegalAccessException IllegalArgumentException
   IllegalMonitorStateException IllegalStateException
   IllegalThreadStateException IndexOutOfBoundsException
   InstantiationException  NegativeArraySizeException
   NoSuchFieldException NoSuchMethodException NullPointerException
   NumberFormatException RuntimeException SecurityException
   StringIndexOutOfBoundsException TypeNotPresentException
   UnsupportedOperationException AbstractMethodError AssertionError
   ClassCircularityError ClassFormatError Error
   ExceptionInInitializerError IllegalAccessError
   IncompatibleClassChangeError InstantiationError InternalError
   LinkageError NoClassDefFoundError NoSuchFieldError
   NoSuchMethodError OutOfMemoryError StackOverflowError
   UnknownError UnsatisfiedLinkError
   UnsupportedClassVersionError VerifyError VirtualMachineError
             
   Thread$UncaughtExceptionHandler Thread$State
   Deprecated Override SuppressWarnings])

(defn imported-short-name ^String [^Class cl]
  (let [s (.getName cl)] ;want "Thread$State" for j.l.Thread.State
    (.substring s (inc (.lastIndexOf s (int \.))))))

(def predefined-imports
  (let [m (java.util.HashMap.)]
    ;; by default, import certain java.base classes using their
    ;; short name; references using the long name are resolved on
    ;; demand and refer to the same JVM-level class instance
    (doseq [^Class cl java-base-classes]
      (.put m (imported-short-name cl) cl)
      (.put m (.getName cl) cl))
    
    ;; pseudo-import of primitive types types by their lower-case Java
    ;; name
    (doseq [^Class cl jvm-primitive-types]
      (.put m (.getSimpleName cl) cl))
    (into {} m)))

;;; ------------------------------------------------------------------------

(defn- maybe-class-name? ^boolean [^String nm] ;format must be pkgName.className
  (pos? (.indexOf nm (int \.))))

;; nil if no match
(defn class-for-desc ^Class [^MethodHandles$Lookup l ^ClassDesc cld]
  (try
    (.resolveConstantDesc cld l)
    (catch ClassNotFoundException _
      nil)))
(defn class-for-name ^Class [^MethodHandles$Lookup l ^String nm]
  (when (maybe-class-name? nm)
    (class-for-desc l (ClassDesc/of nm))))

;;; ------------------------------------------------------------------------

(def invoke-polymorphic -1) ;tails arguments & return type are polymorphic
(def invoke-standard 0)     ;regular invocation
(def invoke-tail-into-array 1)         ;pack tail arguments into array

(deftype Match [^Class owner            ;where the search started
                ^Member member          ;method, field, or constructor
                ^Class/1 parameter-types ;excluding any receiver
                ^Class return-type
                ^int invocation-mode]
  java.lang.Record)

(defn- with-invocation-mode ^Match [^Match m ^int invocation-mode]
  (Match. (.owner m) (.member m) (.parameter-types m) (.return-type m)
          invocation-mode))

(defn parameter-count ^int [^Match m]
  (alength (.parameter-types m)))
(defn end-of-fixed-parameters ^int [^Match m]
  (- (parameter-count m) (bit-and (.invocation-mode m) 1)))
(defn varargs-parameter-type ^Class [^Match m] ;nil if invoke-standard
  (when (not= (.invocation-mode m) invoke-standard)
    (aget (.parameter-types m) (end-of-fixed-parameters m))))


#_(def flag-static 0)
#_(def flag-virtual 1)
;; (def flag-field 2)
;; (def flag-method 3)
;; (def flag-no-candidate-returns-nil 4)
;; (def flag-minus-is-field 5)

#_(def opts-virtual (bit-set 0 flag-virtual))
#_(def opts-static (bit-set 0 flag-static))

(let [#_#_mask-field (bit-set 0 flag-field)
      #_#_mask-method (bit-set 0 flag-method)
      #_#_mask-member (bit-or mask-field mask-method)]
  #_(defn fields-only? ^boolean [^int opts]
      (= mask-field (bit-and mask-member opts)))
  #_(defn methods-only? ^boolean [^int opts]
      (= mask-method (bit-and mask-member opts)))
  #_(defn static-virtual-match? ^boolean [^int opts ^Member m]
    (if (Modifier/isStatic (.getModifiers m))
      (bit-test opts flag-static)
      (bit-test opts flag-virtual))))

;; (defn first-argument-index ^int [^int opts] ;skips receiver
;;   (if (bit-test opts flag-virtual) 1 0))

;; (defn starts-with-dot? ^boolean [^String s]
;;   (and  (> (.length s) 1) (= (.charAt s 0) \.)))

;;; Problem: class MethodHandle.PolymorphicSignature is not public
(def ^:private ann-polymorphic-signature
  (Class/forName "java.lang.invoke.MethodHandle$PolymorphicSignature"
                 false (ClassLoader/getPlatformClassLoader)))

(defn static-member?
  (^boolean [^Member m]
   (Modifier/isStatic (.getModifiers m)))
  (^boolean [^boolean static? ^Member m]
   (= (static-member? m) static?)))

(defn- cons-executable-exact ^seq [^Class owner ^Executable e ^Class return-type
                                   ^seq acc]
  (cond->> acc
    (or (not (.isVarArgs e))
        (not (.isAnnotationPresent e ann-polymorphic-signature)))
    (cons (Match. owner e (.getParameterTypes e) return-type invoke-standard))))

(defn- cons-executable-candidate ^seq [^Class owner ^Executable e
                                       ^Class return-type ^seq acc]
  (let [mode (if (.isVarArgs e)
               (if (.isAnnotationPresent e ann-polymorphic-signature)
                 invoke-polymorphic
                 invoke-tail-into-array) ;preliminary, subject to arg types
               invoke-standard)
        rt (if (= mode invoke-polymorphic)
             type/polymorphic ;polymorphic return determined by context
             return-type)]
    (cons (Match. owner e (.getParameterTypes e) rt mode) acc)))

(defn method-exact ^seq [^seq acc ^boolean static? ^Class owner ^String nm
                         ^Class/1 atypes]
  (letfn [(method-or-throw ^seq [^Class owner] ;throws NoSuchMethodException
            (let [m (.getMethod owner nm atypes)] ;works for class and array
              (cond->> acc
                (static-member? static? m)
                (cons-executable-exact owner m (.getReturnType m)))))]
    (try
      (method-or-throw owner)
      (catch NoSuchMethodException _
        (try     ;if owner is an interface, then try again with Object
          (if (.isInterface owner)
            (method-or-throw Object)
            acc)
          (catch NoSuchMethodException _
            acc))))))

(defn method-candidates ^seq [^seq acc ^boolean static? ^Class owner ^String nm]
  (let [ms (.getMethods owner)]
    (loop [acc acc, i (dec (alength ms))]
      (if (neg? i)
        acc
        (recur (let [m (aget ms i)]
                 (cond->> acc
                   (and (= nm (.getName m))
                        (static-member? static? m)
                        (not (.isBridge m)))
                   (cons-executable-candidate owner m (.getReturnType m))))
               (dec i))))))


;;; Returns `acc` for PolymorphicSignature constructor.
(defn constructor-exact ^seq [^seq acc ^Class owner ^Class/1 atypes]
  (try
    (let [c (.getConstructor owner atypes)]
      (cons-executable-exact owner c owner acc))
    (catch NoSuchMethodException _
      acc)))

(defn constructor-candidates ^seq [^seq acc ^Class owner]
  (let [cs (.getConstructors owner)]
    (loop [acc acc, i (dec (alength cs))]
      (if (neg? i)
        acc
        (recur (cons-executable-candidate owner (aget cs i) owner acc)
               (dec i))))))


(def empty-class-array (new Class/1 0))
(defn- cons-field-candidate ^seq [^Class owner ^Field f ^seq acc]
  (cons (Match. owner f empty-class-array (.getType f) invoke-standard) acc))

(defn field-exact ^seq [^seq acc ^boolean static? ^Class owner ^String nm
                        ^Class/1 atypes]
  (try
    (let [f (.getField owner nm)]
      (cond->> acc
        (and (static-member? static? f) (zero? (alength atypes)))
        (cons-field-candidate owner f)))
    (catch NoSuchFieldException _
      acc)))


(defn member-exact ^seq [^seq acc ^boolean static? ^Class owner ^String mnm
                         ^Class/1 exact-types]
  (if (some? exact-types)
    (or (if (= mnm constructor-name)
          (constructor-exact acc owner exact-types)
          (method-exact acc static? owner mnm exact-types))
        (field-exact acc static? owner mnm exact-types))
    (field-exact acc static? owner mnm empty-class-array)))

(defn member-candidates ^seq [^seq acc ^boolean static? ^Class owner ^String mnm]
  (if (= mnm constructor-name)
    (constructor-candidates acc owner)
    (method-candidates acc static? owner mnm)))

;;; ------------------------------------------------------------------------

;;; `ptags` of nil does not constrain arity or parameter types of
;;; constructors, methods, or virtual fields.  Returns nil if there is
;;; no match.
(defn members-by-param-tags ^seq [^boolean static? ^Class owner ^String mnm
                                  ^Class/1 ptags]
  (letfn [(matches-ptags? ^boolean [^Match candidate] ;pre: (some? ptags)
            (let [ptypes (.parameter-types candidate)]
              (and (= (alength ptypes) (alength ptags))
                   (loop [i (dec (alength ptypes))]
                     (cond
                       (neg? i) true
                       
                       (let [ptag (aget ptags i)]
                         (or (type/same? ptag (aget ptypes i))
                             (type/polymorphic? ptag)))
                       (recur (dec i))
                       
                       :else false)))))
          (filter-by-ptags* ^seq [^seq acc ^seq candidates] ;pre: (some? ptags)
            (if (nil? candidates)
              acc
              (let [candidate (first candidates)]
                (recur (cond->> acc (matches-ptags? candidate) (cons candidate))
                       (next candidates)))))
          (filter-by-ptags ^seq [^seq acc ^seq candidates]
            (if (nil? ptags)
              candidates
              (filter-by-ptags* acc (seq candidates))))]

    (or (member-exact nil static? owner mnm ptags)
        (filter-by-ptags nil (member-candidates nil static? owner mnm)))))

(defn methods-by-param-tags ^seq [^boolean static? ^Class owner ^String mnm
                                  ^Class/1 ptags]
  ;; FIXME... drop this later?
  (->> (members-by-param-tags static? owner mnm ptags)
       (filter #(instance? Method (.member ^Match %)))))
(defn method-by-param-tags ^Match [^boolean static? ^Class owner ^String mnm
                                   ^Class/1 ptags]
  ;; FIXME... drop this later?
  (let [ms (methods-by-param-tags static? owner mnm ptags)]
    (when (nil? (next ms))
      (first ms))))

;;; ------------------------------------------------------------------------

(defn- cons-atypes-match ^seq [^Class/1 atypes ^Match candidate ^seq acc]
  (letfn [(argument-compatible? ^boolean [^Class ptype ^Class atype]
            (type/assignable-from? ptype atype))
          (fixed-arguments-compatible? ^boolean [^Class/1 ptypes ^int end]
            (loop [i 0]
              (cond
                (>= i end)
                true
                (argument-compatible? (aget ptypes i) (aget atypes i))
                (recur (inc i))
                :else
                false)))
          (var-arguments-compatible? ^boolean [^Class va-ptype ^int start]
            (let [va-type (.getComponentType va-ptype)]
              (loop [i start]
                #_(prn :va-type va-type :i i)
                (cond
                  (>= i (alength atypes))
                  true
                  (argument-compatible? va-type (aget atypes i))
                  (recur (inc i))
                  :else
                  false))))]
    
    (let [ptypes (.parameter-types candidate)
          an (alength atypes)
          fixed (end-of-fixed-parameters candidate)]
      (if (and (<= fixed an) (fixed-arguments-compatible? ptypes fixed))
        (cond
          (= fixed an)           ;fixed parameters cover all arguments
          (cons candidate acc)

          (= (.invocation-mode candidate) invoke-standard)
          acc       ;parameter/argument count mismatch but not varargs
          
          (and (= (inc fixed) an)     ;directly pass array to varargs?
               (= (.invocation-mode candidate) invoke-tail-into-array)
               (argument-compatible? (aget ptypes fixed)
                                     (aget atypes fixed)))
          (cons (with-invocation-mode candidate invoke-standard) acc)

          (let [varargs-type (varargs-parameter-type candidate)]
            (or (= invoke-polymorphic (.invocation-mode candidate))
                (var-arguments-compatible? varargs-type fixed)))
          (cons candidate acc)

          :else acc)
        acc))))

(letfn [#_(parameter-count-match? ^boolean [^Match as ^Match e]
            (let [n-p (parameter-count e)
                  n-a (parameter-count as)]
              (or (= n-p n-a)
                  (and (not= (.invocation-mode e) invoke-standard)
                       (>= n-a (dec n-p))))))
        (compatible-args? ^boolean [^Match as ^Match e]
          (and #_(parameter-count-match? as e)
               (some? (cons-atypes-match (.parameter-types as) e nil))))]
  
  (defn- filter-dominators [es]
    (letfn [(dominates-all? ^boolean [^Match e]
              (every? #(compatible-args? e %) es))]
      (if (next es) ;nothing to do if there are less than two elements
        (or (seq (filter dominates-all? es)) es)
        es)))
  
  (defn- dominating-matches ^seq [^seq ms]
    (letfn [(dominates-all? ^boolean [^Match m]
              (every? #(compatible-args? m %) ms))]
      (if (next ms) ;nothing to do if there are less than two elements
        (or (seq (filter dominates-all? ms)) ms)
        ms))))

;;; ------------------------------------------------------------------------

(defn members-by-arg-types ^seq [^boolean static? ^Class owner ^String mnm
                                 ^Class/1 atypes]
  (letfn [(filter-by-atypes ^seq [^seq acc ^seq candidates]
            (if (nil? candidates)
              acc
              (recur (cons-atypes-match atypes (first candidates) acc)
                     (next candidates))))]
    
    (or (member-exact nil static? owner mnm atypes)
        (->> (member-candidates nil static? owner mnm)
             (filter-by-atypes nil)
             (dominating-matches)))))

;;; ------------------------------------------------------------------------

(defn runtime-method ^Match [^Class owner ^String method-name ^Class/1 ptypes]
  ;; match excatly on varargs array type, and then adjust invocation
  ;; mode of the returned match
  (let [ms (method-exact nil true owner method-name ptypes)
        m ^Match (first ms)]
    (cond-> m
      (.isVarArgs ^Method (.member m))
      (with-invocation-mode invoke-tail-into-array))))
