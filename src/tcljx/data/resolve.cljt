;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.data.resolve
  (:require
   (tcljx.data [type :as type]))
  (:import
   (java.lang.invoke MethodHandles$Lookup)
   (java.lang.reflect Method Constructor Executable Field Member Modifier)))

(def ^:private java-base-classes    ;almost all from package java.lang
  [Boolean Byte Character Class ClassLoader #_clojure.lang.Compiler Double
   Enum Float InheritableThreadLocal Integer Long Math Number Object
   Package Process ProcessBuilder Runtime RuntimePermission
   Short StackTraceElement StrictMath String
   #_StringBuffer StringBuilder System Thread ThreadGroup ThreadLocal
   Throwable Void Appendable CharSequence Cloneable Comparable
   Iterable Readable Runnable java.util.concurrent.Callable
   BigInteger BigDecimal
             
   ArithmeticException ArrayIndexOutOfBoundsException
   ArrayStoreException ClassCastException ClassNotFoundException
   CloneNotSupportedException EnumConstantNotPresentException
   Exception IllegalAccessException IllegalArgumentException
   IllegalMonitorStateException IllegalStateException
   IllegalThreadStateException IndexOutOfBoundsException
   InstantiationException  NegativeArraySizeException
   NoSuchFieldException NoSuchMethodException NullPointerException
   NumberFormatException RuntimeException SecurityException
   StringIndexOutOfBoundsException TypeNotPresentException
   UnsupportedOperationException AbstractMethodError AssertionError
   ClassCircularityError ClassFormatError Error
   ExceptionInInitializerError IllegalAccessError
   IncompatibleClassChangeError InstantiationError InternalError
   LinkageError NoClassDefFoundError NoSuchFieldError
   NoSuchMethodError OutOfMemoryError StackOverflowError
   UnknownError UnsatisfiedLinkError
   UnsupportedClassVersionError VerifyError VirtualMachineError
             
   Thread$UncaughtExceptionHandler Thread$State
   Deprecated Override SuppressWarnings])

(def predefined-imports
  (letfn [(short-name ^String [^Class cl]
            (let [s (.getName cl)] ;want "Thread$State" for j.l.Thread.State
              (.substring s (inc (.lastIndexOf s (int \.))))))]
    (let [m (java.util.HashMap.)]
      ;; by default, import certain java.base classes using their
      ;; short name; references using the long name are resolved on
      ;; demand and refer to the same JVM-level class instance
      (doseq [^Class cl java-base-classes]
        (.put m (short-name cl) cl)
        (.put m (.getName cl) cl))
      
      ;; pseudo-import of primitive types types by their lower-case Java
      ;; name
      (doseq [^Class cl [Void/TYPE Boolean/TYPE Byte/TYPE Short/TYPE
                         Character/TYPE Integer/TYPE Float/TYPE
                         Long/TYPE Double/TYPE]]
        (.put m (.getSimpleName cl) cl))
      (into {} m))))

;;; ------------------------------------------------------------------------

(defn- maybe-class-name? ^boolean [^String nm] ;format must be pkgName.className
  (pos? (.indexOf nm (int \.))))

(defn class-by-name ^Class [^MethodHandles$Lookup l ^String nm] ;nil if no match
  (when (maybe-class-name? nm)
    (try
      (.resolveConstantDesc (java.lang.constant.ClassDesc/of nm) l)
      (catch ClassNotFoundException _
        nil))))

;;; ------------------------------------------------------------------------

(def flag-static 0)
(def flag-virtual 1)
;; (def flag-field 2)
;; (def flag-method 3)
;; (def flag-no-candidate-returns-nil 4)
;; (def flag-minus-is-field 5)

(def opts-virtual (bit-set 0 flag-virtual))
(def opts-static (bit-set 0 flag-static))

(let [#_#_mask-field (bit-set 0 flag-field)
      #_#_mask-method (bit-set 0 flag-method)
      #_#_mask-member (bit-or mask-field mask-method)]
  #_(defn fields-only? ^boolean [^int opts]
      (= mask-field (bit-and mask-member opts)))
  #_(defn methods-only? ^boolean [^int opts]
      (= mask-method (bit-and mask-member opts)))
  (defn static-virtual-match? ^boolean [^int opts ^Member m]
    (if (Modifier/isStatic (.getModifiers m))
      (bit-test opts flag-static)
      (bit-test opts flag-virtual))))

;; (defn first-argument-index ^int [^int opts] ;skips receiver
;;   (if (bit-test opts flag-virtual) 1 0))

;; (defn starts-with-dot? ^boolean [^String s]
;;   (and  (> (.length s) 1) (= (.charAt s 0) \.)))

;;; Problem: class MethodHandle.PolymorphicSignature is not public
(def ^:private ann-polymorphic-signature
  (Class/forName "java.lang.invoke.MethodHandle$PolymorphicSignature"
                 false (ClassLoader/getPlatformClassLoader)))

(defn signature-polymorphic? ^boolean [^Executable e]
  (and (.isVarArgs e) (.isAnnotationPresent e ann-polymorphic-signature)))

;;; Returns `acc` for PolymorphicSignature method.
(defn method-exact ^seq [^seq acc ^int opts ^Class owner ^String nm
                         ^Class/1 atypes]
  (letfn [(method-or-throw ^seq [^Class owner] ;throws NoSuchMethodException
            (let [m (.getMethod owner nm atypes)] ;works for class and array
              (cond->> acc
                (and (static-virtual-match? opts m)
                     (not (signature-polymorphic? m)))
                (cons m))))]
    (try
      (method-or-throw owner)
      (catch NoSuchMethodException _
        (try     ;if owner is an interface, then try again with Object
          (if (.isInterface owner)
            (method-or-throw Object)
            acc)
          (catch NoSuchMethodException _
            acc))))))

;;; Returns `acc` for PolymorphicSignature constructor.
(defn constructor-exact ^seq [^seq acc ^Class owner ^Class/1 atypes]
  (try
    (let [c (.getConstructor owner atypes)]
      (cond->> acc (not (signature-polymorphic? c)) (cons c)))
    (catch NoSuchMethodException _
      acc)))

(defn field-exact ^seq [^seq acc ^int opts ^Class owner ^String nm]
  (try
    (let [f (.getField owner nm)]
      (cond->> acc (static-virtual-match? opts f) (cons f)))
    (catch NoSuchFieldException _
      acc)))

;;; ------------------------------------------------------------------------

;;; `ptags` of nil does not constrain arity or parameter types of
;;; constructors, methods, or virtual fields.  Returns nil if there is
;;; no match.
(defn members-by-param-tags ^seq [^boolean virtual? ^Class owner ^String mnm
                                  ^Class/1 ptags]
  (letfn [(parameters-match? ^boolean [^Class/1 ptags ^Class/1 ptypes]
            (loop [i (dec (alength ptypes))]
              (cond
                (neg? i) true
                         
                (let [ptag (aget ptags i)]
                  (or (type/same? ptag (aget ptypes i))
                      (type/polymorphic? ptag)))
                (recur (dec i))
                         
                :else false)))
          (matches-ptags? ^boolean [^Class/1 ptypes]
            (or (nil? ptags)
                (and (= (alength ptypes) (alength ptags))
                     (parameters-match? ptags ptypes))))
          (methods ^seq [^seq acc ^int opts ^String nm ^Method/1 ms]
            (loop [acc acc, i (dec (alength ms))]
              (if (neg? i)
                acc
                (recur (let [m (aget ms i)]
                         (cond->> acc
                           (and (= nm (.getName m))
                                (static-virtual-match? opts m)
                                (matches-ptags? (.getParameterTypes m))
                                (not (.isBridge m)))
                           (cons m)))
                       (dec i)))))
          (constructors ^seq [^seq acc ^Constructor/1 cs]
            (loop [acc acc, i (dec (alength cs))]
              (if (neg? i)
                acc
                (recur (let [c (aget cs i)]
                         (cond->> acc
                           (matches-ptags? (.getParameterTypes c))
                           (cons c)))
                       (dec i)))))]

    (let [opts (if virtual? opts-virtual opts-static)]
      (or (if (= mnm "new")
            (or (when (some? ptags) (constructor-exact nil owner ptags))
                (constructors nil (.getConstructors owner)))
            (or (when (some? ptags) (method-exact nil opts owner mnm ptags))
                (methods nil opts mnm (.getMethods owner))))
          (when (or (nil? ptags) (zero? (alength ptags)))
            (field-exact nil opts owner mnm))))))

(defn methods-by-param-tags ^seq [^boolean virtual? ^Class owner ^String mnm
                                  ^Class/1 ptags]
  ;; FIXME... drop this later?
  (filter #(instance? Method %) (members-by-param-tags virtual? owner mnm ptags)))
(defn method-by-param-tags ^Method [^boolean virtual? ^Class owner ^String mnm
                                    ^Class/1 ptags]
  ;; FIXME... drop this later?
  (let [ms (methods-by-param-tags virtual? owner mnm ptags)]
    (when (nil? (next ms))
      (first ms))))
