(ns tcljx.data.model
  (:require
   (tcljx.data [config :as cfg] resolve))
  (:import
   (tcljx.data.resolve Match)
   (java.lang.classfile CodeBuilder ClassBuilder)
   (java.lang.classfile.constantpool ConstantPoolBuilder LoadableConstantEntry)
   (java.lang.constant DirectMethodHandleDesc ClassDesc)
   (java.util Arrays)
   (java.util.function BiFunction))
  (:refer-clojure :exclude [zero?]))

;;; Emit instruction code into the CodeBuilder instance.  Return the
;;; actual type of the value pushed onto operand stack, or nil if
;;; control leaves the current method.  The produced operand type can
;;; be either the original expression type baked into the emitter, or
;;; the provided `consumed-type` expected by the instruction that
;;; consumes the pushed operand.  If the returned operand type differs
;;; from `consumed-type`, then `emit/insn?` and `emit/then-leave?`
;;; adapt the on stack value to match the `consumed-type`.
;;;
;;; If `then-leave?` is set, then the emitted code is permitted to
;;; close with a return instruction.  In this case the returned type
;;; is nil.
;;; 
;;; No line number is passed to the method.  This limits any adapting
;;; instructions to get to `consumed-type` to "safe" ones that are
;;; known to never raise an exception.  `insn?` and `then-leave?` must
;;; close over the consumer form's line number to perform throwing
;;; adaptions like CHECKCAST.
(definterface CodeEmitter
  (emit-insn* ^Class [^CodeBuilder xb ^Class consumed-type
                      ^boolean then-leave?]))

;;; The parser works with opaque instances of Expr exclusively.  An
;;; Expr gives a very restricted view on whatever data the code
;;; generator keeps around to do its job, implemented by the generator
;;; class Insn).  In particular, Expr does not expose the expression's
;;; type.
(definterface Expr         ;FIXME... turn this into an abstract class?
  (emitter ^CodeEmitter []))

(definterface Exprs
  (length ^int [])
  (empty? ^boolean [])
  (get ^Expr [^int i])
  (set ^Expr [^int i ^Expr x])
  (emitter ^CodeEmitter [^int i])
  (drop ^Exprs [^int n]))

;;; ------------------------------------------------------------------------

;;; A named entity on the level of the code generator that exists at
;;; runtime, usually appearing as the "provide the value of the given
;;; name" operation of a bound name.  Exposes additional operations
;;; beyond "emit code that produces this entity's value".  The code
;;; emitted by Entity itself puts its current value on the operand
;;; stack.
;;;
;;; An entity has a static and bounded compile-time scope in which it
;;; can be accessed, for example to retrieve its value (if it has
;;; any), or to access any of the other more specialized services like
;;; direct invocation.  Only the entity's value can be passed on when
;;; exiting the scope.  But this value does not provide any privileged
;;; access to the entity it was derived from.
;;;
;;; Implementation note: To ease certain code generation patterns,
;;; identity of Entity instances is important.  A runtime entity
;;; should be mirrored by at most one Entity instance during
;;; compilation.
(definterface Entity
  :extends [CodeEmitter]
  ;; The type of the entity's value, for example when pushing it onto
  ;; the operand stack.  If nil, then this entity cannot be reified as
  ;; a regular value at runtime.  This is the case for macros and most
  ;; primitive functions.
  (value-type ^Class [])
  
  ;; The level of the scope that bounds visibility and accessibility
  ;; of this entity and, for a closure, the entity's sequence number
  ;; within that scope.
  (entity-id ^int [])

  ;; Emits code taking one operand from the stack and overwriting the
  ;; entity's current value with it.
  (emit-store ^CodeBuilder [^CodeBuilder xb])            ;optional
  (emit-iinc ^CodeBuilder [^CodeBuilder xb ^int const])) ;optional

(def closure-level-constant 0) ;scope of constants spans all namespaces
(def closure-level-def 1)      ;entity is a def on namespace level
(def closure-level-clinit 2) ;scope of entity is a namespace segment's <clinit>

(defn entity-id-of ^int [^int closure-level]
  (bit-shift-left closure-level 16))
(defn closure-level ^int [^Entity ent]
  (unsigned-bit-shift-right (.entity-id ent) 16))
(defn sequence-number ^int [^Entity ent]
  (bit-and 0xffff (.entity-id ent)))

(def entity-id-constant (entity-id-of closure-level-constant))
(def entity-id-def (entity-id-of closure-level-def))


;;; An entity representing a `def` form of a namespace.
(defn def-entity? ^boolean [^Entity ent]
  (= closure-level-def (closure-level ent)))


(definterface LoadFromCopyWhenBound
  :extends [Entity]
  ;; Called from non-alias Binding and closes over the binding's
  ;; value.  A let binding usually allocates a local variable and
  ;; stores in it the initial value, causing all later `emit-insn*`
  ;; calls to emit a `loadLoad` instruction.  A def binding works
  ;; similar, using a static field or a static method.  Returns false
  ;; if control then leaves the method.
  (emit-setup-code? ^boolean [^CodeBuilder xb]))


(definterface CopyOnRead
  ;; Create an alias for this entity when it appears as value of a let
  ;; binding?  Returns false if a binding *must* create a copy of the
  ;; entity's value.
  (alias-when-let-value? ^boolean []))

(defn alias-when-let-value? ^boolean [^CodeEmitter ce]
  (when (instance? Entity ce)
    (if (instance? CopyOnRead ce)
      (.alias-when-let-value? ^CopyOnRead ce)
      true)))                ;all other entities: reads are repeatable


(definterface Invocable
  :extends [Entity]
  (invoke* ^Expr [^long fctx ^seq form ^CodeEmitter opt-f ^Exprs xs]))

(defn invocable? ^boolean [^CodeEmitter ent]
  (instance? Invocable ent))


;;; An "immediate" entity can be referenced by a fixed nominal
;;; description known at compilation time.  Applies to constants,
;;; namespace-level defs, and functions with an empty environment.  An
;;; immediate entity does not contribute to a closure's environment.
(definterface ImmediateEntity)
(defn immediate-entity? ^boolean [^Entity ent]
  (instance? ImmediateEntity ent))


;;; A binding represents the place in a code sequence where some
;;; entity `bound-to` is associated with a name.
(definterface Binding
  :extends [CodeEmitter]
  ;; The runtime entity for which this binding provides a name.
  (bound-to ^Entity [])

  ;; The name assigned to the entity `bound-to`.
  (name ^String []))

;;; ------------------------------------------------------------------------

;;; Any entity that can be turned into either an LDC instruction as
;;; part of a method's code attribute, or into a loadable entry inside
;;; the constant pool.
;;; 
;;; An entity whose bytecode representation is a variant of the LDC
;;; instruction.  Constant values must be visible to the parser,
;;; because type expression literals (for example `Classname` or
;;; `Classname/1`) are part of the syntax of some special forms.
;;; Constant values are visible to the code generator to support
;;; bottom up constant folding while building the expression tree.
(definterface Constant
  :extends [Entity]
  (computational-value ^Object []) ;ConstantDesc, Class, or some non-nil value

  ;; If `logical-type?` is true, then make sure the entry materializes
  ;; as the actual logical type of the loadable, instead of its
  ;; computational type.  Only makes a difference to computational int
  ;; types other than int: boolean, character, byte, and short.
  (loadable-entry ^LoadableConstantEntry [^ConstantPoolBuilder cpb
                                          ^boolean logical-type?])
  
  ;; Return the compile time data structure representation of this
  ;; loadable.
  (datafy ^Object []))

(defn type-literal ^Class [^Expr x form] ;nil if not a type symbol
  (let [ce (.emitter x)]
    (when (and (instance? Constant ce)
               (identical? Class (Entity/.value-type ce))
               (symbol? form))
      (Constant/.computational-value ce))))

;;; ------------------------------------------------------------------------

;;; Description of an arity's signature.  Basically the information
;;; encoded in an `fn` parameter vector, with the parameter names
;;; being optional.
(definterface ArityType
  ;; The arity's return type.  In case of `auto-return-type`, this is
  ;; replaced with the arity body's result type.
  (return-type ^Class [])
  (with-return-type ^ArityType [^Class tp])
  
  ;; This is the "internal" parameter list that is used to parse and
  ;; compile the arity.  That is, for the variadic case the last/rest
  ;; parameter is of type `ISeq`.
  (parameter-types ^Class/1 [])
  (parameter-type ^Class [^int i])
  
  ;; Number of parameters.
  (parameter-count ^int [])

  ;; The names of the parameters if the arity is being compiled from
  ;; source.  For an imported function this is nil.
  (parameter-names ^String/1 [])
  (parameter-name ^String [^int i])

  ;; JVM-style varargs arity/method with an array parameter like
  ;; `Object...` or `int...`.  Mutually exclusive with `variadic?`.
  (varargs? ^boolean [])

  ;; Clojure-style variadic arity with an `ISeq` rest parameter.
  ;; External view on the arity's method is a varargs `Object...` with
  ;; a bridge method in between.  Mutually exclusive with `varargs?`.
  (variadic? ^boolean [])
  )

(deftype ArityTypeImpl [^Class return-type
                        ^Class/1 parameter-types
                        ^String/1 parameter-names
                        ^boolean varargs?]
  java.lang.Record
  ArityType
  (with-return-type [_ tp]
    (ArityTypeImpl. tp parameter-types parameter-names varargs?))
  (parameter-count [_]
    (alength parameter-types))
  (parameter-name [_ ^int i]
    (aget parameter-names i))
  (parameter-type [_ ^int i]
    (aget parameter-types i))
  (varargs? [_]
    varargs?)
  (variadic? [_]                        ;FIXME...
    false))

(defn translates-to-varargs? ^boolean [^ArityType at]
  (or (.varargs? at) (.variadic? at)))

(defn fixed-parameter-count ^int [^ArityType at]
  (- (.parameter-count at) (int (translates-to-varargs? at))))


(deftype AritySpec [^ArityType at ^seq body ^DirectMethodHandleDesc redirection
                    ^seq error-context ^Expr code]) ;`code` is initially nil

;;; ------------------------------------------------------------------------

;;; Represents the current state of globals and namespace aliases at
;;; this point, and the set of classes defined in the JVM classloader
;;; at this time.  All sets of entities include the declarations done
;;; before this point.  `lookup-global-qname` and `lookup-namespace`
;;; never return entities declared after this point.  Because of
;;; concurrency, `lookup-class` may return class instances defined in
;;; parallel or at a later point.
(definterface Resolver
  (ns-str ^String [])                   ;the name of this namespace
  (lookup-namespace ^String [^String alias]) ;nil if not found

  ;; Called by the reader to replace a syntax quoted simple name with
  ;; its namespace qualified equivalent.  Returns nil if there is no
  ;; such global name at this point in the namespace.
  (lookup-global-qname ^symbol [^String nm])

  ;; Look up class by alias or by name.  May cache resolved class
  ;; names for the scope of the namespace.  Returns nil if not found.
  (lookup-class ^Class [^String nm])
  
  ;; Returns the entity representing the def form for `nm` in
  ;; namespace `nmsp`, or nil if no such binding exists.  Use nil as
  ;; `nmsp` to refer to the current namespace.
  (lookup-def ^Entity [^String nmsp ^String nm]))

;;; ------------------------------------------------------------------------

(deftype ProvidedNamespace [^String ns-str]
  java.lang.Record)

(definterface NamespaceProvider
  ;; Resolves and compiles the namespace names in `ns-strs`.  Returns
  ;; an instance of `ProvidedNamespace` in the corresponding element
  ;; of the result, or an element of value nil if the namespace name
  ;; could not be resolved.
  (require-namespaces ^ProvidedNamespace/1 [^String/1 ns-strs]))

(deftype Require [^String ns-str
                  ^String alias-str     ;nil if no alias
                  ^vector refer-strs    ;nil means all, [] means none
                  ^map rename-strs
                  ^vector exclude-strs
                  ^seq error-context]
  java.lang.Record)
(defn required-ns-sym ^symbol [^Require require]
  (symbol nil (.ns-str require)))
(defn require-refer-none [^String ns-str ^seq error-context]
  (Require. ns-str nil [] {} [] error-context))
(defn require-refer-all [^String ns-str ^seq error-context]
  (Require. ns-str nil nil {} [] error-context))
(def require-core-lib-default ;applies if no :refer-clojure clause is present
  (require-refer-all cfg/core-lib nil))

;;; Compiling a Clojure namespace means to mutate the system state one
;;; top-level form at a time.  Model this with a mutable namespace
;;; builder that both keeps track of the lookup tables the compiler
;;; depends on, and that collects the pieces of information that will
;;; be written to class files.
;;;
;;; Threading: Instance is confined to the single thread that parses
;;; the non-function parts of a namespace.
(definterface NamespaceBuilder
  :extends [Resolver]
  (universe ^NamespaceProvider [])
  (process-require ^NamespaceBuilder [^Require require
                                      ^ProvidedNamespace provided])
  (process-imports ^NamespaceBuilder [^seq import-strs])

  ;; Adds the new binding to the namespace.  Returns an expression
  ;; that initializes the binding with its value (if any).  Pass empty
  ;; expression as `init` if no intial value is provided.
  (new-def-immutable ^Expr [^String nm ^Expr init])
  (new-def-mutable ^Expr [^String nm ^Expr init])
  (new-def-alias ^Expr [^String nm ^Entity other-ent
                        ^String other-nmsp ^String other-nm])

  ;; FIXME... see tcljc/emitter/namespace.cljt
  ;; hack for dependency chain core_print.cljt
  ;; -> MultiFn.java -> tinyclj.core fns
  (load-file ^NamespaceBuilder [^String path-str])

  (process-init-form ^NamespaceBuilder [^long fctx form])
  
  (finish ^ProvidedNamespace [])
  (commit-segment-and-revert [^int end-of-segment ^map then-globals
                              ^map then-imports]))

(defn ns-sym ^symbol [^NamespaceBuilder nmsp]
  (symbol nil (.ns-str nmsp)))

;;; ------------------------------------------------------------------------

;;; An ExprFactory provides an API to the parser to generate a
;;; representation of the namespace's entities and their executable
;;; code.
;;; 
;;; Threading: Confined to a single thread, either one parsing a
;;; function or to the thread parsing the non-function parts of a
;;; namespace.
(definterface ExprFactory
  (empty-expr ^Expr [])
  (new-exprs ^Exprs [^int length])

  ;; hook into entity tracking to build environment of a closure:
  (value-of ^Expr [^Entity ent ^symbol form])
  (invoke ^Expr [^long fctx ^seq form ^Invocable inv ^Exprs args])
  
  ;; Create an entity denoting the constant `value` of type `type`.
  ;; For the most part, there is a one-to-one correspondence between
  ;; the primitive (when possible) class of `value` and `type`.  The
  ;; literal `nil` is represented by ConstantDescs/NULL with a type of
  ;; type/polymorphic.
  ;; "Computationally int" constants (boolean, char, byte, short) are
  ;; represented by instances of Integer. and their `type` is
  ;; Boolean/TYPE, Character/TYPE, and so on.  A wide range of types
  ;; is accepted for `value`: instances of ConstantDesc, instances of
  ;; Constable, and structured values provided by Clojure (symbol,
  ;; keyword, vector, and so on).
  (constant-entity ^Entity [^Object value ^Class type]) ;ConstantDesc or Class
  (class-member-entity ^Entity [^Match m])
  
  ;; Create a symbol, a keyword, a collection, or a regex Pattern.
  ;; `value` usually is the compile time data structure as provided by
  ;; the reader.  Alternatively and only for collections (incl. the
  ;; with-meta construction), `value` can be an array `CodeEmitter/1`
  ;; of constant folded expressions, i.e. instances of `Loadable`.
  ;; Non-Constant loadables are never nil.
  (new-loadable ^Expr [^Object value ^Class expr-type])
  
  ;; These methods return a constant expression when possible:
  (attach-meta-to ^Expr [^Expr meta ^Expr arg])
  (new-collection ^Expr [^Class coll-type ^Exprs args])
  (new-array ^Expr [^long fctx ^Class array-type ^Exprs dims])

  ;; ### basics
  
  (progn-expr ^Expr [^Exprs xs ^Expr x])

  ;; Test, followed by the "true" path, optionally followed by
  ;; the "false" path.
  (if-expr ^Expr [^long fctx ^Exprs xs])
  
  ;; If the program provides a default path, then `paths-and-default`
  ;; has one more element than `guards`.
  (case-expr ^Expr [^Expr select ^Exprs/1 guards ^Exprs paths-and-default
                    ^long fctx ^seq/1 error-contexts])

  (invoke-value ^Expr [^long fctx ^Expr f ^Exprs args])
  
  ;; ### bindings

  (assignment ^Expr [^Entity ent ^Expr value])

  (new-parameter ^Expr [^int param-no ^String name ^Class type])
  
  (binding-alias ^Expr [^long fctx ^String name ^Entity ent])
  (binding-fresh ^Expr [^long fctx ^Class opt-type ^String name ^Expr init])
  (block-let ^Expr [^long fctx ^Exprs bindings ^Expr body])
  
  (with-recur-parameters ^ExprFactory [^Exprs parameters])
  (block-loop ^Expr [^long fctx ^Expr body])
  (recur-expr ^Expr [^long fctx ^Exprs args])
  
  (new-catching-local ^Expr [^long fctx ^Class type ^String name])
  (try-catch-finally ^Expr [^long fctx ^Exprs body+catches ^Class/1 catch-types
                            ^Exprs finally])
  
  ;; ### functions

  ;; Replaces any arity return types `auto-return-marker` with their
  ;; corresponding body's expression type.
  (new-function ^Expr [^Parser parser ^symbol fn-nm
                       ^BiFunction parse-arity-body ^AritySpec/1 arity-specs])

  
  
  ;; ### interop

  (type-cast ^Expr [^long fctx ^Class target-type ^Expr arg])
  
  (invoke-constructor ^Expr [^long fctx ^Class owner ^Exprs args])
  
  ;; Invoke static public method or field `mnm` of class `owner`.
  ;; Note: Invoking a field actually means to invoke the field's value
  ;; as a function, instead of just getting its value.
  (invoke-static-member ^Expr [^long fctx ^boolean invoke-value-of-field?
                               ^Class owner ^String mnm ^Exprs args])
  
  (invoke-virtual-member ^Expr [^long fctx ^Expr receiver
                                ^Class opt-owner ^String mnm ^Exprs args])

  (get-static-field ^Expr [^long fctx ^Class owner ^String mnm])
  (get-virtual-field ^Expr [^long fctx ^Expr receiver ^String mnm])
  
  (instanceof-expr ^Expr [^long fctx ^Class type ^Expr arg])
  (throw-expr ^Expr [^long fctx ^Expr arg]))

(definterface Parser
  (parse-form ^Expr [^long fctx form])
  
  ;; Frequency of change: very low.
  (resolver ^Resolver [])

  ;; Frequency of change: one for every `loop*` expression.
  (expr-factory ^ExprFactory [])
  
  ;; Maps simple name string to its associated binding.  The map can
  ;; be incomplete if a namespace `def` was parsed after creation of
  ;; the scope instance.  In this case, a second lookup using
  ;; `resolver` must be done to get an accurate picture of all `def`s.
  ;; Frequency of change: moderate.
  (bindings* ^map [])
  (with-bindings* ^Parser [^map bindings])
  (with-recur-parameters ^Parser [^Exprs parameters])
  (with-expr-factory ^Parser [^ExprFactory expr-factory]))

(defn new-constant ^Expr [^ExprFactory ef ^Object value ^Class type]
  (.value-of ef (.constant-entity ef value type) nil))

(defn exprs-of ^Exprs [^ExprFactory ef & ^Expr/1 xs*]
  (let [xs (.new-exprs ef (alength xs*))]
    (dotimes [i (.length xs)]
      (.set xs i (aget xs* i)))
    xs))

(defn parameter-bindings ^Exprs [^Parser parser ^ArityType at]
  (let [ef (.expr-factory parser)
        xs (.new-exprs ef (.parameter-count at))]
    (dotimes [i (.length xs)]
      (.set xs i (.new-parameter ef i (.parameter-name at i)
                                 (.parameter-type at i))))
    xs))

(defn with-local-binding
  (^Parser [^Parser parser ^Expr binding-expr]
   (let [bnd ^Binding (.emitter binding-expr)]
     (with-local-binding parser (.name bnd) (.bound-to bnd))))
  (^Parser [^Parser parser ^String nm ^Entity ent]
   (.with-bindings* parser (assoc (.bindings* parser) nm ent))))

(defn with-local-bindings ^Parser [^Parser parser ^Exprs binding-exprs]
  (loop [locals (transient (.bindings* parser))
         i 0]
    (if (< i (.length binding-exprs))
      (let [bnd ^Binding (.emitter binding-exprs i)]
        (recur (assoc! locals (.name bnd) (.bound-to bnd)) (inc i)))
      (.with-bindings* parser (persistent! locals)))))
