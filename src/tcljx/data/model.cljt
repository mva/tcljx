(ns tcljx.data.model
  (:require
   (tcljx.data [config :as cfg] [reflect :as reflect]))
  (:import
   (java.lang.classfile CodeBuilder)
   (java.lang.classfile.constantpool ConstantPoolBuilder LoadableConstantEntry)
   (java.lang.constant MethodHandleDesc MethodTypeDesc ConstantDescs)
   (java.util Arrays))
  (:refer-clojure :exclude [zero?]))

;;; Emit instruction code into the CodeBuilder instance.  Return the
;;; actual type of the value pushed onto operand stack, or nil if
;;; control leaves the current method.  The produced operand type can
;;; be either the original expression type baked into the emitter, or
;;; the provided `consumed-type` expected by the instruction that
;;; consumes the pushed operand.  If the returned operand type differs
;;; from `consumed-type`, then `emit/insn?` and `emit/then-leave?`
;;; adapt the on stack value to match the `consumed-type`.
;;;
;;; If `then-leave?` is set, then the emitted code is permitted to
;;; close with a return instruction.  In this case the returned type
;;; is nil.
;;; 
;;; No line number is passed to the method.  This limits any adapting
;;; instructions to get to `consumed-type` to "safe" ones that are
;;; known to never raise an exception.  `insn?` and `then-leave?` must
;;; close over the consumer form's line number to perform throwing
;;; adaptions like CHECKCAST.
(definterface CodeEmitter
  (emit-insn* ^Class [^CodeBuilder xb ^Class consumed-type
                      ^boolean then-leave?]))


;;; A named entity on the level of the code generator that exists at
;;; runtime, usually appearing as the "provide the value of the given
;;; name" operation of a binding.  Exposes additional operations
;;; beyond "emit code that produces this entity's value".  The code
;;; emitted by Entity itself puts its current value on the operand
;;; stack.
;;;
;;; Implementation note: To ease certain code generation patterns,
;;; identity of Entity instances is important.  A runtime entity
;;; should be mirrored by at most one Entity instance during
;;; compilation.
(definterface Entity
  :extends [CodeEmitter]
  ;; The type of the value to load from or store in the entity.
  (entity-type ^Class [])

  ;; Emits code taking one operand from the stack and overwrites the
  ;; entity's current value with it.
  (emit-store ^CodeBuilder [^CodeBuilder xb])
  (emit-iinc ^CodeBuilder [^CodeBuilder xb ^int const]) ;optional
  
  ;; Returns false if control then leaves the method.
  (emit-setup-code? ^boolean [^CodeBuilder xb ^CodeEmitter init]))



;;; The parser works with opaque instances of Expr exclusively.  An
;;; Expr gives a very restricted view on whatever data the code
;;; generator keeps around to do its job, implemented by the generator
;;; class Insn).  In particular, Expr does not expose the expression's
;;; type.
(definterface Expr         ;FIXME... turn this into an abstract class?
  (emitter ^CodeEmitter []))

(definterface Exprs
  (length ^int [])
  (empty? ^boolean [])
  (get ^Expr [^int i])
  (set ^Expr [^int i ^Expr x])
  (emitter ^CodeEmitter [^int i])
  (drop ^Exprs [^int n]))


;;; A binding represents the partial evaluation to a runtime named
;;; entity.  Depending on the context it is used to detect aliasing of
;;; one name to another, to identify a macro expansion form, and to
;;; produce the bound value of the binding.
(definterface Binding
  :extends [CodeEmitter]
  ;; The runtime entity for which this binding provides a name.  There
  ;; can be multiple bindings referring to the same shared entity.  In
  ;; this case, only the root binding performs initialization of the
  ;; entity by calling `emit-setup-code`.
  (bound-to ^Entity [])

  ;; The expression that produces the entity's value.
  (bound-value ^Expr [])

  ;; Every binding has a name, but only global bindings on the
  ;; namespace level provide a non-nil namespace name.
  (namespace ^String [])                ;non nil if global def
  (name ^String []))

(defn binding-name ^symbol [^Binding bnd] ;for error messages
  (symbol (.namespace bnd) (.name bnd)))

(defn global? ^boolean [^Binding bnd]
  (some? (.namespace bnd)))

(defn require-binding
  (^Binding [^Expr x]
   (.emitter x))
  (^Binding [^Exprs xs ^int i]
   (.emitter xs i)))

;;; ------------------------------------------------------------------------

;;; Any entity that can be turned into either an LDC instruction as
;;; part of a method's code attribute, or into a loadable entry inside
;;; the constant pool.  The method `emit-insn*` emits an LDC or
;;; equivalent instruction, and `emit-setup-code` is empty.
(definterface Loadable
  :extends [Entity]
  ;; If `logical-type?` is true, then make sure the entry materializes
  ;; as the actual logical type of the loadable, instead of its
  ;; computational type.  Only makes a difference to computational int
  ;; types other than int: boolean, character, byte, and short.
  (loadable-entry ^LoadableConstantEntry [^ConstantPoolBuilder cpb
                                          ^boolean logical-type?])
  
  ;; Return the compile time data structure representation of this
  ;; loadable.
  (datafy ^Object []))

(defn loadable?
  (^boolean [^Expr x]
   (instance? Loadable (.emitter x)))
  (^boolean [^Exprs xs ^int i]
   (instance? Loadable (.emitter xs i))))


;;; Constant values must be visible to the parser, because type
;;; expression literals (for example `Classname` or `Classname/1`) are
;;; part of the syntax of some special forms.  Constant values are
;;; visible to the code generator to support bottom up constant
;;; folding while building the expression tree.
(definterface Constant
  :extends [Loadable]
  (computational-value ^Object [])) ;ConstantDesc or Class, and never nil

(defn const?
  (^boolean [^Expr x]
   (instance? Constant (.emitter x)))
  (^boolean [^Exprs xs ^int i]
   (instance? Constant (.emitter xs i))))

(defn null? ^boolean [^Object value]
  (identical? ConstantDescs/NULL value))
(defn zero? ^boolean [^Object value]
  (and (instance? Number value) (= (.doubleValue ^Number value) 0.0)))
(defn ce-const? ^boolean [^CodeEmitter ce]
  (instance? Constant ce))
(defn ce-const-value ^Object [^CodeEmitter ce]
  (when (ce-const? ce)
    (Constant/.computational-value ce)))
(defn ce-null? ^boolean [^CodeEmitter ce]
  (and (ce-const? ce) (null? (ce-const-value ce))))
(defn ce-zero? ^boolean [^CodeEmitter ce]
  (and (ce-const? ce) (zero? (ce-const-value ce))))

(defn const-value
  (^Object [^Expr x]                    ;nil if `x` is not a Constant
   (ce-const-value (.emitter x)))
  (^Object [^Exprs xs ^int i]        ;nil if `xs[i]` is not a Constant
   (ce-const-value (.emitter xs i))))

(defn type-expression ^Class [^Expr x form] ;nil if no type expression
  (when-some [value (const-value x)]
    (when (and (class? value) (symbol? form))
      value)))

;;; ------------------------------------------------------------------------

;;; Description of an arity's signature.  Basically the information
;;; encoded in an `fn` parameter vector, with the parameter names
;;; being optional.
(definterface ArityType
  ;; The arity's return type.  In case of `auto-return-type`, this is
  ;; replaced with the arity body's result type.
  (return-type ^Class [])
  (with-return-type ^ArityType [^Class tp])
  
  ;; This is the "internal" parameter list that is used to parse and
  ;; compile the arity.  That is, for the variadic case the last/rest
  ;; parameter is of type `ISeq`.
  (parameter-types ^Class/1 [])
  (parameter-type ^Class [^int i])
  
  ;; Number of parameters.
  (parameter-count ^int [])

  ;; The names of the parameters if the arity is being compiled from
  ;; source.  For an imported function this is nil.
  (parameter-names ^String/1 [])
  (parameter-name ^String [^int i])

  ;; JVM-style varargs arity/method with an array parameter like
  ;; `Object...` or `int...`.  Mutually exclusive with `variadic?`.
  (varargs? ^boolean [])

  ;; Clojure-style variadic arity with an `ISeq` rest parameter.
  ;; External view on the arity's method is a varargs `Object...` with
  ;; a bridge method in between.  Mutually exclusive with `varargs?`.
  (variadic? ^boolean [])
  )

(deftype ArityTypeImpl [^Class return-type
                        ^Class/1 parameter-types
                        ^String/1 parameter-names]
  java.lang.Record
  ArityType
  (with-return-type [_ tp]
    (ArityTypeImpl. tp parameter-types parameter-names))
  (parameter-count [_]
    (alength parameter-types))
  (parameter-name [_ ^int i]
    (aget parameter-names i))
  (parameter-type [_ ^int i]
    (aget parameter-types i))
  (varargs? [_]                         ;FIXME...
    false)
  (variadic? [_]                        ;FIXME...
    false))

(defn mtd-of-arity-type ^MethodTypeDesc [^ArityType at]
  (MethodTypeDesc/of (reflect/describe-class (.return-type at))
                     (reflect/describe-class* (.parameter-types at))))


(definterface Invocable
  :extends [Entity]
  (invoke* ^Expr [^long fctx ^seq form ^Exprs xs]))

(defn bound-invocable ^Invocable [^Binding bnd]
  (when (instance? Invocable (.bound-to bnd))
    (.bound-to bnd)))

;;; If `x` is a binding, then return the very first non-aliasing
;;; binding that defines its value.  Otherwise, return nil.
#_(defn root ^Binding [^Expr x]
    (loop [^Binding bnd nil, x x]
      (if (binding? x)
        (let [bnd ^Binding x] (recur bnd (.init bnd)))
        bnd)))

;;; ------------------------------------------------------------------------

;;; Represents the current state of globals and namespace aliases at
;;; this point, and the set of classes defined in the JVM classloader
;;; at this time.  All sets of entities include the declarations done
;;; before this point.  `lookup-global-qname` and `lookup-namespace`
;;; never return entities declared after this point.  Because of
;;; concurrency, `lookup-class` may return class instances defined in
;;; parallel or at a later point.
(definterface Resolver
  (ns-str ^String [])                   ;the name of this namespace
  (lookup-namespace ^String [^String alias]) ;nil if not found

  ;; Called by the reader to replace a syntax quoted simple name with
  ;; its namespace qualified equivalent.  Returns nil if there is no
  ;; such global name at this point in the namespace.
  (lookup-global-qname ^symbol [^String nm])

  ;; Look up class by alias or by name.  May cache resolved class
  ;; names for the scope of the namespace.  Returns nil if not found.
  (lookup-class ^Class [^String nm])
  
  ;; Returns the binding representing the def form for `nm` in
  ;; namespace `nmsp`, or nil if no such binding exists.  Use nil as
  ;; `nmsp` to refer to the current namespace.
  (lookup-def ^Binding [^String nmsp ^String nm])

  ;; Generates unique names for fn* and reify* instances within a
  ;; given namespace.  `dflt-nm` of nil means function or interface
  ;; function.
  (pick-unique-name ^String [^String dflt-nm]))

;;; ------------------------------------------------------------------------

(deftype ProvidedNamespace [^String ns-str]
  java.lang.Record)

(definterface NamespaceProvider
  ;; Resolves and compiles the namespace names in `ns-strs`.  Returns
  ;; an instance of `ProvidedNamespace` in the corresponding element
  ;; of the result, or an element of value nil if the namespace name
  ;; could not be resolved.
  (require-namespaces ^ProvidedNamespace/1 [^String/1 ns-strs]))

(deftype Require [^String ns-str
                  ^String alias-str     ;nil if no alias
                  ^vector refer-strs    ;nil means all, [] means none
                  ^map rename-strs
                  ^vector exclude-strs
                  ^seq error-context]
  java.lang.Record)
(defn required-ns-sym ^symbol [^Require require]
  (symbol nil (.ns-str require)))
(defn require-refer-none [^String ns-str ^seq error-context]
  (Require. ns-str nil [] {} [] error-context))
(defn require-refer-all [^String ns-str ^seq error-context]
  (Require. ns-str nil nil {} [] error-context))
(def require-core-lib-default ;applies if no :refer-clojure clause is present
  (require-refer-all cfg/core-lib nil))

;;; Compiling a Clojure namespace means to mutate the system state one
;;; top-level form at a time.  Model this with a mutable namespace
;;; builder that both keeps track of the lookup tables the compiler
;;; depends on, and that collects the pieces of information that will
;;; be written to class files.
;;;
;;; Threading: Instance is confined to the single thread that parses
;;; the non-function parts of a namespace.
(definterface NamespaceBuilder
  :extends [Resolver]
  (universe ^NamespaceProvider [])
  (process-require ^NamespaceBuilder [^Require require
                                      ^ProvidedNamespace provided])
  (process-imports ^NamespaceBuilder [^seq import-strs])

  ;; Adds the new binding to the namespace.  Returns an expression
  ;; that initializes the binding with its value (if any).  Pass an
  ;; `init` of nil if no intial value is provided.
  (new-def-init ^Expr [^String nm ^Expr init])
  (new-def-alias ^Expr [^String nm ^Binding other])

  ;; FIXME... see tcljc/emitter/namespace.cljt
  ;; hack for dependency chain core_print.cljt
  ;; -> MultiFn.java -> tinyclj.core fns
  (load-file ^NamespaceBuilder [^String path-str])

  (process-init-form ^NamespaceBuilder [^long fctx form])
  (finish ^ProvidedNamespace []))

(definterface SegmentBuilder
  (commit-segment-and-revert [^int end-of-segment-elements
                              ^map then-globals
                              ^map then-imports]))

(defn ns-sym ^symbol [^NamespaceBuilder nmsp]
  (symbol nil (.ns-str nmsp)))

;;; ------------------------------------------------------------------------

;;; An ExprFactory provides an API to the parser to generate a
;;; representation of the namespace's entities and their executable
;;; code.
;;; 
;;; Threading: Confined to a single thread, either one parsing a
;;; function or to the thread parsing the non-function parts of a
;;; namespace.
(definterface ExprFactory
  (empty-expr ^Expr [])
  (new-exprs ^Exprs [^int length])
  
  ;; Create an expression denoting the constant `value` of type
  ;; `expr-type`.  For the most part, there is a one-to-one
  ;; correspondence between the primitive (when possible) class of
  ;; `value` and `expr-type`.  The literal `nil` is represented by
  ;; ConstantDescs/NULL with a type of type/polymorphic.
  ;; "Computationally int" constants (boolean, char, byte, short) are
  ;; represented by instances of Integer. and their `expr-type` is
  ;; Boolean/TYPE, Character/TYPE, and so on.  A wide range of types
  ;; is accepted for `value`: instances of ConstantDesc, instances of
  ;; Constable, and structured values provided by Clojure (symbol,
  ;; keyword, vector, and so on).
  (new-constant ^Expr [^Class expr-type ^Object value]) ;ConstantDesc or Class
  
  ;; Create a symbol, a keyword, a collection, or a regex Pattern.
  ;; `value` usually is the compile time data structure as provided by
  ;; the reader.  Alternatively and only for collections (incl. the
  ;; with-meta construction), `value` can be an array `CodeEmitter/1`
  ;; of constant folded expressions, i.e. instances of `Loadable`.
  ;; Non-Constant loadables are never nil.
  (new-loadable ^Expr [^Class expr-type ^Object value])
  
  ;; These methods return a constant expression when possible:
  (attach-meta-to ^Expr [^Expr meta ^Expr arg])
  (new-vector ^Expr [^Exprs args])
  (new-map ^Expr [^Exprs args])
  (new-set ^Expr [^Exprs args])
  (new-list ^Expr [^Exprs args])
  (new-array ^Expr [^long fctx ^Class array-type ^Exprs dims])

  ;; ### basics
  
  (progn-expr ^Expr [^Exprs xs ^Expr x])

  ;; Test, followed by the "true" path, optionally followed by
  ;; the "false" path.
  (if-expr ^Expr [^long fctx ^Exprs xs])
  
  ;; If the program provides a default path, then `paths-and-default`
  ;; has one more element than `guards`.
  (case-expr ^Expr [^Expr select ^Exprs/1 guards ^Exprs paths-and-default
                    ^long fctx ^seq/1 error-contexts])

  (invoke ^Expr [^long fctx ^Object form ^Invocable inv ^Exprs args])
  
  ;; ### bindings

  (assignment ^Expr [^Binding bnd ^Expr value])

  (new-parameter ^Expr [^int param-no ^String name ^Class type])
  
  (new-local ^Expr [^long fctx ^boolean fresh-entity? ^Class opt-type
                    ^String name init-or-binding])
  (block-let ^Expr [^long fctx ^Exprs bindings ^Expr body])
  
  (with-recur-parameters ^ExprFactory [^Exprs parameters])
  (block-loop ^Expr [^long fctx ^Expr body])
  (recur-expr ^Expr [^long fctx ^Exprs args])
  
  (new-catching-local ^Expr [^long fctx ^Class type ^String name])
  (try-catch-finally ^Expr [^long fctx ^Exprs body+catches ^Class/1 catch-types
                            ^Expr finally])
  
  ;; ### functions
  
  ;; Replaces any arity return types `auto-return-marker` with their
  ;; corresponding body's expression type.
  (new-function ^Expr [^String mangled-name
                       ^ArityType/1 arity-types
                       ^Exprs arity-bodies
                       ^MethodHandleDesc/1 arity-redirections])
  
  ;; ### interop

  (type-cast ^Expr [^long fctx ^Class target-type ^Expr arg])
  
  (invoke-constructor ^Expr [^long fctx ^Class owner ^Exprs args])
  
  ;; Invoke static public method or field `mnm` of class `owner`.
  ;; Note: Invoking a field actually means to invoke the field's value
  ;; as a function, instead of just getting its value.
  (invoke-static-member ^Expr [^long fctx ^boolean invoke-value-of-field?
                               ^Class owner ^String mnm ^Exprs args])
  
  (invoke-virtual-member ^Expr [^long fctx ^Expr receiver ^String mnm
                                ^Exprs args])

  (get-static-field ^Expr [^long fctx ^Class owner ^String mnm])
  (get-virtual-field ^Expr [^long fctx ^Expr receiver ^String mnm])

  (instanceof-expr ^Expr [^long fctx ^Class type ^Expr arg])
  (throw-expr ^Expr [^long fctx ^Expr arg])
  
  ;; ### misc
  
  (mk-expr ^Expr [form]))               ;FIXME... drop this

(defn exprs-of ^Exprs [^ExprFactory ef & ^Expr/1 xs*]
  (let [xs (.new-exprs ef (alength xs*))]
    (dotimes [i (.length xs)]
      (.set xs i (aget xs* i)))
    xs))

(definterface Scope
  (parse-form ^Expr [^long fctx form])

  ;; Frequency of change: very low.
  (resolver ^Resolver [])

  ;; Frequency of change: one for every `loop*` expression.
  (expr-factory ^ExprFactory [])
  
  ;; Maps simple name string to its associated binding.  The map can
  ;; be incomplete if a namespace `def` was parsed after creation of
  ;; the scope instance.  In this case, a second lookup using
  ;; `resolver` must be done to get an accurate picture of all `def`s.
  ;; Frequency of change: moderate.
  (bindings* ^map [])
  (with-bindings* ^Scope [^map bindings])
  (with-recur-parameters ^Scope [^Exprs parameters]))

(defn parameter-bindings ^Exprs [^Scope scope ^ArityType at]
  (let [ef (.expr-factory scope)
        xs (.new-exprs ef (.parameter-count at))]
    (dotimes [i (.length xs)]
      (.set xs i (.new-parameter ef i (.parameter-name at i)
                                 (.parameter-type at i))))
    xs))
