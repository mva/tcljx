;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.data.config
  (:require
   #_[tcljx.files :as files]
   #_[tinyclj.string :as str])
  (:import
   #_(java.lang.constant ClassDesc)
   #_(java.lang.invoke MethodHandles$Lookup)
   #_(java.net URLClassLoader URL)
   #_(java.nio.file Path Files)
   #_(java.nio.file.attribute PosixFilePermission PosixFilePermissions)
   #_(java.util Set)
   #_(java.util.function Predicate)))

;; ;;; If true, the both the compilation and the emit thread are free to
;; ;;; fork of work to other threads.  Set this to false to force them to
;; ;;; compile namespaces sequentially and emit class files in order.
;; (def fork-work? #_false true)

;; ;; Emit ClassFile attribute SourceFile & Code attribute LineNumberTable?
;; (def enable-line-numbers true)

;; ;; Emit Code attribute LocalVariableTable?  This adds constant pool
;; ;; entries for parameter and bindings names plus their type
;; ;; descriptors, increasing the pressure on the constant pool.
;; (def enable-local-variables true)

(def no-line-number 0)

(def core-lib "tinyclj.core")
;; (def core-lib-sym (symbol nil core-lib))
(defn core-lib? ^boolean [^String ns-str] (= core-lib ns-str))

;;; note: the `regex-literal` symbol is spliced into the core lib's
;;; namespace (similar to e.g. `*ns*`) and bound to a predefined macro
(def sym-regex-literal (symbol core-lib "regex-literal"))
(def sym-quote 'quote)

;;; note: a copy of this lives in tinyclj.core/specials
(def specials '#{def loop* recur if case* let* letfn*
                 do fn* quote var import* . set! deftype* reify* try throw
                 monitor-enter monitor-exit catch finally new &
                 ;; special forms that are not special in Clojure:
                 definterface* instanceof*})

;; (def primitive-ns-str "tinyclj.lang.primitive")

;; (def key-force-clinit nil)

;; (def wait-cyclic-ms (* 5 1000l))

;; (def java-base-classes              ;almost all from package java.lang
;;   [Boolean Byte Character Class ClassLoader #_clojure.lang.Compiler Double
;;    Enum Float InheritableThreadLocal Integer Long Math Number Object
;;    Package Process ProcessBuilder Runtime RuntimePermission
;;    Short StackTraceElement StrictMath String
;;    #_StringBuffer StringBuilder System Thread ThreadGroup ThreadLocal
;;    Throwable Void Appendable CharSequence Cloneable Comparable
;;    Iterable Readable Runnable java.util.concurrent.Callable
;;    BigInteger BigDecimal
             
;;    ArithmeticException ArrayIndexOutOfBoundsException
;;    ArrayStoreException ClassCastException ClassNotFoundException
;;    CloneNotSupportedException EnumConstantNotPresentException
;;    Exception IllegalAccessException IllegalArgumentException
;;    IllegalMonitorStateException IllegalStateException
;;    IllegalThreadStateException IndexOutOfBoundsException
;;    InstantiationException  NegativeArraySizeException
;;    NoSuchFieldException NoSuchMethodException NullPointerException
;;    NumberFormatException RuntimeException SecurityException
;;    StringIndexOutOfBoundsException TypeNotPresentException
;;    UnsupportedOperationException AbstractMethodError AssertionError
;;    ClassCircularityError ClassFormatError Error
;;    ExceptionInInitializerError IllegalAccessError
;;    IncompatibleClassChangeError InstantiationError InternalError
;;    LinkageError NoClassDefFoundError NoSuchFieldError
;;    NoSuchMethodError OutOfMemoryError StackOverflowError
;;    UnknownError UnsatisfiedLinkError
;;    UnsupportedClassVersionError VerifyError VirtualMachineError
             
;;    Thread$UncaughtExceptionHandler Thread$State
;;    Deprecated Override SuppressWarnings])

;;; ------------------------------------------------------------------------


;; (defn nmsp-rpath ^Path [^String ns-str]
;;   (path-of (str (str/replace ns-str "." "/") source-suffix)))


;; (defn- path-seq [^Path p ^int max-depth ^Predicate pred]
;;   (try
;;     (-> p (Files/walk max-depth) (.filter pred) (.toArray) (seq))
;;     (catch java.nio.file.NoSuchFileException _ ;thrown if `p` does not exist
;;       nil)))

;; (def ^:private dir?
;;   (^Predicate fn [x]
;;    (Files/isDirectory x)))
;; (defn recursive-directory-seq [^Path p]
;;   (path-seq p Integer/MAX_VALUE dir?))

;; (def ^:private file?
;;   (^Predicate fn [x]
;;    (Files/isRegularFile x)))
;; (defn file-seq [^Path p]
;;   (path-seq p Integer/MAX_VALUE file?))
;; (defn- directory-file-seq [^Path p]
;;   (path-seq p 1 file?))

;; (defn- class-file? ^boolean [^Path x]
;;   (str/ends-with? (.toString x) class-suffix))

;; (defn delete-package-classes
;;   (^void [^Path pkg-dir]
;;    #_(prn :delete-package-classes (str pkg-dir "/*.class"))
;;    (doseq [^Path x (directory-file-seq pkg-dir) :when (class-file? x)]
;;      (Files/delete x)))
;;   (^void [^Path dest-dir ^String ns-str]
;;    (delete-package-classes (package-directory dest-dir ns-str))))

;; #_
;; (defn spit-class ^void [^Path dest-prefix ^String owner-name ^byte/1 b]
;;   (when (some? dest-prefix)
;;     (let [f (.resolve dest-prefix (path-of (str owner-name class-suffix)))]
;;       #_(println :spit-class (.toString f))
;;       (create-directories (.getParent f))
;;       (with-open [w (Files/newOutputStream f)]
;;         (.write w b)))))

;; ;;; ------------------------------------------------------------------------

;; (defn validate-defined-class ^Class [^Class cl]
;;   (let [nm (.getName cl)]
;;     (when-not (identical? cl (Class/forName nm false (.getClassLoader cl)))
;;       (throw (IllegalStateException.
;;               (str "failed to define class " nm " over existing class from "
;;                    "classpath")))))
;;   cl)

;; (defn internal-name ^String [^ClassDesc cd]
;;   (assert (not (.isArray cd)))
;;   (assert (not (.isPrimitive cd)))
;;   (let [desc (.descriptorString cd)]
;;     (.substring desc 1 (dec (.length desc))))) ;drop "L" and ";", but keep "/"

;;; ------------------------------------------------------------------------

;;; Because application and compiler can live in different class
;;; loaders with a different runtime (e.g. when bootstrapping
;;; tclj-in-tclj), it is easier to duplicate munge/demunge code.  See
;;; tinyclj/lang/Compiler.java

;; ;;; see OpenJDK classFileParser.cpp, verify_unqualified_name
;; (defn nm-repl ^String [^char c]
;;   (case c
;;     ;; \; nil                             ;invalid in symbol & class name
;;     ;; \[ nil                             ;invalid in symbol & class name
;;     \/ "_SLASH_"                        ;"/"
;;     \\ "_BSLASH_"                       ;"\\"
;;     \< "_LT_"                           ;"<"
;;     \> "_GT_"                           ;">"
;;     \. "_DOT_"                          ;"."
;;     nil))                              ;accept char

;; (def ^:private ^java.util.Map de-repl
;;   (java.util.Map/of "_SLASH_" "/"
;;                     "_BSLASH_" "\\"
;;                     "_LT_" "<"
;;                     "_GT_" ">"
;;                     "_DOT_" "."))

;; (defn munge-name ^String [nm-sym]   ;pre: `nm-sym` is symbol or string
;;   (let [nm (name nm-sym)]
;;     (letfn [(up-to-replacement ^int [^int s]
;;               (loop [i s]
;;                 (if (and (< i (.length nm))
;;                          (nil? (nm-repl (.charAt nm i))))
;;                   (recur (inc i))
;;                   i)))
;;             (replace-all ^String [^int s ^StringBuilder b]
;;               (let [e (up-to-replacement s)]
;;                 (if (= e (.length nm))
;;                   (str (.append b (subs nm s)))
;;                   (recur (inc e)
;;                          (doto b
;;                            (.append (subs nm s e))
;;                            (.append (nm-repl (.charAt nm e))))))))]
;;       (let [i (up-to-replacement 0)]
;;         (if (= i (.length nm))
;;           nm               ;common fast path: return existing instance
;;           (replace-all 0 (StringBuilder.)))))))

;; (defn demunge-name ^String [^String s]
;;   (if (neg? (.indexOf s "_"))
;;     s                      ;common fast path: return existing instance
;;     (str/replace s #"_(?:DOT|[LG]T|B?SLASH)_"
;;                  (fn [^String m] (.getOrDefault de-repl m m)))))

;; ;;; ------------------------------------------------------------------------

;; (def nano-time-zero (System/nanoTime))
;; (defn fmt-duration ^String [^long nanos]
;;   (let [ms (/ nanos 1000000.0)]
;;     (String/format java.util.Locale/ROOT "%5.2f" (object ms))))
;; (defn fmt-instance ^String [^long inst]
;;   (let [ms (/ (- inst nano-time-zero) 1000000.0)]
;;     (String/format java.util.Locale/ROOT "%7.2f" (object ms))))

;; (def ^:private *logger* (agent {}))

;; (defn- print-log [a ^String s]
;;   (.println System/out s)
;;   a)

;; (defn log-info ^void [label & parts]
;;   (let [now (System/nanoTime)
;;         s (str (fmt-instance now) " (info) "
;;                label " " (str/join " " parts)
;;                " [tid=" (.threadId (Thread/currentThread)) "]")]
;;     (send-off *logger* print-log s)))

;; (defn log-start ^long [label & parts]
;;   (let [now (System/nanoTime)
;;         s (str (fmt-instance now) " (start) "
;;                label " " (str/join " " parts)
;;                " [tid=" (.threadId (Thread/currentThread)) "]")]
;;     (send-off *logger* print-log s)
;;     now))

;; (defn log-end ^long [^long start label & parts]
;;   (let [now (System/nanoTime)
;;         s (str (fmt-instance now) " (" (fmt-duration (- now start)) ") "
;;                label " " (str/join " " parts)
;;                " [tid=" (.threadId (Thread/currentThread)) "]")]
;;     (send-off *logger* print-log s)
;;     now))
