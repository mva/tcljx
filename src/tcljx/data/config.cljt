;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljx.data.config
  (:require
   #_[tcljx.files :as files]
   #_[tinyclj.string :as str])
  (:import
   (java.lang.classfile ClassFile ClassBuilder)
   #_(java.lang.constant ClassDesc)
   #_(java.lang.invoke MethodHandles$Lookup)
   #_(java.net URLClassLoader URL)
   #_(java.nio.file Path Files)
   #_(java.nio.file.attribute PosixFilePermission PosixFilePermissions)
   #_(java.util Set)
   #_(java.util.function Predicate)))

;; ;;; If true, the both the compilation and the emit thread are free to
;; ;;; fork of work to other threads.  Set this to false to force them to
;; ;;; compile namespaces sequentially and emit class files in order.
;; (def fork-work? #_false true)

;; ;; Emit ClassFile attribute SourceFile & Code attribute LineNumberTable?
;; (def enable-line-numbers true)

;; ;; Emit Code attribute LocalVariableTable?  This adds constant pool
;; ;; entries for parameter and bindings names plus their type
;; ;; descriptors, increasing the pressure on the constant pool.
;; (def enable-local-variables true)

(defn with-class-version ^ClassBuilder [^ClassBuilder cb]
  (let [major ClassFile/JAVA_17_VERSION
        minor 0 #_ClassFile/PREVIEW_MINOR_VERSION]
    (.withVersion cb major minor)))

(def no-line-number 0)

(def core-lib "tinyclj.core")
;; (def core-lib-sym (symbol nil core-lib))
(defn core-lib? ^boolean [^String ns-str] (= core-lib ns-str))

(def sym-quote 'quote)

;;; note: a copy of this lives in tinyclj.core/specials
(def specials '#{def loop* recur if case* let* letfn*
                 do fn* quote var import* . set! deftype* reify* try throw
                 monitor-enter monitor-exit catch finally new &
                 ;; special forms that are not special in Clojure:
                 definterface* instanceof*})

(def primitive-ns-str "tinyclj.lang.primitive")

;; (def key-force-clinit nil)

;; (def wait-cyclic-ms (* 5 1000l))

;;; ------------------------------------------------------------------------

;; (defn nmsp-rpath ^Path [^String ns-str]
;;   (path-of (str (str/replace ns-str "." "/") source-suffix)))


;; (defn- path-seq [^Path p ^int max-depth ^Predicate pred]
;;   (try
;;     (-> p (Files/walk max-depth) (.filter pred) (.toArray) (seq))
;;     (catch java.nio.file.NoSuchFileException _ ;thrown if `p` does not exist
;;       nil)))

;; (def ^:private dir?
;;   (^Predicate fn [x]
;;    (Files/isDirectory x)))
;; (defn recursive-directory-seq [^Path p]
;;   (path-seq p Integer/MAX_VALUE dir?))

;; (def ^:private file?
;;   (^Predicate fn [x]
;;    (Files/isRegularFile x)))
;; (defn file-seq [^Path p]
;;   (path-seq p Integer/MAX_VALUE file?))
;; (defn- directory-file-seq [^Path p]
;;   (path-seq p 1 file?))

;; (defn- class-file? ^boolean [^Path x]
;;   (str/ends-with? (.toString x) class-suffix))

;; (defn delete-package-classes
;;   (^void [^Path pkg-dir]
;;    #_(prn :delete-package-classes (str pkg-dir "/*.class"))
;;    (doseq [^Path x (directory-file-seq pkg-dir) :when (class-file? x)]
;;      (Files/delete x)))
;;   (^void [^Path dest-dir ^String ns-str]
;;    (delete-package-classes (package-directory dest-dir ns-str))))

;; #_
;; (defn spit-class ^void [^Path dest-prefix ^String owner-name ^byte/1 b]
;;   (when (some? dest-prefix)
;;     (let [f (.resolve dest-prefix (path-of (str owner-name class-suffix)))]
;;       #_(println :spit-class (.toString f))
;;       (create-directories (.getParent f))
;;       (with-open [w (Files/newOutputStream f)]
;;         (.write w b)))))

;; ;;; ------------------------------------------------------------------------

;; (defn validate-defined-class ^Class [^Class cl]
;;   (let [nm (.getName cl)]
;;     (when-not (identical? cl (Class/forName nm false (.getClassLoader cl)))
;;       (throw (IllegalStateException.
;;               (str "failed to define class " nm " over existing class from "
;;                    "classpath")))))
;;   cl)

;; (defn internal-name ^String [^ClassDesc cd]
;;   (assert (not (.isArray cd)))
;;   (assert (not (.isPrimitive cd)))
;;   (let [desc (.descriptorString cd)]
;;     (.substring desc 1 (dec (.length desc))))) ;drop "L" and ";", but keep "/"

;;; ------------------------------------------------------------------------

;;; Because application and compiler can live in different class
;;; loaders with a different runtime (e.g. when bootstrapping
;;; tclj-in-tclj), it is easier to duplicate munge/demunge code.  See
;;; tinyclj/lang/Compiler.java

;;; see OpenJDK classFileParser.cpp, verify_unqualified_name
(defn nm-repl ^String [^char c]
  (case c
    ;; \; nil                             ;invalid in symbol & class name
    ;; \[ nil                             ;invalid in symbol & class name
    \/ "_SLASH_"                        ;"/"
    \\ "_BSLASH_"                       ;"\\"
    \< "_LT_"                           ;"<"
    \> "_GT_"                           ;">"
    \. "_DOT_"                          ;"."
    nil))                              ;accept char

;; (def ^:private ^java.util.Map de-repl
;;   (java.util.Map/of "_SLASH_" "/"
;;                     "_BSLASH_" "\\"
;;                     "_LT_" "<"
;;                     "_GT_" ">"
;;                     "_DOT_" "."))

(defn munge-name ^String [nm-sym]   ;pre: `nm-sym` is symbol or string
  (let [nm (name nm-sym)]
    (letfn [(up-to-replacement ^int [^int s]
              (loop [i s]
                (if (and (< i (.length nm))
                         (nil? (nm-repl (.charAt nm i))))
                  (recur (inc i))
                  i)))
            (replace-all ^String [^int s ^StringBuilder b]
              (let [e (up-to-replacement s)]
                (if (= e (.length nm))
                  (str (.append b (subs nm s)))
                  (recur (inc e)
                         (doto b
                           (.append (subs nm s e))
                           (.append (nm-repl (.charAt nm e))))))))]
      (let [i (up-to-replacement 0)]
        (if (= i (.length nm))
          nm               ;common fast path: return existing instance
          (replace-all 0 (StringBuilder.)))))))

;; (defn demunge-name ^String [^String s]
;;   (if (neg? (.indexOf s "_"))
;;     s                      ;common fast path: return existing instance
;;     (str/replace s #"_(?:DOT|[LG]T|B?SLASH)_"
;;                  (fn [^String m] (.getOrDefault de-repl m m)))))
