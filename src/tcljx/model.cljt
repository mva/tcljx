(ns tcljx.model
  (:require (tcljx [config :as cfg] [reflect :as reflect]))
  (:import (java.lang.constant MethodHandleDesc MethodTypeDesc ConstantDescs)
           (java.util Arrays)))

#_(definterface Type
  )

;;; Emit instruction code into the CodeBuilder instance.  Return the
;;; logical type of the value pushed on operand stack.  This is either
;;; the original expression type, or the value of the `requested-type`
;;; argument.  If the returned type differs from `requested-type`,
;;; then it is the caller's responsibility to adapt the operand value
;;; to the latter.
;;; 
;;; Right now, line numbers are only written to decorate stack traces.
;;; A bytecode instruction must emit a line number pseudo instruction
;;; before its own opcode only if an exception may be raised during
;;; the opcode's execution.
(definterface CodeEmitter
  (emit-code* ^Class [^java.lang.classfile.CodeBuilder xb ^Class requested-type
                      ^int line]))

;;; A named entity on the level of the code generator that exists at
;;; runtime.  Exposes additional operations beyond "emit code that
;;; produces this entity's value".  The code emitted by Entity
;;; itself (if any) usually only establishes the entity without
;;; putting a value on the operand stack.  The exception are loadable
;;; constant values, where establishing the value *does* push it onto
;;; the stack.
;;;
;;; Implementation note: To ease certain code generation patterns,
;;; identity of Entity instances is important.  A runtime entity
;;; should be mirrored by at most one Entity instance during
;;; compilation.
(definterface Entity :extends [CodeEmitter])

;;; The parser works with opaque instances of Expr exclusively.  An
;;; Expr gives a very restricted view on whatever data the code
;;; generator keeps around to do its job, implemented by the generator
;;; class Insn).  In particular, Expr does not expose the expression's
;;; type.
(definterface Expr         ;FIXME... turn this into an abstract class?
  ;; If this expression is backed by a runtime entity, then return it.
  ;; Otherwise, return nil.
  (emitter ^CodeEmitter [])
  (entity ^Entity []))

(def entity Expr/.entity)
(defn require-entity ^Entity [^Expr x]
  (java.util.Objects/requireNonNull (entity x)))

;;; ------------------------------------------------------------------------

;;; Constant values must be visible to the parser, because type
;;; expression literals (for example `Classname` or `Classname/1`) are
;;; part of the syntax of some special forms.  Constant values are
;;; visible to the code generator to support bottom up constant
;;; folding while building the expression tree.
(definterface Constant
  :extends [Entity]
  (const-value ^Object []))             ;never nil

(defn const? ^boolean [^Expr x]
  (instance? Constant (.entity x)))
(defn const-value ^Object [^Expr x]     ;nil if not a constant
  (let [e (.entity x)]
    (when (instance? Constant e)
      (.const-value ^Constant e))))

;;; ------------------------------------------------------------------------

;;; A binding represents the partial evaluation to a runtime named
;;; entity.  Depending on the context it is used to detect aliasing of
;;; one name to another, to identify a macro expansion form, and to
;;; produce the bound value of the binding.
(definterface Binding ;FIXME... change this name once picture becomes clearer
  :extends [Entity]
  (namespace ^String [])                ;non-nil for namespace def
  (name ^String [])
  (init ^Expr [])                       ;Binding if this is an alias
  (bound-value ^Expr []))

(defn binding? ^boolean [^Expr x]
  (instance? Binding (.entity x)))
(defn def? ^boolean [^Binding bnd]
  (some? (.namespace bnd)))

(defn binding-name ^symbol [^Binding bnd] ;for error messages
  (symbol (.namespace bnd) (.name bnd)))


(definterface Parameter
  :extends [Binding]
  (type ^Class []))

;;; Description of an arity's signature.  Basically the information
;;; encoded in an `fn` parameter vector, with the parameter names
;;; being optional.
(definterface ArityType
  ;; The arity's return type.  In case of `auto-return-type`, this is
  ;; replaced with the arity body's result type.
  (return-type ^Class [])
  (with-return-type ^ArityType [^Class tp])
  
  ;; This is the "internal" parameter list that is used to parse and
  ;; compile the arity.  That is, for the variadic case the last/rest
  ;; parameter is of type `ISeq`.
  (parameter-types ^Class/1 [])
  (parameter-type ^Class [^int i])
  
  ;; Number of parameters.
  (parameter-count ^int [])

  ;; The names of the parameters if the arity is being compiled from
  ;; source.  For an imported function this is nil.
  (parameter-names ^String/1 [])
  (parameter-name ^String [^int i]))

(deftype ArityTypeImpl [^Class return-type
                        ^Class/1 parameter-types
                        ^String/1 parameter-names]
  java.lang.Record
  ArityType
  (with-return-type [_ tp]
    (ArityTypeImpl. tp parameter-types parameter-names))
  (parameter-count [_]
    (alength parameter-types))
  (parameter-name [_ ^int i]
    (aget parameter-names i))
  (parameter-type [_ ^int i]
    (aget parameter-types i)))

(defn mtd-of-arity-type ^MethodTypeDesc [^ArityType at]
  (MethodTypeDesc/of (reflect/describe-class (.return-type at))
                     (reflect/describe-class* (.parameter-types at))))

(definterface FnLiteral
  :extends [Entity]
  (mangled-name ^String [])
  (arity-types ^ArityType/1 [])
  (arity-bodies ^Expr/1 [])
  (arity-redirections ^MethodHandleDesc/1 []))

;;; If `x` is a binding, then return the very first non-aliasing
;;; binding that defines its value.  Otherwise, return nil.
#_(defn root ^Binding [^Expr x]
    (loop [^Binding bnd nil, x x]
      (if (binding? x)
        (let [bnd ^Binding x] (recur bnd (.init bnd)))
        bnd)))

;;; ------------------------------------------------------------------------

;;; Represents the current state of globals and namespace aliases at
;;; this point, and the set of classes defined in the JVM classloader
;;; at this time.  All sets of entities include the declarations done
;;; before this point.  `lookup-global-qname` and `lookup-namespace`
;;; never return entities declared after this point.  Because of
;;; concurrency, `lookup-class` may return class instances defined in
;;; parallel or at a later point.
(definterface Resolver
  (ns-str ^String [])                   ;the name of this namespace
  (lookup-namespace ^String [^String alias]) ;nil if not found

  ;; Called by the reader to replace a syntax quoted simple name with
  ;; its namespace qualified equivalent.  Returns nil if there is no
  ;; such global name at this point in the namespace.
  (lookup-global-qname ^symbol [^String nm])

  ;; Look up class by alias or by name.  May cache resolved class
  ;; names for the scope of the namespace.  Returns nil if not found.
  (lookup-class ^Class [^String nm])
  
  ;; Returns the binding representing the def form for `nm` in
  ;; namespace `nmsp`, or nil if no such binding exists.  Use nil as
  ;; `nmsp` to refer to the current namespace.
  (lookup-def ^Binding [^String nmsp ^String nm])

  ;; Generates unique names for fn* and reify* instances within a
  ;; given namespace.  `dflt-nm` of nil means function or interface
  ;; function.
  (pick-unique-name ^String [^String dflt-nm]))

;;; ------------------------------------------------------------------------

(deftype ProvidedNamespace [^String ns-str]
  java.lang.Record)

(definterface NamespaceProvider
  ;; Resolves and compiles the namespace names in `ns-strs`.  Returns
  ;; an instance of `ProvidedNamespace` in the corresponding element
  ;; of the result, or an element of value nil if the namespace name
  ;; could not be resolved.
  (require-namespaces ^ProvidedNamespace/1 [^String/1 ns-strs]))

(deftype Require [^String ns-str
                  ^String alias-str     ;nil if no alias
                  ^vector refer-strs    ;nil means all, [] means none
                  ^map rename-strs
                  ^vector exclude-strs
                  ^seq error-context]
  java.lang.Record)
(defn required-ns-sym ^symbol [^Require require]
  (symbol nil (.ns-str require)))
(defn require-refer-none [^String ns-str ^seq error-context]
  (Require. ns-str nil [] {} [] error-context))
(defn require-refer-all [^String ns-str ^seq error-context]
  (Require. ns-str nil nil {} [] error-context))
(def require-core-lib-default ;applies if no :refer-clojure clause is present
  (require-refer-all cfg/core-lib nil))

;;; Compiling a Clojure namespace means to mutate the system state one
;;; top-level form at a time.  Model this with a mutable namespace
;;; builder that both keeps track of the lookup tables the compiler
;;; depends on, and that collects the pieces of information that will
;;; be written to class files.
;;;
;;; Threading: Instance is confined to the single thread that parses
;;; the non-function parts of a namespace.
(definterface NamespaceBuilder
  :extends [Resolver]
  (universe ^NamespaceProvider [])
  (process-require ^NamespaceBuilder [^Require require
                                      ^ProvidedNamespace provided])
  (process-imports ^NamespaceBuilder [^seq import-strs])
  (add-def ^Binding [^String nm ^Binding bnd])
  
  ;; FIXME... see tcljc/emitter/namespace.cljt
  ;; hack for dependency chain core_print.cljt
  ;; -> MultiFn.java -> tinyclj.core fns
  (load-file ^NamespaceBuilder [^String path-str])

  (process-init-form ^NamespaceBuilder [form])
  (finish ^ProvidedNamespace []))

(definterface SegmentBuilder
  (commit-segment-and-revert [^int end-of-segment-elements
                              ^map then-globals
                              ^map then-imports]))

(defn ns-sym ^symbol [^NamespaceBuilder nmsp]
  (symbol nil (.ns-str nmsp)))

;;; ------------------------------------------------------------------------

;;; Threading: Confined to a single thread, either one parsing a
;;; function or to the thread parsing the non-function parts of a
;;; namespace.
(definterface ExprFactory
  (new-array ^Expr/1 [^int n])
  (empty ^Expr [])
  (line-number ^Expr [^Integer line ^Expr x])
  (progn ^Expr [^Expr/1 xs])
  (new-constant ^Expr [^Class expr-type ^Object value])

  ;; ### bindings

  ;; Adds the new binding to the namespace.  Returns an expression
  ;; that initializes the binding with its value (if any).  Pass an
  ;; `init` of nil if no intial value is provided.
  (new-def-init ^Expr [^NamespaceBuilder nmsp ^String nm ^Expr init])
  (new-def-alias ^Expr [^NamespaceBuilder nmsp ^String nm ^Binding other])
  (assignment ^Expr [^Binding bnd ^Expr value])


  ;; ### functions
  (new-parameter ^Expr [^int param-no ^String name ^Class type])

  ;; Replaces any arity return types `auto-return-marker` with their
  ;; corresponding body's expression type.
  (new-function ^Expr [^FnLiteral fn-literal])
  
  ;; ### interop

  (invoke-constructor ^Expr [^Class owner ^Expr/1 args])
  
  ;; Invoke static public method or field `mnm` of class `owner`.
  ;; Note: Invoking a field actually means to invoke the field's value
  ;; as a function, instead of just getting its value.
  (invoke-static-member ^Expr [^boolean invoke-value-of-field?
                               ^Class owner ^String mnm ^Expr/1 args])
  (invoke-virtual-member ^Expr [^Expr receiver ^String mnm ^Expr/1 args])

  ;; ### misc
  
  (mk-expr ^Expr [form]))

(defn progn* ^Expr [^ExprFactory ef & ^Expr/1 xs]
  (.progn ef xs))
(defn progn ^Expr [^ExprFactory ef ^Expr/1 statements ^Expr x]
  (let [a (Arrays/copyOf statements (inc (alength statements)))]
    (aset a (alength statements) x)
    (.progn ef a)))

(defn aconst-null ^Expr [^ExprFactory ef]
  (.new-constant ef Void ConstantDescs/NULL))

(definterface Scope
  (parse-form ^Expr [form])

  ;; Frequency of change: very low.
  (resolver ^Resolver [])

  ;; Frequency of change: does not change at all.
  (expr-factory ^ExprFactory [])

  ;; Maps simple name string to its associated binding.  The map can
  ;; be incomplete if a namespace `def` was parsed after creation of
  ;; the scope instance.  In this case, a second lookup using
  ;; `resolver` must be done to get an accurate picture of all `def`s.
  ;; Frequency of change: moderate.
  (bindings* ^map [])
  (with-bindings* ^Scope [^map bindings]))

(defn parameter-bindings ^Expr/1 [^Scope scope ^ArityType at]
  (let [ef (.expr-factory scope)
        xs (.new-array ef (.parameter-count at))]
    (dotimes [i (alength xs)]
      (aset xs i (.new-parameter ef i (.parameter-name at i)
                                 (.parameter-type at i))))
    xs))
