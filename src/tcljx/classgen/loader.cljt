(ns tcljx.classgen.loader
  (:require
   (tcljx.data [files :as files])
   [tcljx.classgen.beachhead :as beachhead])
  (:import
   (java.lang.classfile ClassFile ClassBuilder ClassHierarchyResolver
                        ClassHierarchyResolver$ClassHierarchyInfo)
   (java.lang.constant ClassDesc)
   (java.lang.invoke MethodHandles$Lookup)
   (java.net URLClassLoader URL)
   (java.nio.file Path Files)
   (java.util.concurrent ConcurrentHashMap)
   (java.util.function Consumer)))

;;; Compilation scenario "distinct runtimes".  The compiler is, for
;;; example, a Clojure application running from `getSystemClassLoader`
;;; with its own runtime.  On the other hand, the application being
;;; compiled needs to see the Tinyclj runtime, plus any additional
;;; classes imported by the application.  In this case, the
;;; application can not be based on `getSystemClassLoader`, but only
;;; on the neutral `getPlatformClassLoader`.  The Tinyclj runtime and
;;; imported application classes must be installed manually into a
;;; fresh application class loader.
(defn app-class-loader ^URLClassLoader [parent class-paths]
  (let [parent-ld (case parent
                    :platform (ClassLoader/getPlatformClassLoader)
                    :system (ClassLoader/getSystemClassLoader))
        urls (into-array URL (map files/path-url class-paths))]
    (URLClassLoader. "tclj-app" urls parent-ld)))

(defn- class-loader-instance ^URLClassLoader [^ClassLoader parent ^String name
                                              source-paths]
  (let [dyn-cl-class (.loadClass parent "tinyclj.lang.DynamicClassLoader")
        c (.getConstructor dyn-cl-class String URL/1 ClassLoader)
        urls (->> source-paths (map files/path-url) (distinct) (into-array URL))]
    (.newInstance c name urls parent)))

(defn dyn-class-loader ^URLClassLoader [^ClassLoader app-ld source-paths]
  (class-loader-instance app-ld "tclj-dyn" source-paths))

(defn- get-rt-lookup ^MethodHandles$Lookup [^ClassLoader app-ld]
  (let [cl (Class/forName "tinyclj.lang.CljCljMapper" false app-ld)
        f (.getDeclaredField cl "rtLookup")]
    (.get f nil)))

;;; ------------------------------------------------------------------------

(deftype Loader [^Path dest-dir         ;may be nil
                 ^ClassLoader dyn-ld
                 ^MethodHandles$Lookup rt-lookup
                 ^Consumer class-sink
                 ^ClassHierarchyResolver chr-from-file])

;;; If a non-nil `dest-dir` is provided, then class files will be
;;; written to this directory.  If a non-nil `class-sink` is provided,
;;; then the ClassByte instance is passed to the sink after it has
;;; been defined.
(defn mk-loader
  (^Loader [^Path dest-dir ^ClassLoader app-ld]
   (mk-loader dest-dir app-ld (dyn-class-loader app-ld [])))
  (^Loader [^Path dest-dir ^ClassLoader app-ld ^ClassLoader dyn-ld]
   (mk-loader dest-dir app-ld dyn-ld nil))
  (^Loader [^Path dest-dir ^ClassLoader app-ld ^ClassLoader dyn-ld
            ^Consumer class-sink]
   (Loader. dest-dir dyn-ld (get-rt-lookup app-ld) class-sink
            (ClassHierarchyResolver/ofResourceParsing dyn-ld))))

(defn resolve-rt-class ^Class [^Loader loader ^ClassDesc cld]
  (.resolveConstantDesc cld (.rt-lookup loader)))

(deftype PackageBuilder [^String pkg-name
                         ^Path pkg-dir
                         ^MethodHandles$Lookup lookup-in-pkg
                         ^Consumer class-sink
                         ^ClassHierarchyResolver chr-from-file
                         ^ConcurrentHashMap chr-class-map]
  ClassHierarchyResolver
  (getClassInfo [_ class-desc]
    (or (.get chr-class-map class-desc)
        (.getClassInfo chr-from-file class-desc))))

;;; Coordinates cross cutting concerns for building and defining
;;; classes.  For the Class-File API it provides the class hierarchy
;;; resolver, and for class definition a mechanism to enforce "super
;;; class is defined before extending class".
(defn mk-package-builder ^PackageBuilder [^Loader loader ^String ns-str]
  (let [pkg-dir (files/prepare-package-directory (.dest-dir loader) ns-str)
        lookup-in-pkg (beachhead/mk-lookup-in-pkg (.rt-lookup loader)
                                                  (.dyn-ld loader) ns-str)]
    (PackageBuilder. ns-str pkg-dir lookup-in-pkg (.class-sink loader)
                     (.chr-from-file loader) (ConcurrentHashMap.))))

;;; For future class building, declare that `cld` is an interface
;;; class.
(defn declare-interface ^void [^PackageBuilder pkg-build ^ClassDesc cld]
  (.put (.chr-class-map pkg-build) cld
        (ClassHierarchyResolver$ClassHierarchyInfo/ofInterface)))

;;; For future class building, declare that `cld` extends
;;; `super-class`.
(defn declare-super-class ^void [^PackageBuilder pkg-build ^ClassDesc cld
                                 ^ClassDesc super-class]
  (.put (.chr-class-map pkg-build) cld
        (ClassHierarchyResolver$ClassHierarchyInfo/ofClass super-class)))

;;; ------------------------------------------------------------------------

(deftype ClassBytes [^ClassDesc this-class
                     ^ClassDesc super-class
                     ^byte/1 class-bytes
                     ^Class defined-class]
  java.lang.Record)

(defn- class-file-of ^ClassFile [^ClassHierarchyResolver dyn-chr]
  (ClassFile/of
   java.lang.classfile.ClassFile$DeadCodeOption/KEEP_DEAD_CODE
   (java.lang.classfile.ClassFile$ClassHierarchyResolverOption/of dyn-chr)))

(defn- with-version ^ClassBuilder [^ClassBuilder cb]
  (let [major ClassFile/JAVA_17_VERSION
        minor 0 #_ClassFile/PREVIEW_MINOR_VERSION]
    (.withVersion cb major minor)))

(defn- with-source-file ^ClassBuilder [^ClassBuilder cb ^String source-file]
  (cond-> cb
    (some? source-file)
    (.with (java.lang.classfile.attribute.SourceFileAttribute/of source-file))))

(defn- build ^ClassBytes [^PackageBuilder pkg-build
                          ^ClassDesc this-class ^int flags
                          ^ClassDesc super-class ^String source-file
                          ^Consumer class-builder-handler]
  (let [cbh (^Consumer fn ^void [^ClassBuilder cb]
             (.accept class-builder-handler
                      (-> (with-version cb)
                          (.withFlags flags)
                          (.withSuperclass super-class)
                          (with-source-file source-file))))]
    (ClassBytes. this-class super-class
                 (.build (class-file-of pkg-build) this-class cbh) nil)))

(defn- write ^ClassBytes [^ClassBytes cbs ^PackageBuilder pkg-build]
  (when-some [pkg-dir (.pkg-dir pkg-build)]
    (let [fnm (str (-> cbs .this-class .displayName) files/class-suffix)]
      (with-open [w (Files/newOutputStream (.resolve pkg-dir fnm))]
        (.write w (.class-bytes cbs)))))
  cbs)

(defn- define ^ClassBytes [^ClassBytes cbs ^PackageBuilder pkg-build]
  (letfn [#_(internal-name ^String [^ClassDesc cld]
              (assert (not (.isArray cld)))
              (assert (not (.isPrimitive cld)))
              (let [desc (.descriptorString cld)]
                ;; drop "L" and ";", but keep "/"
                (.substring desc 1 (dec (.length desc)))))]

    (let [l (.lookup-in-pkg pkg-build)
          cl (.defineClass l (.class-bytes cbs))
          cbs (ClassBytes. (.this-class cbs) (.super-class cbs)
                           (.class-bytes cbs) cl)]
      #_                           ;FIXME... is this still true?  
      (-> (try
            (.defineClass l bs)
            (catch NoClassDefFoundError _
              ;; happens for example
              ;; with "pkg/ns0/n2$n2-n1$n2-n1-n0" from test case
              ;; tcljc.closure-test/nested
              (.findClass l (.replace (internal-name this-class) "/" ".")))))

      (when-some [sink (.class-sink pkg-build)]
        (.accept sink cbs)
        cbs))))

(defn- initialize ^ClassBytes [^ClassBytes cbs]
  ;; FIXME... disable this eventually? for development it is a
  ;; valuable sanity check!
  (let [cl (.defined-class cbs)
        nm (.getName cl)
        cl* (Class/forName nm true (.getClassLoader cl))]
    (when-not (identical? cl cl*)
      (throw (IllegalStateException.
              (str "failed to define class " nm
                   " over existing class from classpath"))))
    cbs))

(defn bwdi ^ClassBytes [^PackageBuilder pkg-build
                        ^ClassDesc this-class ^int flags
                        ^ClassDesc super-class ^String source-file
                        ^Consumer class-builder-handler]
  (-> (build pkg-build this-class flags super-class source-file
             class-builder-handler)
      (write pkg-build)
      (define pkg-build)
      (initialize)))
