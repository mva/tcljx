(ns tcljx.classgen.loader
  (:require
   [tcljx.files :as files]
   [tcljx.classgen.beachhead :as beachhead])
  (:import
   (java.lang.classfile ClassFile ClassBuilder ClassHierarchyResolver
                        ClassHierarchyResolver$ClassHierarchyInfo)
   (java.lang.constant ClassDesc)
   (java.lang.invoke MethodHandles$Lookup)
   (java.net URLClassLoader URL)
   (java.nio.file Path Files)
   (java.util.concurrent ConcurrentHashMap)
   (java.util.function Consumer)))

;;; Compilation scenario "distinct runtimes".  The compiler is, for
;;; example, a Clojure application running from `getSystemClassLoader`
;;; with its own runtime.  On the other hand, the application being
;;; compiled needs to see the Tinyclj runtime, plus any additional
;;; classes imported by the application.  In this case, the
;;; application can not be based on `getSystemClassLoader`, but only
;;; on the neutral `getPlatformClassLoader`.  The Tinyclj runtime and
;;; imported application classes must be installed manually into a
;;; fresh application class loader.
(defn app-class-loader ^URLClassLoader [parent class-paths]
  (let [parent-ld (case parent
                    :platform (ClassLoader/getPlatformClassLoader)
                    :system (ClassLoader/getSystemClassLoader))
        urls (into-array URL (map files/path-url class-paths))]
    (URLClassLoader. "tclj-app" urls parent-ld)))

(defn- class-loader-instance ^URLClassLoader [^ClassLoader parent ^String name
                                              source-paths]
  (let [dyn-cl-class (.loadClass parent "tinyclj.lang.DynamicClassLoader")
        c (.getConstructor dyn-cl-class String URL/1 ClassLoader)
        urls (->> source-paths (map files/path-url) (distinct) (into-array URL))]
    (.newInstance c name urls parent)))

(defn- dyn-class-loader ^URLClassLoader [^ClassLoader app-ld source-paths]
  (class-loader-instance app-ld "tclj-dyn" source-paths))

(defn- get-rt-lookup ^MethodHandles$Lookup [^ClassLoader app-ld]
  (let [cl (Class/forName "tinyclj.lang.CljCljMapper" false app-ld)
        f (.getDeclaredField cl "rtLookup")]
    (.get f nil)))

;;; ------------------------------------------------------------------------

(deftype Loader [^Path dest-dir         ;may be nil
                 ^ClassLoader dyn-ld
                 ^MethodHandles$Lookup rt-lookup
                 ^Consumer class-sink
                 ^ClassHierarchyResolver chr-from-file])

;;; If a non-nil `dest-dir` is provided, then class files will be
;;; written to this directory.  If a non-nil `class-sink` is provided,
;;; then the ClassByte instance is passed to the sink after it has
;;; been defined.
(defn mk-loader ^Loader [^Path dest-dir ^ClassLoader app-ld dyn-source-paths
                         ^Consumer class-sink]
  (let [dyn-ld (dyn-class-loader app-ld dyn-source-paths)]
    (Loader. dest-dir dyn-ld (get-rt-lookup app-ld) class-sink
             (ClassHierarchyResolver/ofResourceParsing dyn-ld))))

(deftype PackageBuilder [^Path pkg-dir
                         ^MethodHandles$Lookup lookup-in-pkg
                         ^Consumer class-sink
                         ^ClassHierarchyResolver chr-from-file
                         ^ConcurrentHashMap chr-class-map]
  ClassHierarchyResolver
  (getClassInfo [_ class-desc]
    (or (.get chr-class-map class-desc)
        (.getClassInfo chr-from-file class-desc))))

;;; Coordinates cross cutting concerns for building and defining
;;; classes.  For the Class-File API it provides the class hierarchy
;;; resolver, and for class definition a mechanism to enforce "super
;;; class is defined before extending class".
(defn mk-package-builder ^PackageBuilder [^Loader loader ^String ns-str]
  (let [pkg-dir (files/prepare-package-directory (.dest-dir loader) ns-str)
        lookup-in-pkg (beachhead/mk-lookup-in-pkg (.rt-lookup loader)
                                                  (.dyn-ld loader) ns-str)]
    (PackageBuilder. pkg-dir lookup-in-pkg (.class-sink loader)
                     (.chr-from-file loader) (ConcurrentHashMap.))))

;;; For future class building, declare that `cld` is an interface
;;; class.
(defn declare-interface ^void [^PackageBuilder pkg-build ^ClassDesc cld]
  (.put (.chr-class-map pkg-build) cld
        (ClassHierarchyResolver$ClassHierarchyInfo/ofInterface)))

;;; For future class building, declare that `cld` extends
;;; `super-class`.
(defn declare-super-class ^void [^PackageBuilder pkg-build ^ClassDesc cld
                                 ^ClassDesc super-class]
  (.put (.chr-class-map pkg-build) cld
        (ClassHierarchyResolver$ClassHierarchyInfo/ofClass super-class)))

(deftype ClassBytes [^ClassDesc this-class ^ClassDesc super-class
                     ^byte/1 class-bytes]
  java.lang.Record)

(letfn [(class-file-of ^ClassFile [^ClassHierarchyResolver dyn-chr]
          (ClassFile/of
           java.lang.classfile.ClassFile$DeadCodeOption/KEEP_DEAD_CODE
           (java.lang.classfile.ClassFile$ClassHierarchyResolverOption/of dyn-chr)))

        (with-version ^ClassBuilder [^ClassBuilder cb]
          (let [major ClassFile/JAVA_17_VERSION
                minor 0 #_ClassFile/PREVIEW_MINOR_VERSION]
            (.withVersion cb major minor)))

        (with-source-file ^ClassBuilder [^ClassBuilder cb ^String source-file]
          (cond-> cb
            (some? source-file)
            (.with (java.lang.classfile.attribute.SourceFileAttribute/of source-file))))]

  (defn build-and-write ^ClassBytes [^PackageBuilder pkg-build
                                     ^ClassDesc this-class ^int flags
                                     ^ClassDesc super-class ^String source-file
                                     ^Consumer class-builder-handler]
    (letfn [(internal-name ^String [^ClassDesc cld]
              (assert (not (.isArray cld)))
              (assert (not (.isPrimitive cld)))
              (let [desc (.descriptorString cld)]
                ;; drop "L" and ";", but keep "/"
                (.substring desc 1 (dec (.length desc)))))
            (initialize-class ^Class [^Class cl]
              ;; FIXME... disable this eventually? for development it
              ;; is a valuable sanity check!
              (let [nm (.getName cl)
                    cl* (Class/forName nm true (.getClassLoader cl))]
                (when-not (identical? cl cl*)
                  (throw (IllegalStateException.
                          (str "failed to define class " nm
                               " over existing class from classpath"))))
                cl))]
      
      (let [bs (->> (^Consumer fn ^void [^ClassBuilder cb]
                     (.accept class-builder-handler
                              (-> (with-version cb)
                                  (.withFlags flags)
                                  (.withSuperclass super-class)
                                  (with-source-file source-file))))
                    (.build (class-file-of pkg-build) this-class))
            l (.lookup-in-pkg pkg-build)]
        
        (when-some [pkg-dir (.pkg-dir pkg-build)]
          (let [clnm (.displayName this-class)
                fnm (str clnm files/class-suffix)]
            (with-open [w (Files/newOutputStream (.resolve pkg-dir fnm))]
              (.write w bs))))

        (initialize-class (.defineClass l bs))

        #_                             ;FIXME... is this still true?  
        (-> (try
              (.defineClass l bs)
              (catch NoClassDefFoundError _
                ;; happens for example
                ;; with "pkg/ns0/n2$n2-n1$n2-n1-n0" from test case
                ;; tcljc.closure-test/nested
                (.findClass l (.replace (internal-name this-class) "/" "."))))
            (initialize-class))

        (let [cbs (ClassBytes. this-class super-class bs)]
          (when-some [sink (.class-sink pkg-build)]
            (.accept sink cbs)
            cbs))))))
