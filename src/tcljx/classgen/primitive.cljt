(ns tcljx.classgen.primitive
  (:require
   (tcljx.data
    [config :as cfg] [type :as type] [resolve :as resolve] [reflect :as reflect]
    [model :as model] [wrong :as wrong])
   (tcljx.classgen
    [emit :as emit] [insn :as insn] [entity :as entity] [runtime :as rt]
    [constgen :as constgen] [condgen :as condgen])
   (tinyclj [string :as str]))
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.model Expr Exprs CodeEmitter Constant Invocable)
   (tcljx.classgen.insn Insn Insns)
   (java.lang.classfile Opcode CodeBuilder)
   (java.lang.classfile.constantpool ConstantPoolBuilder)
   (java.lang.classfile.instruction OperatorInstruction)
   (java.lang.constant ConstantDescs MethodTypeDesc)))

(defn take-args ^Insns [^seq form ^Exprs xs ^int n]
  (when-not (= (.length xs) n)
    (throw (wrong/wr-info (str (wrong/q (first form)) " takes " n
                               " argument" (when-not (= 1 n) "s")
                               (wrong/got-int (.length xs))))))
  xs)
(defn take-arg ^Insn [^seq form ^Exprs xs]
  (.get (take-args form xs 1) 0))


(letfn [(fold-cast-from ^Expr [^Class target-type c]
          ;; pre: `target-type` is primitive
          ;; pre: expression type of constant `c` is primitive
          (if (type/polymorphic? target-type)
            insn/insn-empty             ;casting some constant to void
            (-> (type/convert-from-constant target-type c)
                (entity/new-constant target-type))))]

  (defn- convert-to-primitive ^Insn [^Insn arg ^Class target-type]
    (or (when-some [c (model/const-value arg)]
          (fold-cast-from target-type c))
        (insn/cast-to arg target-type)))
  
  (defn- mk-convert-to-primitive ^Invocable [^Wrapper target]
    (let [target-type (.class-primitive target)
          numeric? (.numeric? target)]
      (^Invocable fn [form args]
       (let [arg (-> (take-arg form args) (insn/cast-to-logical))
             arg-type (insn/expr-type arg)]
         (cond
           (type/same? target-type arg-type)
           arg      ;elide conversion from primitive to same primitive
           
           (.isPrimitive arg-type)
           (convert-to-primitive arg target-type)
           
           :else           ;here holds: `arg-type` is a reference type
           (insn/cast-to (cond-> arg
                           (and numeric?
                                (not (.isAssignableFrom Number arg-type)))
                           (insn/cast-to Number))
                         target-type))))))

  (def ^:private convert-to-logical-truth
    (^Invocable fn [form args]
     (-> (take-arg form args)
         (insn/cast-to-logical)
         (condgen/logical-truth))))

  (def ^:private convert-to-object
    (^Invocable fn [form args]
     (let [arg (-> (take-arg form args) (insn/cast-to-logical))
           arg-tp (insn/expr-type arg)]
       (cond-> arg
         (.isPrimitive arg-tp)
         (insn/cast-to (.class-reference (type/of arg-tp))))))))

;;; ------------------------------------------------------------------------

(def ^:private op-instr (new OperatorInstruction/1 (- #_iinc 132 #_iadd 96)))
(let [opcodes (Opcode/values)]
  (dotimes [i (alength opcodes)]
    (let [opcode (aget opcodes i)]
      (when (and (<= #_iadd 96 (.bytecode opcode))
                 (< (.bytecode opcode) #_iinc 132))
        (aset op-instr (- i #_iadd 96) (OperatorInstruction/of opcode))))))


(deftype OpSpec [^Wrapper bottom-type ;arguments are at least widened to this
                 ^Wrapper top-type    ;... and at most widened to this
                 ^Opcode base-opcode
                 ^Number left-identity
                 ^Number right-identity]
  java.lang.Record)
(defn left-identity? [^OpSpec op ^Object const]
  (and (some? const) (= const (.left-identity op))))
(defn right-identity? [^OpSpec op ^Object const]
  (and (some? const) (= const (.right-identity op))))

(defn- numeric-op ^OpSpec [^Wrapper bottom-type ^Opcode base-opcode
                           ^Insn left-identity ^Insn right-identity]
  (OpSpec. bottom-type type/double base-opcode
           (when left-identity (model/const-value left-identity))
           (model/const-value right-identity)))

(defn- bitset-op ^OpSpec [^Opcode base-opcode ^Insn identity]
  (OpSpec. type/int type/long base-opcode
           (model/const-value identity) (model/const-value identity)))


(letfn [(op-type ^Class [^int opcd]
          (case opcd
            0 Integer/TYPE
            1 Long/TYPE
            2 Float/TYPE
            3 Double/TYPE))
        
        (const-fold-int ^int [^int bytecode ^Number c0 ^Number c1]
          (let [a0 (.intValue c0), a1 (.intValue c1)]
            (case bytecode
              #_iadd 96 (+ a0 a1)
              #_isub 100 (- a0 a1)
              #_imul 104 (* a0 a1)
              #_idiv 108 (quot a0 a1)
              #_irem 112 (rem a0 a1)
              #_ishl 120 (bit-shift-left a0 a1)
              #_ishr 122 (bit-shift-right a0 a1)
              #_iushr 124 (unsigned-bit-shift-right a0 a1)
              #_iand 126 (bit-and a0 a1)
              #_ior 128 (bit-or a0 a1)
              #_ixor 130 (bit-xor a0 a1))))
        (const-fold-long ^long [^int bytecode ^Number arg0 ^Number arg1]
          (let [a0 (.longValue arg0), a1 (.longValue arg1)]
            (case bytecode
              #_ladd 97 (+ a0 a1)
              #_lsub 101 (- a0 a1)
              #_lmul 105 (* a0 a1)
              #_ldiv 109 (quot a0 a1)
              #_lrem 113 (rem a0 a1)
              #_lshl 121 (bit-shift-left a0 (int a1))
              #_lshr 123 (bit-shift-right a0 (int a1))
              #_lushr 125 (unsigned-bit-shift-right a0 (int a1))
              #_land 127 (bit-and a0 a1)
              #_lor 129 (bit-or a0 a1)
              #_lxor 131 (bit-xor a0 a1))))
        (const-fold-float ^float [^int bytecode ^Number arg0 ^Number arg1]
          (let [a0 (.floatValue arg0), a1 (.floatValue arg1)]
            (case bytecode
              #_fadd 98 (+ a0 a1)
              #_fsub 102 (- a0 a1)
              #_fmul 106 (* a0 a1)
              #_fdiv 110 (/ a0 a1)
              #_frem 114 (rem a0 a1))))
        (const-fold-double ^double [^int bytecode ^Number arg0 ^Number arg1]
          (let [a0 (.doubleValue arg0), a1 (.doubleValue arg1)]
            (case bytecode
              #_dadd 99 (+ a0 a1)
              #_dsub 103 (- a0 a1)
              #_dmul 107 (* a0 a1)
              #_ddiv 111 (/ a0 a1)
              #_drem 115 (rem a0 a1))))
        (folded-constant ^CodeEmitter [^OpSpec op ^int opcd0
                                       ^Number c0 ^Number c1]
          (-> (let [bytecode (+ (-> op .base-opcode .bytecode) opcd0)]
                (case opcd0
                  #_int 0 (object (const-fold-int bytecode c0 c1))
                  #_long 1 (object (const-fold-long bytecode c0 c1))
                  #_float 2 (object (const-fold-float bytecode c0 c1))
                  #_double 3 (object (const-fold-double bytecode c0 c1))))
              (entity/mk-constant (op-type opcd0))))

        (info-type-mismatch ^Throwable [form ^Insns args ^int i ^String exp]
          (-> (str (wrong/q (first form)) " expects " exp " type for argument #"
                   (inc i) (wrong/got-types (insn/expr-types args)))
              (wrong/wr-info)))
        (info-top-type ^Throwable [^Wrapper top-type form ^Insns args ^int i]
          (info-type-mismatch form args i (if (identical? type/double top-type)
                                            "numeric"
                                            "integral")))
        (top-type-of
          (^Wrapper [^OpSpec op form ^Insns args]
           (top-type-of (.bottom-type op) (.top-type op) form args))
          (^Wrapper [^Wrapper bottom-type ^Wrapper top-type form ^Insns args]
           (loop [acc bottom-type, i (dec (alength (.expr-types args)))]
             (if (neg? i)
               acc
               (let [tp (aget (.expr-types args) i)]
                 (if (.isPrimitive tp)
                   (let [wtp (type/of tp)]
                     (if (type/primitive-assignable-from? top-type wtp)
                       (recur (if (type/primitive-assignable-from? acc wtp)
                                acc
                                wtp)
                              (dec i))
                       (throw (info-top-type top-type form args i))))
                   (throw (info-top-type top-type form args i))))))))
        (top-numeric-of ^Wrapper [form ^Insns args]
          (top-type-of type/int type/double form args))

        (consumed-as ^Wrapper [^Wrapper target ^Insns args ^int i]
          ;; pre: `target` is numeric type
          (let [tp (insn/expr-type args i)]
            (when (.isPrimitive tp)
              (let [wtp (type/of tp)]
                (when (type/primitive-assignable-from? target wtp)
                  (if (> (.primitive-id wtp) 3)
                    type/int   ;byte and short are computationally int
                    wtp))))))  ;int, long, float, or double
        (integral-type ^Wrapper [form ^Insns args ^int i]
          (or (consumed-as type/long args i)
              (throw (info-type-mismatch form args i "integral"))))
        (integer-type ^Wrapper [form ^Insns args ^int i]
          (or (consumed-as type/int args i)
              (throw (info-type-mismatch form args i "integer"))))
        (info-two-reference-args ^Throwable [form ^Insns args]
          (-> (str (wrong/q (first form)) " expects two reference arguments"
                   (wrong/got-types (insn/expr-types args)))
              (wrong/wr-info)))
        
        (op-2* ^CodeEmitter [^int base-bytecode ^int opcd0 ^int opcd1
                             ^CodeEmitter ce0 ^CodeEmitter ce1]
          (^CodeEmitter fn [xb line _ _]
           (let [tp0 (op-type opcd0), tp1 (op-type opcd1)
                 bytecode (+ base-bytecode opcd0)]
             (when (emit/insn? xb line tp0 ce0 false)
               (when (or (nil? ce1) (emit/insn? xb line tp1 ce1 false))
                 (when (<= #_idiv 108 bytecode #_drem 115)
                   ;; [il]div and [il]rem can raise a division by zero
                   ;; exception, so provide a line number for div & rem
                   (emit/line-number xb line))
                 (.with xb (aget op-instr (- bytecode #_iadd 96)))
                 tp0)))))
        (op-2 ^CodeEmitter [^OpSpec op ^int opcd0 ^int opcd1
                            ^CodeEmitter ce0 ^CodeEmitter ce1]
          (let [c0 (model/ce-const-value ce0)
                c1 (model/ce-const-value ce1)]
            (cond
              (left-identity? op c0)
              ce1
              (right-identity? op c1)
              ce0
              (and (some? c0) (some? c1))
              (folded-constant op opcd0 c0 c1)
              :else
              (op-2* (-> op .base-opcode .bytecode) opcd0 opcd1 ce0 ce1))))
        (op-n ^CodeEmitter [^OpSpec op ^int opcd ^CodeEmitter/1 ces]
          (loop [acc (aget ces 0), i 1]
            (if (< i (alength ces))
              (recur (op-2 op opcd opcd acc (aget ces i)) (inc i))
              acc)))

        (unary ^CodeEmitter [^OpSpec op ^int opcd ^CodeEmitter ce]
          (condp identical? (.base-opcode op)
            Opcode/ISUB
            (if-some [c (model/ce-const-value ce)]
              (folded-constant op opcd (.right-identity op) c)
              (op-2* (.bytecode Opcode/INEG) opcd opcd ce nil))
            Opcode/IDIV
            (if-some [c (model/ce-const-value ce)]
              (folded-constant op opcd (.right-identity op) c)
              (op-2 op opcd opcd (.emitter entity/insn-int-one) ce))
            #_else ce))
        (binary-numeric-insn ^Insn [^OpSpec op form ^Insns args]
          (let [args (take-args form args 2)
                wop-type (top-numeric-of form args)
                opcd (.primitive-id wop-type)]
            (-> (op-2 op opcd opcd (insn/emitter args 0) (insn/emitter args 1))
                (insn/mk-insn (.class-primitive wop-type)))))]
  
  (defn mk-nary-numeric ^Invocable [^OpSpec op]
    (^Invocable fn [form args]
     (let [args ^Insns args
           wop-type (top-type-of op form args)
           op-type (.class-primitive wop-type)]
       (-> (case (.length args)
             0 (entity/mk-constant (.right-identity op) op-type)
             1 (unary op (.primitive-id wop-type) (insn/emitter args 0))
             #_else (op-n op (.primitive-id wop-type) (.emitters args)))
           (insn/mk-insn op-type)))))

  (defn mk-binary-numeric ^Invocable [^OpSpec op]
    (^Invocable fn [form args]
     (binary-numeric-insn op form args)))
  
  (defn mk-binary-xdiv-integral [^OpSpec op] ;aka 'quot
    (^Invocable fn [form args]
     (let [insn (binary-numeric-insn op form args)
           op-type (.expr-type insn)]
       ;; FIXME... this does not work if the result is out of range of
       ;; long; maybe better: truncate with something along the line of
       ;; `(if (neg? x) (Math/ceil x) (Math/floor x))` (or put this
       ;; into a static method that first checks if the division
       ;; result is in range for long, and only falls back to the
       ;; ceil/floor variant if out of range)
       (cond-> insn
         (or (identical? Float/TYPE op-type) (identical? Double/TYPE op-type))
         (-> (convert-to-primitive Long/TYPE)
             (convert-to-primitive op-type))))))

  (def unary-bit-not
    (^Invocable fn [form args]
     (let [arg (take-arg form args)
           wop-type (integral-type form args 0)
           opcd (.primitive-id wop-type)]
       (-> (op-2 (bitset-op Opcode/IXOR entity/insn-int-zero)
                 opcd opcd (.emitter arg) (.emitter entity/insn-int-m1))
           (insn/mk-insn (.class-primitive wop-type))))))
  
  (def unary-xdefault ;FIXME... only use is shifted-one; find something better?
    (^Invocable fn [form args]
     (let [arg (take-arg form args)
           tp (.expr-type arg)]
       (cond
         (type/same? Void/TYPE tp) insn/insn-empty
         (.isPrimitive tp) (-> 0 (entity/mk-constant tp) (insn/mk-insn tp))
         :else entity/insn-null))))
  
  (defn mk-binary-shift ^Invocable [^Opcode base-opc]
    (let [op (OpSpec. type/int type/long base-opc nil 0)]
      (^Invocable fn [form args]
       (let [args (take-args form args 2)
             warg0 (integral-type form args 0)
             warg1 (integer-type form args 1)]
         (-> (op-2 op (.primitive-id warg0) (.primitive-id warg1)
                   (insn/emitter args 0) (insn/emitter args 1))
             (insn/mk-insn (.class-primitive warg0)))))))
  
  (defn mk-binary-compare ^Invocable [^int cmp-opcd] ;FIXME... drop?
    (^Invocable fn [form args]
     (let [args (take-args form args 2)
           wtop (top-numeric-of form args)]
       (if (identical? type/int wtop)
         (condgen/icmp (.get args 0) (.get args 1) cmp-opcd)
         (assert false)))))

  (def binary-identical
    (^Invocable fn [form args]
     (let [args (take-args form args 2)]
       (if (type/any-primitive? (.expr-types args))
         (throw (info-two-reference-args form args))
         (condgen/acmp (.get args 0) (.get args 1) condgen/cmp-eq))))))

;;; ------------------------------------------------------------------------

(def ^:private dyn-mark "\u0001")
(def ^:private const-mark "\u0002")
(def ^:private re-marks #"[\u0001\u0002]") ;note: hash of Pattern is not stable
(def ^:private cd-Objects (reflect/describe-class java.util.Objects))
(def ^:private mtd-String-Object-String
  (MethodTypeDesc/of ConstantDescs/CD_String
                     ConstantDescs/CD_Object ConstantDescs/CD_String))
(letfn [(prepare-concat-args ^Insns [^Insns args]
          ;; arguments are converted to their logical types and, if
          ;; they are of reference type, are then passed through
          ;; a "nil to empty string" filter
          (let [args' (insn/copy-of-insns args)]
            (loop [i (dec (.length args'))]
              (when-not (neg? i)
                (let [insn (insn/cast-to-logical args' i)
                      tp (insn/expr-type insn)]
                  (.set args' i
                        (if (or (.isPrimitive tp) (model/const? insn))
                          insn ;note: *all* constants are passed through
                          (-> (^CodeEmitter fn [xb line _ _]
                               (when (emit/insn? xb line tp (.emitter insn) false)
                                 (-> (.ldc xb "")
                                     (.invokestatic cd-Objects "toString"
                                                    mtd-String-Object-String))
                                 String))
                              (insn/mk-insn String))))
                  (recur (dec i)))))
            args'))
        (consts-to-lces ^java.util.List [^ConstantPoolBuilder cpb insns]
          (for [^Insn insn insns]
            (constgen/loadable-entry cpb (constgen/typed-constant-description-of insn))))
        (insn-str ^Insn [^String rstr ^Insns inv-args ^seq const-args]
          (let [recipe (entity/new-constant rstr String)]
            (cond
              (and (empty? const-args) (.empty? inv-args))
              recipe
               
              (and (= rstr dyn-mark)
                   (type/same? String (insn/expr-type inv-args 0)))
              (.get inv-args 0)   ;output of mhd-Objects-toString call
               
              (= rstr const-mark)
              (first const-args)

              :else
              (-> (^CodeEmitter fn [xb line _ _]
                   (let [cpb (.constantPool xb)
                         atypes (.expr-types inv-args) ;only logical types
                         mhe (.methodHandleEntry cpb rt/bsm-concat)
                         bsm (.bsmEntry cpb mhe (->> (cons recipe const-args)
                                                     (consts-to-lces cpb)))
                         mtd (insn/mtd-of-poly String atypes)
                         nat (.nameAndTypeEntry cpb ConstantDescs/DEFAULT_NAME
                                                mtd)]
                     (when (emit/typed-insns? xb line atypes
                                              (.emitters inv-args))
                       (-> (emit/line-number xb line)
                           (.invokedynamic (.invokeDynamicEntry cpb bsm nat)))
                       String)))
                  (insn/mk-insn String)))))]
  
  (def string-concat
    (^Invocable fn [form args]
     (let [args (prepare-concat-args args)]
       (loop [rparts nil, dyn-args nil, const-args nil, i 0]
         (if (= i (.length args))
           (insn-str (str/join "" (reverse rparts))
                     (insn/insns-of* (reverse dyn-args))
                     (reverse const-args))
           
           (let [x ^Insn (.get args i)]
             (if (model/const? x)
               (let [s (constgen/constant-literal-str x)
                     x-str (entity/new-constant s String)]
                 (if (re-find re-marks s)
                   (recur (cons const-mark rparts) dyn-args
                          (cons x-str const-args) (inc i))
                   (recur (cons s rparts) dyn-args const-args (inc i))))
               (recur (cons dyn-mark rparts) (cons x dyn-args)
                      const-args (inc i))))))))))

;;; ------------------------------------------------------------------------

(def primitive-nmsp-globals
  (letfn [(assoc-prim ^map [^map acc ^String nm ^Invocable inv]
            (assoc acc nm (entity/global-binding inv cfg/primitive-ns-str nm)))
          (assoc-nary ^map [^map acc ^String nm ^OpSpec op]
            (assoc-prim acc nm (mk-nary-numeric op)))
          (assoc-conversions ^map [^map acc]
            (-> (reduce (fn ^map [^map acc ^Wrapper wtp]
                          (let [tp (.class-primitive wtp)
                                nm (.getSimpleName tp)]
                            (assoc-prim acc nm (mk-convert-to-primitive wtp))))
                        acc type/primitive-types)
                ;; provide Clojure rules for (boolean ...)
                (assoc-prim "boolean" convert-to-logical-truth)
                (assoc-prim "object" convert-to-object)))]
    (-> {}
        (assoc-conversions)
        (assoc-nary "+" (numeric-op type/int Opcode/IADD
                                    entity/insn-int-zero entity/insn-int-zero))
        (assoc-nary "-" (numeric-op type/int Opcode/ISUB
                                    nil entity/insn-int-zero))
        (assoc-nary "*" (numeric-op type/int Opcode/IMUL
                                    entity/insn-int-one entity/insn-int-one))
        (assoc-nary "/" (numeric-op type/float Opcode/IDIV
                                    nil entity/insn-float-one))
        (assoc-prim "quot" (-> (numeric-op type/int Opcode/IDIV
                                           nil entity/insn-int-one)
                               (mk-binary-xdiv-integral)))
        (assoc-prim "rem" (-> (numeric-op type/int Opcode/IREM
                                          nil entity/insn-int-one)
                              (mk-binary-numeric)))

        (assoc-nary "bit-and" (bitset-op Opcode/IAND entity/insn-int-m1))
        (assoc-nary "bit-or" (bitset-op Opcode/IOR entity/insn-int-zero))
        (assoc-nary "bit-xor" (bitset-op Opcode/IXOR entity/insn-int-zero))
        (assoc-prim "bit-not" unary-bit-not)
        (assoc-prim "xdefault" unary-xdefault)
        (assoc-prim "bit-shift-left" (mk-binary-shift Opcode/ISHL))
        (assoc-prim "bit-shift-right" (mk-binary-shift Opcode/ISHR))
        (assoc-prim "unsigned-bit-shift-right" (mk-binary-shift Opcode/IUSHR))
        
        (assoc-prim "<" (mk-binary-compare condgen/cmp-lt))
        
        (assoc-prim "identical?" binary-identical)
        (assoc-prim "str" string-concat))))
