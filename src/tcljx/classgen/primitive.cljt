(ns tcljx.classgen.primitive
  (:require
   (tcljx.data
    [config :as cfg] [type :as type] [resolve :as resolve] [reflect :as reflect]
    [model :as model] [wrong :as wrong])
   (tcljx.classgen
    [emit :as emit] [insn :as insn] [entity :as entity] [runtime :as rt]
    [constgen :as constgen] [condgen :as condgen])
   (tinyclj [string :as str]))
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.model Expr Exprs CodeEmitter Constant Invocable)
   (tcljx.classgen.insn Insn Insns)
   (java.lang.classfile Opcode CodeBuilder)
   (java.lang.classfile.constantpool ConstantPoolBuilder)
   (java.lang.classfile.instruction OperatorInstruction)
   (java.lang.constant ConstantDescs MethodTypeDesc)))

(defn take-args ^Insns [^seq form ^Exprs xs ^int n]
  (when-not (= (.length xs) n)
    (throw (wrong/wr-info (str (wrong/q (first form)) " takes " n
                               " argument" (when-not (= 1 n) "s")
                               (wrong/got-int (.length xs))))))
  xs)
(defn take-arg ^Insn [^seq form ^Exprs xs]
  (.get (take-args form xs 1) 0))


(letfn [(fold-cast-from ^Expr [^Class target-type c]
          ;; pre: `target-type` is primitive
          ;; pre: expression type of constant `c` is primitive
          (if (type/polymorphic? target-type)
            insn/insn-empty             ;casting some constant to void
            (-> (type/convert-from-constant target-type c)
                (entity/new-constant target-type))))]

  (defn- convert-to-primitive ^Insn [^Insn arg ^Class target-type]
    (or (when-some [c (model/const-value arg)]
          (fold-cast-from target-type c))
        (insn/cast-to arg target-type)))
  
  (defn- mk-convert-to-primitive ^Invocable [^Wrapper target]
    (let [target-type (.class-primitive target)
          numeric? (.numeric? target)]
      (^Invocable fn [form args]
       (let [arg (-> (take-arg form args) (insn/cast-to-logical))
             arg-type (insn/expr-type arg)]
         (cond
           (type/same? target-type arg-type)
           arg      ;elide conversion from primitive to same primitive
           
           (.isPrimitive arg-type)
           (convert-to-primitive arg target-type)
           
           :else           ;here holds: `arg-type` is a reference type
           (insn/cast-to (cond-> arg
                           (and numeric?
                                (not (.isAssignableFrom Number arg-type)))
                           (insn/cast-to Number))
                         target-type))))))

  (def ^:private convert-to-logical-truth
    (^Invocable fn [form args]
     (-> (take-arg form args)
         (insn/cast-to-logical)
         (condgen/logical-truth))))

  (def ^:private convert-to-object
    (^Invocable fn [form args]
     (let [arg (-> (take-arg form args) (insn/cast-to-logical))
           arg-tp (insn/expr-type arg)]
       (cond-> arg
         (.isPrimitive arg-tp)
         (insn/cast-to (.class-reference (type/of arg-tp))))))))

;;; ------------------------------------------------------------------------

(def ^:private op-instr (new OperatorInstruction/1 (- #_iinc 132 #_iadd 96)))
(let [opcodes (Opcode/values)]
  (dotimes [i (alength opcodes)]
    (let [opcode (aget opcodes i)]
      (when (and (<= #_iadd 96 (.bytecode opcode))
                 (< (.bytecode opcode) #_iinc 132))
        (aset op-instr (- i #_iadd 96) (OperatorInstruction/of opcode))))))

(defn- with-bytecode ^CodeBuilder [^CodeBuilder xb ^int bytecode]
  (.with xb (aget op-instr (- bytecode #_iadd 96))))

(defn- operator ^CodeEmitter [^Class op-type ^int bytecode ^Insns args]
  (^CodeEmitter fn [xb line consumed-type _]
   (when (emit/insns? xb line op-type (.emitters args))
     (when (<= #_idiv 108 bytecode #_drem 115)
       ;; [il]div and [il]rem can raise a division by zero
       ;; exception, so provide a line number for div & rem
       (emit/line-number xb line))
     (with-bytecode xb bytecode)
     op-type)))

(deftype NumericOp [^Wrapper bottom-type ;arguments are widened to this
                    ^Opcode base-opcode
                    ^Number right-identity]
  java.lang.Record)
(defn- numeric-op ^NumericOp [^Wrapper bottom-type
                              ^Opcode base-opcode
                              ^Insn right-identity]
  (NumericOp. bottom-type base-opcode (model/const-value right-identity)))

(letfn [(opcode-delta ^int [^Class tp]
          (condp identical? tp
            Integer/TYPE 0
            Long/TYPE 1
            Float/TYPE 2
            Double/TYPE 3))
        (typed-bytecode ^int [^Opcode base-opc ^Class op-type]
          (+ (.bytecode base-opc) (opcode-delta op-type)))
        
        (const-fold-int ^int [^int bytecode ^Number c0 ^Number c1]
          (let [a0 (.intValue c0), a1 (.intValue c1)]
            (case bytecode
              #_iadd 96 (+ a0 a1)
              #_isub 100 (- a0 a1)
              #_imul 104 (* a0 a1)
              #_idiv 108 (quot a0 a1)
              #_irem 112 (rem a0 a1))))
        (const-fold-long ^long [^int bytecode ^Number arg0 ^Number arg1]
          (let [a0 (.longValue arg0), a1 (.longValue arg1)]
            (case bytecode
              #_ladd 97 (+ a0 a1)
              #_lsub 101 (- a0 a1)
              #_lmul 105 (* a0 a1)
              #_ldiv 109 (quot a0 a1)
              #_lrem 113 (rem a0 a1))))
        (const-fold-float ^float [^int bytecode ^Number arg0 ^Number arg1]
          (let [a0 (.floatValue arg0), a1 (.floatValue arg1)]
            (case bytecode
              #_fadd 98 (+ a0 a1)
              #_fsub 102 (- a0 a1)
              #_fmul 106 (* a0 a1)
              #_fdiv 110 (/ a0 a1)
              #_frem 114 (rem a0 a1))))
        (const-fold-double ^double [^int bytecode ^Number arg0 ^Number arg1]
          (let [a0 (.doubleValue arg0), a1 (.doubleValue arg1)]
            (case bytecode
              #_dadd 99 (+ a0 a1)
              #_dsub 103 (- a0 a1)
              #_dmul 107 (* a0 a1)
              #_ddiv 111 (/ a0 a1)
              #_drem 115 (rem a0 a1))))
        (const-fold ^Number [^Opcode base-opc ^Class op-type
                             ^Number c0 ^Number c1]
          (let [bytecode (typed-bytecode base-opc op-type)]
            (case (- bytecode (.bytecode base-opc))
              #_int 0 (object (const-fold-int bytecode c0 c1))
              #_long 1 (object (const-fold-long bytecode c0 c1))
              #_float 2 (object (const-fold-float bytecode c0 c1))
              #_double 3 (object (const-fold-double bytecode c0 c1)))))
        (const-inverse ^CodeEmitter [^NumericOp num-op ^Class op-type
                                     ^CodeEmitter ce]
          (when (model/ce-const? ce)
            (-> (const-fold (.base-opcode num-op) op-type
                            (.right-identity num-op) (model/ce-const-value ce))
                (entity/mk-constant op-type))))
        
        (top-numeric-of ^Class [^Wrapper bottom-type ^Class/1 expr-types]
          (loop [acc bottom-type, i (dec (alength expr-types))]
            (if (neg? i)
              (.class-primitive acc)
              (let [tp (aget expr-types i)]
                (when (.isPrimitive tp)
                  (let [wtp (type/of tp)]
                    (when (.numeric? wtp)
                      (recur (if (type/primitive-assignable-from? acc wtp)
                               acc
                               wtp)
                             (dec i)))))))))
        (info-two-numeric-args ^Throwable [form ^Insns args]
          (-> (str (wrong/q (first form)) " expects two numeric arguments"
                   (wrong/got-types (insn/expr-types args)))
              (wrong/wr-info)))
        (info-two-reference-args ^Throwable [form ^Insns args]
          (-> (str (wrong/q (first form)) " expects two reference arguments"
                   (wrong/got-types (insn/expr-types args)))
              (wrong/wr-info)))
        (info-numeric-args-only ^Throwable [form ^Insns args]
          (-> (str (wrong/q (first form)) " expects numeric arguments"
                   (wrong/got-types (insn/expr-types args)))
              (wrong/wr-info)))

        (emit-suffix ^CodeEmitter [^Opcode base-opc ^Class op-type
                                   ^CodeEmitter lhs ^CodeEmitter/1 ces
                                   ^int start]
          (let [bytecode (typed-bytecode base-opc op-type)]
            (^CodeEmitter fn [xb line consumed-type _]
             (when (emit/insn? xb line op-type lhs false)
               (loop [i start]
                 (if (< i (alength ces))
                   (let [ce (aget ces i)]
                     (when (emit/insn? xb line op-type ce false)
                       (when (<= #_idiv 108 bytecode #_drem 115)
                         ;; [il]div and [il]rem can raise a division by
                         ;; zero exception, so provide a line number for
                         ;; div & rem
                         (emit/line-number xb line))
                       (with-bytecode xb bytecode)
                       (recur (inc i))))
                   op-type))))))
        (fold-lhs-then-emit ^CodeEmitter [^Opcode base-opc ^Class op-type
                                          ^CodeEmitter/1 ces]
          ;; pre: (model/ce-const? (aget ces 0))
          (loop [lhs ^Number (model/ce-const-value (aget ces 0)), i 1]
            (cond
              (>= i (alength ces))
              (entity/mk-constant lhs op-type)
              
              (model/ce-const? (aget ces i))
              (-> (const-fold base-opc op-type lhs
                              (model/ce-const-value (aget ces i)))
                  (recur (inc i)))
              
              :else
              (emit-suffix base-opc op-type (entity/mk-constant lhs op-type)
                           ces i))))
        (fold-or-emit ^CodeEmitter [^Opcode base-opc ^Class op-type
                                    ^CodeEmitter/1 ces]
          (if (model/ce-const? (aget ces 0))
            (fold-lhs-then-emit base-opc op-type ces)
            (emit-suffix base-opc op-type (aget ces 0) ces 1)))
        (unary ^CodeEmitter [^NumericOp num-op ^Class op-type ^Insns args]
          (let [ce (insn/emitter args 0)]
            (condp identical? (.base-opcode num-op)
              Opcode/IADD
              (insn/emitter args 0)
                      
              Opcode/ISUB
              (or (const-inverse num-op op-type ce)
                  (operator op-type (typed-bytecode Opcode/INEG op-type) args))

              Opcode/IMUL 
              (insn/emitter args 0)

              Opcode/IDIV
              (or (const-inverse num-op op-type ce)
                  (->> (insn/insns-of entity/insn-int-one (.get args 0))
                       (operator op-type (typed-bytecode Opcode/IDIV op-type)))))))]
  
  (defn mk-nary-numeric ^Invocable [^NumericOp num-op]
    (^Invocable fn [form args]
     (let [args ^Insns args]
       (if-some [op-type (top-numeric-of (.bottom-type num-op)
                                         (.expr-types args))]
         (-> (case (.length args)
               0 (entity/mk-constant (.right-identity num-op) op-type)
               1 (unary num-op op-type args)
               #_else (fold-or-emit (.base-opcode num-op) op-type
                                    (.emitters args)))
             (insn/mk-insn op-type))
         (throw (info-numeric-args-only form args))))))

  (defn mk-binary-numeric ^Invocable [^Wrapper bottom-type ^Opcode base-opc]
    (^Invocable fn [form args]
     (let [args (take-args form args 2)]
       (if-some [op-type (top-numeric-of bottom-type (.expr-types args))]
         (insn/mk-insn (fold-or-emit base-opc op-type (.emitters args))
                       op-type)
         (throw (info-numeric-args-only form args))))))
  
  (def binary-xdiv-integral             ;aka 'quot
    (^Invocable fn [form args]
     (let [args (take-args form args 2)]
       ;; FIXME... this does not work if the result is out of range of
       ;; long; maybe better: truncate with something along the line of
       ;; `(if (neg? x) (Math/ceil x) (Math/floor x))` (or put this
       ;; into a static method that first checks if the division
       ;; result is in range for long, and only falls back to the
       ;; ceil/floor variant if out of range)
       (if-some [op-type (top-numeric-of type/int (.expr-types args))]
         (cond-> (insn/mk-insn (fold-or-emit Opcode/IDIV op-type
                                             (.emitters args))
                               op-type)
           (or (type/same? Float/TYPE op-type)
               (type/same? Double/TYPE op-type))
           (-> (convert-to-primitive Long/TYPE)
               (convert-to-primitive op-type)))
         (throw (info-numeric-args-only form args))))))
  
  (defn mk-binary-compare ^Invocable [^int cmp-opcd] ;FIXME... drop?
    (^Invocable fn [form args]
     (let [args (take-args form args 2)]
       (if-some [tp-top (top-numeric-of type/int (.expr-types args))]
         (if (type/same? Integer/TYPE tp-top)
           (condgen/icmp (.get args 0) (.get args 1) cmp-opcd)
           (assert false))
         (throw (info-two-numeric-args form args))))))

  (def binary-identical
    (^Invocable fn [form args]
     (let [args (take-args form args 2)]
       (if (type/any-primitive? (.expr-types args))
         (throw (info-two-reference-args form args))
         (condgen/acmp (.get args 0) (.get args 1) condgen/cmp-eq))))))

;;; ------------------------------------------------------------------------

(def ^:private dyn-mark "\u0001")
(def ^:private const-mark "\u0002")
(def ^:private re-marks #"[\u0001\u0002]") ;note: hash of Pattern is not stable
(def ^:private cd-Objects (reflect/describe-class java.util.Objects))
(def ^:private mtd-String-Object-String
  (MethodTypeDesc/of ConstantDescs/CD_String
                     ConstantDescs/CD_Object ConstantDescs/CD_String))
(letfn [(prepare-concat-args ^Insns [^Insns args]
          ;; arguments are converted to their logical types and, if
          ;; they are of reference type, are then passed through
          ;; a "nil to empty string" filter
          (let [args' (insn/copy-of-insns args)]
            (loop [i (dec (.length args'))]
              (when-not (neg? i)
                (let [insn (insn/cast-to-logical args' i)
                      tp (insn/expr-type insn)]
                  (.set args' i
                        (if (or (.isPrimitive tp) (model/const? insn))
                          insn ;note: *all* constants are passed through
                          (-> (^CodeEmitter fn [xb line _ _]
                               (when (emit/insn? xb line tp (.emitter insn) false)
                                 (-> (.ldc xb "")
                                     (.invokestatic cd-Objects "toString"
                                                    mtd-String-Object-String))
                                 String))
                              (insn/mk-insn String))))
                  (recur (dec i)))))
            args'))
        (consts-to-lces ^java.util.List [^ConstantPoolBuilder cpb insns]
          (for [^Insn insn insns]
            (constgen/loadable-entry cpb (constgen/typed-constant-value insn))))
        (insn-str ^Insn [^String rstr ^Insns inv-args ^seq const-args]
          (let [recipe (entity/new-constant rstr String)]
            (cond
              (and (nil? const-args) (.empty? inv-args))
              recipe
               
              (and (= rstr dyn-mark)
                   (type/same? String (insn/expr-type inv-args 0)))
              (.get inv-args 0)   ;output of mhd-Objects-toString call
               
              (= rstr const-mark)
              (first const-args)

              :else
              (-> (^CodeEmitter fn [xb line _ _]
                   (let [cpb (.constantPool xb)
                         atypes (.expr-types inv-args) ;only logical types
                         mhe (.methodHandleEntry cpb rt/bsm-concat)
                         bsm (.bsmEntry cpb mhe (->> (cons recipe const-args)
                                                     (consts-to-lces cpb)))
                         mtd (insn/mtd-of-poly String atypes)
                         nat (.nameAndTypeEntry cpb ConstantDescs/DEFAULT_NAME
                                                mtd)]
                     (when (emit/typed-insns? xb line atypes
                                              (.emitters inv-args))
                       (-> (emit/line-number xb line)
                           (.invokedynamic (.invokeDynamicEntry cpb bsm nat)))
                       String)))
                  (insn/mk-insn String)))))]
  
  (def string-concat
    (^Invocable fn [form args]
     (let [args (prepare-concat-args args)]
       (loop [rparts nil, dyn-args nil, const-args nil, i 0]
         (if (= i (.length args))
           (insn-str (str/join "" (reverse rparts))
                     (insn/insns-of* (reverse dyn-args))
                     (reverse const-args))
           
           (let [x ^Insn (.get args i)]
             (if (model/const? x)
               (let [c (constgen/typed-constant-value x)
                     s (if (seq? c)
                         (str (list* c)) ;wrap LazySeq
                         (str c))
                     x-str (entity/new-constant s String)]
                 (if (re-find re-marks s)
                   (recur (cons const-mark rparts) dyn-args
                          (cons x-str const-args) (inc i))
                   (recur (cons s rparts) dyn-args const-args (inc i))))
               (recur (cons dyn-mark rparts) (cons x dyn-args)
                      const-args (inc i))))))))))

;;; ------------------------------------------------------------------------

(def primitive-nmsp-globals
  (letfn [(assoc-prim ^map [^map acc ^String nm ^Invocable inv]
            (assoc acc nm (entity/mk-global cfg/primitive-ns-str nm inv)))
          (assoc-nary ^map [^map acc ^String nm ^NumericOp num-op]
            (assoc-prim acc nm (mk-nary-numeric num-op)))
          (assoc-conversions ^map [^map acc]
            (-> (reduce (fn ^map [^map acc ^Wrapper wtp]
                          (let [tp (.class-primitive wtp)
                                nm (.getSimpleName tp)]
                            (assoc-prim acc nm (mk-convert-to-primitive wtp))))
                        acc type/primitive-types)
                ;; provide Clojure rules for (boolean ...)
                (assoc-prim "boolean" convert-to-logical-truth)
                (assoc-prim "object" convert-to-object)))]
    (-> {}
        (assoc-conversions)
        (assoc-nary "+" (numeric-op type/int Opcode/IADD entity/insn-int-zero))
        (assoc-nary "-" (numeric-op type/int Opcode/ISUB entity/insn-int-zero))
        (assoc-nary "*" (numeric-op type/int Opcode/IMUL entity/insn-int-one))
        (assoc-nary "/" (numeric-op type/float Opcode/IDIV entity/insn-float-one))
        
        (assoc-prim "quot" binary-xdiv-integral)
        (assoc-prim "rem" (mk-binary-numeric type/int Opcode/IREM))
        (assoc-prim "identical?" binary-identical)
        (assoc-prim "<" (mk-binary-compare condgen/cmp-lt))
        (assoc-prim "str" string-concat))))
