(ns tcljx.classgen.runtime
  #_(:require (tcljx.classgen [reflect :as reflect]))
  (:import
   (java.lang.constant ClassDesc MethodTypeDesc MethodHandleDesc ConstantDescs
                       DirectMethodHandleDesc$Kind))
  (:refer-clojure :exclude [symbol vector map set list]))

;;; ------------------------------------------------------------------------

(def mtd-void-string (MethodTypeDesc/of ConstantDescs/CD_void
                                        ConstantDescs/CD_String))

;;; ------------------------------------------------------------------------

(def RT (ClassDesc/of "tinyclj.lang.RT"))

#_(def ClojureRT (ClassDesc/of "clojure.lang.RT"))

(def ^:private clnm-ifn 'clojure.lang.IFn)
(def ^:private clnm-abstract-fn 'tinyclj.lang.AFnMh)
(def ^:private clnm-static-fn 'tinyclj.lang.StaticFn)

(def ^:private MethodHandle ConstantDescs/CD_MethodHandle)
(def ^:private MethodHandleArray (.arrayType MethodHandle))
(def ^:private Lookup ConstantDescs/CD_MethodHandles_Lookup)

(def ^:private Object ConstantDescs/CD_Object)
(def ^:private ObjectArray (.arrayType Object))
(def ^:private Class ConstantDescs/CD_Class)
(def ^:private String ConstantDescs/CD_String)

(def ^:private BootstrapMethod (ClassDesc/of "tinyclj.lang.BootstrapMethod"))
(def StaticFn (ClassDesc/of (name clnm-static-fn)))

(def name-requires "requires~1")

;;; ------------------------------------------------------------------------

(defmacro ^:private mtd [rtype ptypev]
  `(MethodTypeDesc/of ~rtype ~(with-meta ptypev {:tag 'java.util.List})))

(defmacro ^:private mhd-static [[owner name] rtype ptypev]
  `(MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                              ~owner ~name (mtd ~rtype ~ptypev)))

(def bsm-quote (mhd-static [BootstrapMethod "quote"] Object
                           [Lookup String Class ObjectArray]))
(def bsm-static-fn (mhd-static [BootstrapMethod "createStaticFn"] StaticFn
                               [Lookup String Class MethodHandleArray]))

;;; ------------------------------------------------------------------------

(def ^:private clnm-symbol 'clojure.lang.Symbol)
(def ^:private clnm-keyword 'clojure.lang.Keyword)
(def ^:private clnm-vector 'clojure.lang.IPersistentVector)
(def ^:private clnm-map 'clojure.lang.IPersistentMap)
(def ^:private clnm-set 'clojure.lang.IPersistentSet)
(def ^:private clnm-list 'clojure.lang.IPersistentList)
(def ^:private clnm-seq 'clojure.lang.ISeq)
(def ^:private clnm-iobj 'clojure.lang.IObj)

(def symbol (ClassDesc/of (name clnm-symbol)))
(def keyword (ClassDesc/of (name clnm-keyword)))
(def vector (ClassDesc/of (name clnm-vector)))
(def map (ClassDesc/of (name clnm-map)))
(def set (ClassDesc/of (name clnm-set)))
(def list (ClassDesc/of (name clnm-list)))
(def ^:private seq (ClassDesc/of (name clnm-seq)))
(def pattern (ClassDesc/of "java.util.regex.Pattern"))
(def ^:private iobj (ClassDesc/of (name clnm-iobj)))

;;; used for coll-literal implementation (e.g. as part of compile-quote):
(def ^:private Literal (ClassDesc/of "tinyclj.lang.Literal"))
(def mhd-with-meta (mhd-static [Literal "with_meta"] iobj [iobj map]))
(def mhd-vector (mhd-static [Literal "vector"] vector [ObjectArray]))
(def mhd-map (mhd-static [Literal "map"] map [ObjectArray]))
(def mhd-set (mhd-static [Literal "set"] set [ObjectArray]))
(def mhd-list (mhd-static [Literal "list"] list [ObjectArray]))
