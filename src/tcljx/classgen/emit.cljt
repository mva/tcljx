(ns tcljx.classgen.emit
  (:require
   (tcljx.data [config :as cfg] [type :as type] [model :as model]
               [reflect :as reflect])
   (tcljx.classgen [classfile :as classfile]))
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.model CodeEmitter)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant MethodTypeDesc ConstantDesc ConstantDescs)))

(defn line-number ^CodeBuilder [^CodeBuilder xb ^int line]
  ;; Note: Writing only line number of zero triggers output of an
  ;; empty "LineNumberTable" attribute.  Probably pointless to
  ;; suppress this special case.  FIXME... set this to
  ;; CodeBuilder/.lineNumber
  (cond-> xb (not= line cfg/no-line-number) (.lineNumber line)))

(letfn [(return-from-method? ^boolean [^CodeBuilder xb ^Class on-stack-type]
          (.return_ xb (TypeKind/from on-stack-type))
          false)

        (pop-operand ^boolean [^CodeBuilder xb ^Class on-stack-type]
          ;; pre: `on-stack-type` is not Void/TYPE
          (if (or (identical? Long/TYPE on-stack-type)
                  (identical? Double/TYPE on-stack-type))
            (-> xb .pop2)
            (-> xb .pop))
          true)

        (unbox-reference ^void [^CodeBuilder xb ^int line
                                ^Class consumed-type ^Class on-stack-type]
          ;; pre: (.isPrimitive consumed-type)
          (let [box-type (.class-reference (type/of consumed-type))
                mtd (MethodTypeDesc/of (reflect/describe-class consumed-type))
                mnm (str (.getSimpleName consumed-type) "Value")]
            (if (type/same? Number on-stack-type) ;not instanceof test!
              ;; type conversion from Number to primitive type
              ;; FIXME... does conversion via Number.xxxValue() make
              ;; RT.longCast(Object) etc. redundant, at least as far
              ;; as tcljx is concerned?
              (-> (line-number xb line)
                  (.invokevirtual ConstantDescs/CD_Number mnm mtd))
              ;; type cast from box type to primitive type
              (do (when-not (type/same? box-type on-stack-type)
                    (cast-from-reference xb line box-type on-stack-type))
                  (-> (line-number xb line)
                      (.invokevirtual (reflect/describe-class box-type) mnm
                                      mtd))))))
        (cast-from-reference ^void [^CodeBuilder xb ^int line
                                    ^Class consumed-type ^Class on-stack-type]
          ;; pre: `on-stack-type` is reference type
          ;; pre: `on-stack-type` is not Void/TYPE
          ;; pre: `consumed-type` is not void
          (cond
            (.isPrimitive consumed-type)
            (unbox-reference xb line consumed-type on-stack-type)

            (.isAssignableFrom consumed-type on-stack-type)
            nil
                
            :else
            (-> (line-number xb line)
                (.checkcast (reflect/describe-class consumed-type)))))

        (box-primitive ^void [^CodeBuilder xb ^Class consumed-type
                              ^Class on-stack-type]
          ;; pre: (.isPrimitive on-stack-type) but it is not void
          (let [box-type (.class-reference (type/of on-stack-type))
                cd-box (reflect/describe-class box-type)
                mtd (MethodTypeDesc/of cd-box
                                       (reflect/describe-class on-stack-type))]
            (.invokestatic xb cd-box "valueOf" mtd)
            ;; there should be no scenario where the additonal cast
            ;; fails, so drop the line number for now
            (cast-from-reference xb cfg/no-line-number consumed-type box-type)))
        (convert-from-primitive ^void [^CodeBuilder xb ^Class consumed-type
                                       ^Class on-stack-type]
          ;; pre: `on-stack-type` is primitive type including void
          ;; pre: `consumed-type` is not void
          (cond
            (.isPrimitive consumed-type)
            (classfile/accept-> xb (.convert-from (type/of consumed-type))
                                (type/of on-stack-type))
            ;; here holds: requested type is reference
                
            (identical? Void/TYPE on-stack-type)
            (-> xb .aconst_null)
                
            :else
            (box-primitive xb consumed-type on-stack-type)))

        ;; Emits instruction to `xb` and adapts the operand stack
        ;; entry it produces to `consumed-type`.  Returns false if
        ;; the instruction is known to return from the current method,
        ;; and true otherwise.  Note: The true case "instruction may
        ;; complete normally" is only an approximation, because this
        ;; is not known with certainty across instances of
        ;; CodeBuilder.block().
        (adapt-stack? ^boolean [^CodeBuilder xb ^int line
                                ^Class consumed-type ^Class on-stack-type]
          (cond
            (nil? on-stack-type)
            false
            
            (identical? on-stack-type consumed-type)
            true
            
            (identical? Void/TYPE consumed-type)
            (pop-operand xb on-stack-type)
            
            ;; here holds: this function leaves an operand on the stack
            :else (do (if (.isPrimitive on-stack-type)
                        (convert-from-primitive xb consumed-type
                                                on-stack-type)
                        (cast-from-reference xb line consumed-type
                                             on-stack-type))
                      true)))

        (emit-number? ^boolean [^CodeBuilder xb ^Class consumed-type
                                ^Number value]
          (.loadConstant xb (type/convert-from-constant consumed-type value))
          true)]
  
  (defn insn? ^boolean [^CodeBuilder xb ^int line ^Class consumed-type
                        ^CodeEmitter ce ^boolean then-leave?]
    (if (or (and (model/ce-const? ce)
                 (let [value (model/ce-const-value ce)]
                   (if (model/null? value)
                     (do (assert (not (.isPrimitive consumed-type)))
                         (.aconst_null xb)
                         true)
                     (and (instance? Number value)
                          (type/monomorphic-primitive? consumed-type)
                          (emit-number? xb consumed-type value)))))
          
            (adapt-stack? xb line consumed-type
                          (.emit-insn* ce xb line consumed-type then-leave?)))
      (if then-leave?
        (return-from-method? xb consumed-type)
        true)
      false)))

(defn insns?
  (^boolean [^CodeBuilder xb ^int line ^Class consumed-type
             ^CodeEmitter/1 ces]
   (insns? xb line consumed-type ces 0 (alength ces)))
  (^boolean [^CodeBuilder xb ^int line ^Class consumed-type
             ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (or (>= i end)
         (and (insn? xb line consumed-type (aget ces i) false)
              (recur (inc i)))))))

(defn typed-insns?
  (^boolean [^CodeBuilder xb ^int line ^Class/1 consumed-types
             ^CodeEmitter/1 ces]
   (typed-insns? xb line consumed-types ces 0 (alength consumed-types)))
  (^boolean [^CodeBuilder xb ^int line ^Class/1 consumed-types
             ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (or (>= i end)
         (and (insn? xb line (aget consumed-types i) (aget ces i) false)
              (recur (inc i)))))))
