(ns tcljx.classgen.emit
  (:require
   (tcljx.data [config :as cfg] [context :as context] [type :as type]
               [model :as model] [reflect :as reflect])
   (tcljx.classgen [classfile :as classfile]))
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.model CodeEmitter Entity LoadFromCopyWhenBound Invocable)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind)
   (java.lang.constant MethodTypeDesc ConstantDesc ClassDesc ConstantDescs)
   (java.util ArrayList HashMap)
   (java.util.concurrent ConcurrentHashMap)
   (java.util.function Consumer Function BiFunction)))

(deftype OtherClass [^ClassDesc this-class ^int flags ^ClassDesc super-class
                     ^Consumer class-handler])
(deftype SegmentAcc [^ArrayList segment-elements ;of Consumer
                     ^ArrayList clinit-statms    ;of CodeEmitter
                     ^ArrayList other-classes]   ;of OtherClass
  java.lang.Record)

(defn add-segment-elements ^SegmentAcc [^SegmentAcc acc ^Consumer class-handler]
  (.add (.segment-elements acc) class-handler)
  acc)
(defn add-clinit-statm ^SegmentAcc [^SegmentAcc acc ^CodeEmitter emitter]
  (.add (.clinit-statms acc) emitter)
  acc)
(defn add-class-file ^SegmentAcc [^SegmentAcc acc ^ClassDesc this-class
                                  ^int flags ^ClassDesc super-class
                                  ^Consumer class-handler]
  (.add (.other-classes acc)
        (OtherClass. this-class flags super-class class-handler))
  acc)


;;; ------------------------------------------------------------------------

;;; Line numbers are written to enable accurate stack traces.  Any
;;; instruction that may cause a stack trace (in other words: that may
;;; raise an exception) should have a line number, as well as any
;;; instruction that appears as an ancestor stack trace element (that
;;; is, almost every invoke instruction).
;;;
;;; The form context `fctx` of an instruction of interest refers to
;;; the Clojure list form from which it was compiled.  Its line number
;;; is taken from the opening parenthesis of the list.  Type adaption
;;; instructions take a `consumer-fctx`, which refers to the *parent*
;;; expression that consumes the adapted value, *not* the `fctx` of
;;; the on stack value being adapted.
(defn with-line-number ^CodeBuilder [^CodeBuilder xb ^long fctx]
  ;; Note: Writing only line number of zero triggers output of an
  ;; empty "LineNumberTable" attribute.  For example invocations of
  ;; runtime methods are emitted without any line number.
  (let [line (context/fctx-line fctx)]
    (cond-> xb (pos? line) (.lineNumber (context/fctx-line fctx)))))

;;; Do not push a reference as "consumed type" into a code emitter
;;; that natively produces a primitive value.  The emitter must
;;; materialize the primitive to trigger any NPE, before the known to
;;; be non-nil consumed value is produced.
(defn with-adaption-barrier ^CodeEmitter [^Class produced-type ^CodeEmitter ce]
  (^CodeEmitter fn [xb consumed-type then-leave?]
   (if (or (identical? Void/TYPE consumed-type)
           (identical? produced-type consumed-type)
           (= (.isPrimitive produced-type) (.isPrimitive consumed-type)))
     (.emit-insn* ce xb consumed-type then-leave?)
     (.emit-insn* ce xb produced-type false))))

(letfn [(pop-operand ^void [^CodeBuilder xb ^Class on-stack-type]
          ;; pre: `on-stack-type` is not Void/TYPE
          (if (or (identical? Long/TYPE on-stack-type)
                  (identical? Double/TYPE on-stack-type))
            (-> xb .pop2)
            (-> xb .pop)))
        
        (unbox-reference ^void [^CodeBuilder xb ^long consumer-fctx
                                ^Class consumed-type ^Class on-stack-type]
          ;; pre: (.isPrimitive consumed-type)
          (let [box-type (.class-reference (type/of consumed-type))
                mtd (MethodTypeDesc/of (reflect/describe-class consumed-type))
                mnm (str (.getSimpleName consumed-type) "Value")]
            (if (type/same? Number on-stack-type) ;not instanceof test!
              ;; type conversion from Number to primitive type
              ;; FIXME... does conversion via Number.xxxValue() make
              ;; RT.longCast(Object) etc. redundant, at least as far
              ;; as tcljx is concerned?
              (-> (with-line-number xb consumer-fctx)
                  (.invokevirtual ConstantDescs/CD_Number mnm mtd))
              ;; type cast from box type to primitive type
              (do (when-not (type/same? box-type on-stack-type)
                    (cast-from-reference* xb consumer-fctx
                                          box-type on-stack-type))
                  (-> (with-line-number xb consumer-fctx)
                      (.invokevirtual (reflect/describe-class box-type) mnm
                                      mtd))))))
        (cast-from-reference* ^void [^CodeBuilder xb ^long consumer-fctx
                                     ^Class consumed-type ^Class on-stack-type]
          ;; pre: `on-stack-type` is reference type
          ;; pre: `on-stack-type` is not Void/TYPE
          ;; pre: `consumed-type` is not void
          (cond
            (.isPrimitive consumed-type)
            (unbox-reference xb consumer-fctx consumed-type on-stack-type)

            (.isAssignableFrom consumed-type on-stack-type)
            nil
                
            :else
            (-> (with-line-number xb consumer-fctx)
                (.checkcast (reflect/describe-class consumed-type)))))

        (box-primitive ^void [^CodeBuilder xb ^Class consumed-type
                              ^Class on-stack-type]
          ;; pre: (.isPrimitive on-stack-type) but it is not void
          (let [box-type (.class-reference (type/of on-stack-type))
                cd-box (reflect/describe-class box-type)
                mtd (MethodTypeDesc/of cd-box
                                       (reflect/describe-class on-stack-type))]
            (.invokestatic xb cd-box "valueOf" mtd)
            ;; there should be no scenario where the additonal cast
            ;; fails, so drop the line number for now
            (cast-from-reference* xb cfg/no-line-number consumed-type box-type)))

        (convert-from-primitive* ^void [^CodeBuilder xb ^Class consumed-type
                                        ^Class on-stack-type]
          ;; pre: (not (identical? consumed-type on-stack-type))
          ;; pre: `on-stack-type` is primitive type including void
          ;; pre: `consumed-type` is not void
          (cond
            (.isPrimitive consumed-type)
            (type/primitive-convert-from xb (type/of consumed-type)
                                         (type/of on-stack-type))
            ;; here holds: requested type is reference
                
            (identical? Void/TYPE on-stack-type)
            (-> xb .aconst_null)
                
            :else
            (box-primitive xb consumed-type on-stack-type)))]

  (defn convert-from-primitive ^void [^CodeBuilder xb ^Class consumed-type
                                      ^Class on-stack-type]
    (when-not (identical? consumed-type on-stack-type)
      (convert-from-primitive* xb consumed-type on-stack-type)))

  ;; Emits instructions that adapt the top operand stack entry from
  ;; `on-stack-type` to `consumed-type`.
  (defn adapt-stack ^void [^CodeBuilder xb ^long consumer-fctx
                           ^Class consumed-type ^Class on-stack-type]
    ;; pre: (some? on-stack-type)
    (when-not (identical? on-stack-type consumed-type)
      (cond
        (identical? Void/TYPE consumed-type)
        (pop-operand xb on-stack-type)
        ;; here holds: this function leaves an operand on the stack
        
        (.isPrimitive on-stack-type)
        (convert-from-primitive* xb consumed-type on-stack-type)
        
        :else
        (cast-from-reference* xb consumer-fctx consumed-type on-stack-type))))

  (defn statm? ^boolean [^CodeBuilder xb ^CodeEmitter ce]
    (when-some [on-stack-type (.emit-insn* ce xb Void/TYPE false)]
      (when-not (identical? Void/TYPE on-stack-type)
        (pop-operand xb on-stack-type))
      true))
  
  ;; FIXME... move argument `ce` to second position?
  (defn insn? ^boolean [^CodeBuilder xb ^long consumer-fctx
                        ^Class consumed-type ^CodeEmitter ce]
    (when-some [on-stack-type (.emit-insn* ce xb consumed-type false)]
      (adapt-stack xb (context/fctx-line consumer-fctx) consumed-type
                   on-stack-type)
      true))
  
  ;; FIXME... move argument `ce` to second position?
  (defn then-leave? ^boolean [^CodeBuilder xb ^long consumer-fctx
                              ^Class consumed-type ^CodeEmitter ce
                              ^boolean then-leave?]
    (if then-leave?
      (do (when-some [on-stack-type (.emit-insn* ce xb consumed-type true)]
            (adapt-stack xb (context/fctx-line consumer-fctx) consumed-type
                         on-stack-type)
            (.return_ xb (TypeKind/from consumed-type)))
          false)
      (insn? xb consumer-fctx consumed-type ce))))

(defn statms? ^boolean [^CodeBuilder xb ^CodeEmitter/1 ces]
  (loop [i 0]
    (or (>= i (alength ces)) (and (statm? xb (aget ces i)) (recur (inc i))))))

(defn insns?
  (^boolean [^CodeBuilder xb ^long consumer-fctx ^Class consumed-type
             ^CodeEmitter/1 ces]
   (insns? xb consumer-fctx consumed-type ces 0 (alength ces)))
  (^boolean [^CodeBuilder xb ^long consumer-fctx ^Class consumed-type
             ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (or (>= i end)
         (and (insn? xb consumer-fctx consumed-type (aget ces i))
              (recur (inc i)))))))

(defn typed-insns?
  (^boolean [^CodeBuilder xb ^long consumer-fctx ^Class/1 consumed-types
             ^CodeEmitter/1 ces]
   (typed-insns? xb consumer-fctx consumed-types ces
                 0 (alength consumed-types)))
  (^boolean [^CodeBuilder xb ^long consumer-fctx ^Class/1 consumed-types
             ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (or (>= i end)
         (and (insn? xb consumer-fctx (aget consumed-types i) (aget ces i))
              (recur (inc i)))))))

(defn entities? ^boolean [^CodeBuilder xb ^Entity/1 ces]
  (dotimes [i (alength ces)]
    (let [ent (aget ces i)]
      (.emit-insn* ent xb (.value-type ent) false)))
  true)

;;; ------------------------------------------------------------------------

(def ^:private ZERO (object 0))

;; Generates unique names for fn* and reify* instances within a given
;; namespace.  In case of name clashes the result is not
;; deterministic, unless all of the namespace's processing happens
;; within a single thread.
(defn- pick-unique-name ^String [^ConcurrentHashMap private-name-map
                                 ^String dflt-nm]
  (let [n ^int (.compute private-name-map dflt-nm
                         (^BiFunction fn ^Integer [_ ^Integer v]
                          (if (nil? v) ZERO (object (inc ^int v)))))]
    (cond-> dflt-nm (pos? n) (str "^" n))))



;;; A Blueprint acts as a buffer between the information gathering
;;; phase of parsing and the build step that emits the class files.
;;; It encapsulates mutable state and all updates are initiated from a
;;; single thread.  Blueprints can be nested, for example to capture
;;; information about a given closure's environment.

(definterface IClosureBlueprint
  (scope-name ^String [])
  (closure-level ^int [])
  (next-entity-id ^int []))

(deftype ClosureBlueprint [^ClassDesc segment-class ^ArrayList tasks
                           ^ConcurrentHashMap private-name-map
                           ^String scope-name ^HashMap origin-to-proxy
                           ^Entity this-fn-proxy
                           ^:unsynchronized-mutable ^int curr-entity-id]
  IClosureBlueprint
  (scope-name [_]
    scope-name)
  (closure-level [_]
    (unsigned-bit-shift-right curr-entity-id 16))
  (next-entity-id [_]
    (set! curr-entity-id (inc curr-entity-id))))

(defn size-staged ^int [^ClosureBlueprint cbp]
  (.size (.tasks cbp)))
(defn stage-task! [^ClosureBlueprint cbp task]
  ;; clinit task: one of PreparationTask, CodeBearingFragment, or CodeEmitter
  ;; non-clinit task: CodeBearingFragment
  (.add (.tasks cbp) task))

(definterface IEmitProxy
  :extends [Invocable]
  (set-emit-entity! ^void [^Entity ent])
  (get-emit-entity ^Entity []))

(defn value-type-exact ^ClassDesc [^CodeEmitter ce ^Class or-else]
  (if (instance? Entity ce)
     (.value-type-exact ^Entity ce)
     (reflect/describe-class or-else)))

;;; Local copy of a value taken from the entity `origin`, where
;;; `origin` is defined by a parent of the current function (or reify,
;;; or interface function).
(deftype EnvProxy [^Entity origin ^int local-entity-id ^String local-name
                   ^:unsynchronized-mutable ^Entity __emit-entity]
  CodeEmitter
  (emit-insn* [_ xb consumed-type then-leave?]
    (.emit-insn* __emit-entity xb consumed-type then-leave?))
  Entity
  (value-type [_]
    (.value-type origin))
  (entity-id [_]
    local-entity-id)
  Invocable
  (invoke* [this fctx form opt-f xs]
    (.invoke* ^Invocable origin fctx form this xs))
  IEmitProxy
  (set-emit-entity! [_ ent]
    (set! __emit-entity ent))
  (get-emit-entity [_]
    __emit-entity))

(def ^:private this-fn-reference ;FIXME... is this only a temporary workaround?
  (reify Entity
    (emit-insn* [_ xb _ _]
      (.aload xb (.receiverSlot xb))
      tinyclj.lang.AFnMh)))

(defn add-env-proxy! ^Entity [^ClosureBlueprint cbp ^Entity origin
                              ^String local-name]
  #_(prn :closure-level (model/closure-level ent)
         :sequence-number (model/sequence-number ent)
         :using-scope (.scope-name cbp))
  (.computeIfAbsent (.origin-to-proxy cbp) origin
                    (^Function fn [origin]
                     (EnvProxy. origin (.next-entity-id cbp) local-name nil))))

(defn- closes-over? ^boolean [^ClosureBlueprint cbp ^Entity ent]
  (let [origin (model/closure-level ent)]
    (and (>= origin model/closure-level-clinit)
         (not= origin (.closure-level cbp)))))

(defn value-of ^Entity [^ClosureBlueprint cbp ^Entity ent ^Object form]
  #_(prn :cbp-level (.closure-level cbp)
         :ent-level (model/closure-level ent)
         :sequence-number (model/sequence-number ent)
         :using-scope (.scope-name cbp)
         :form form
         :ent-class (class ent)
         :closes-over? (closes-over? cbp ent))
  (if (closes-over? cbp ent)
    (add-env-proxy! cbp ent (name ^symbol form))
    ent))

(defn invocation-of ^Entity [^ClosureBlueprint cbp ^Entity inv ^seq form]
  (if (closes-over? cbp inv)
    (if (identical? (.this-fn-proxy cbp) inv)
      this-fn-reference      ;invocation of fn from one of its arities
      (add-env-proxy! cbp inv (name ^symbol (first form))))
    inv))


(defn mk-segment-clinit ^ClosureBlueprint [^ClassDesc this-class]
  (let [initial-entity-id (model/entity-id-of model/closure-level-clinit)]
    (ClosureBlueprint. this-class (ArrayList.) (ConcurrentHashMap.)
                       nil nil nil initial-entity-id)))

(letfn [(closure ^ClosureBlueprint [^ClosureBlueprint parent
                                    ^String unique-nm ^Entity this-fn-proxy]
          (let [nested-tasks (ArrayList.)
                level' (if (some? unique-nm)
                         (inc (.closure-level parent))
                         model/closure-level-clinit)]
            (ClosureBlueprint. (.segment-class parent) nested-tasks
                               (.private-name-map parent) unique-nm
                               (HashMap.) this-fn-proxy
                               (model/entity-id-of level'))))]
  
  (defn mk-closures ^ClosureBlueprint/1 [^ClosureBlueprint parent 
                                         ^String scope-name-suffix
                                         ^Entity this-fn-proxy ^int n]
    (let [parent-name (.scope-name parent)
          nm-str (cond->> scope-name-suffix
                   (some? parent-name) (str parent-name "$"))
          unique-nm (pick-unique-name (.private-name-map parent) nm-str)
          a (new ClosureBlueprint/1 n)]
      (dotimes [i (alength a)]
        (aset a i (closure parent unique-nm this-fn-proxy)))
      a)))

