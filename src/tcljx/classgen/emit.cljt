(ns tcljx.classgen.emit
  (:require
   (tcljx.data [config :as cfg] [type :as type] [model :as model]
               [reflect :as reflect])
   (tcljx.classgen [classfile :as classfile]))
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.model CodeEmitter)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant MethodTypeDesc ConstantDesc ConstantDescs)))

(defn line-number ^CodeBuilder [^CodeBuilder xb ^int line]
  ;; Note: Writing only line number of zero triggers output of an
  ;; empty "LineNumberTable" attribute.  Probably pointless to
  ;; suppress this special case.  FIXME... set this to
  ;; CodeBuilder/.lineNumber
  (cond-> xb (not= line cfg/no-line-number) (.lineNumber line)))

(letfn [(pop-operand ^void [^CodeBuilder xb ^Class on-stack-type]
          ;; pre: `on-stack-type` is not Void/TYPE
          (if (or (identical? Long/TYPE on-stack-type)
                  (identical? Double/TYPE on-stack-type))
            (-> xb .pop2)
            (-> xb .pop)))
        
        (unbox-reference ^void [^CodeBuilder xb ^int line
                                ^Class consumed-type ^Class on-stack-type]
          ;; pre: (.isPrimitive consumed-type)
          (let [box-type (.class-reference (type/of consumed-type))
                mtd (MethodTypeDesc/of (reflect/describe-class consumed-type))
                mnm (str (.getSimpleName consumed-type) "Value")]
            (if (type/same? Number on-stack-type) ;not instanceof test!
              ;; type conversion from Number to primitive type
              ;; FIXME... does conversion via Number.xxxValue() make
              ;; RT.longCast(Object) etc. redundant, at least as far
              ;; as tcljx is concerned?
              (-> (line-number xb line)
                  (.invokevirtual ConstantDescs/CD_Number mnm mtd))
              ;; type cast from box type to primitive type
              (do (when-not (type/same? box-type on-stack-type)
                    (cast-from-reference* xb line box-type on-stack-type))
                  (-> (line-number xb line)
                      (.invokevirtual (reflect/describe-class box-type) mnm
                                      mtd))))))
        (cast-from-reference* ^void [^CodeBuilder xb ^int line
                                     ^Class consumed-type ^Class on-stack-type]
          ;; pre: `on-stack-type` is reference type
          ;; pre: `on-stack-type` is not Void/TYPE
          ;; pre: `consumed-type` is not void
          (cond
            (.isPrimitive consumed-type)
            (unbox-reference xb line consumed-type on-stack-type)

            (.isAssignableFrom consumed-type on-stack-type)
            nil
                
            :else
            (-> (line-number xb line)
                (.checkcast (reflect/describe-class consumed-type)))))

        (box-primitive ^void [^CodeBuilder xb ^Class consumed-type
                              ^Class on-stack-type]
          ;; pre: (.isPrimitive on-stack-type) but it is not void
          (let [box-type (.class-reference (type/of on-stack-type))
                cd-box (reflect/describe-class box-type)
                mtd (MethodTypeDesc/of cd-box
                                       (reflect/describe-class on-stack-type))]
            (.invokestatic xb cd-box "valueOf" mtd)
            ;; there should be no scenario where the additonal cast
            ;; fails, so drop the line number for now
            (cast-from-reference* xb cfg/no-line-number consumed-type box-type)))

        (convert-from-primitive* ^void [^CodeBuilder xb ^Class consumed-type
                                        ^Class on-stack-type]
          ;; pre: (not (identical? consumed-type on-stack-type))
          ;; pre: `on-stack-type` is primitive type including void
          ;; pre: `consumed-type` is not void
          (cond
            (.isPrimitive consumed-type)
            (type/primitive-convert-from xb (type/of consumed-type)
                                         (type/of on-stack-type))
            ;; here holds: requested type is reference
                
            (identical? Void/TYPE on-stack-type)
            (-> xb .aconst_null)
                
            :else
            (box-primitive xb consumed-type on-stack-type)))]

  (defn convert-from-primitive ^void [^CodeBuilder xb ^Class consumed-type
                                      ^Class on-stack-type]
    (when-not (identical? consumed-type on-stack-type)
      (convert-from-primitive* xb consumed-type on-stack-type)))

  (defn cast-from-reference ^void [^CodeBuilder xb ^int line
                                   ^Class consumed-type ^Class on-stack-type]
    (when-not (identical? consumed-type on-stack-type)
      (cast-from-reference* xb line consumed-type on-stack-type)))
  
  ;; Emits instructions that adapt the top operand stack entry from
  ;; `on-stack-type` to `consumed-type`.
  (defn adapt-stack ^void [^CodeBuilder xb ^int line
                           ^Class consumed-type ^Class on-stack-type]
    ;; pre: (some? on-stack-type)
    (when-not (identical? on-stack-type consumed-type)
      (cond
        (identical? Void/TYPE consumed-type)
        (pop-operand xb on-stack-type)
        ;; here holds: this function leaves an operand on the stack
        
        (.isPrimitive on-stack-type)
        (convert-from-primitive* xb consumed-type on-stack-type)
        
        :else
        (cast-from-reference* xb line consumed-type on-stack-type))))

  (defn insn? ^boolean [^CodeBuilder xb ^int line ^Class consumed-type
                        ^CodeEmitter ce]
    (if-some [on-stack-type (.emit-insn* ce xb line consumed-type false)]
      (do (adapt-stack xb line consumed-type on-stack-type)
          true)
      false))
  
  (defn then-leave? ^boolean [^CodeBuilder xb ^int line ^Class consumed-type
                              ^CodeEmitter ce ^boolean then-leave?]
    (if then-leave?
      (do (when-some [on-stack-type (.emit-insn* ce xb line consumed-type true)]
            (adapt-stack xb line consumed-type on-stack-type)
            (.return_ xb (TypeKind/from consumed-type)))
          false)
      (insn? xb line consumed-type ce))))

(defn insns?
  (^boolean [^CodeBuilder xb ^int line ^Class consumed-type
             ^CodeEmitter/1 ces]
   (insns? xb line consumed-type ces 0 (alength ces)))
  (^boolean [^CodeBuilder xb ^int line ^Class consumed-type
             ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (or (>= i end)
         (and (insn? xb line consumed-type (aget ces i))
              (recur (inc i)))))))

(defn typed-insns?
  (^boolean [^CodeBuilder xb ^int line ^Class/1 consumed-types
             ^CodeEmitter/1 ces]
   (typed-insns? xb line consumed-types ces 0 (alength consumed-types)))
  (^boolean [^CodeBuilder xb ^int line ^Class/1 consumed-types
             ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (or (>= i end)
         (and (insn? xb line (aget consumed-types i) (aget ces i))
              (recur (inc i)))))))
