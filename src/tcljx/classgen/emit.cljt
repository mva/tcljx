(ns tcljx.classgen.emit
  (:require
   (tcljx.data [config :as cfg] [type :as type] [model :as model]
               [reflect :as reflect])
   (tcljx.classgen [classfile :as classfile]))
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.model CodeEmitter)
   (java.lang.classfile CodeBuilder TypeKind)))

(defn- adapt-to ^void [^CodeBuilder xb ^int line
                       ^Class opnd-type ^Class requested-type]
  (assert (type/continues? opnd-type))      ;FIXME... drop
  (assert (type/continues? requested-type)) ;FIXME... drop
  
  (letfn [(indirect-unbox ^void [^Wrapper wopnd ^Wrapper wrequested]
            ;; pre: `wopnd` denotes a reference type
            ;; pre: `wrequested` denotes a non-void primitive type
            (let [box-type (.class-reference wrequested)]
              #_(prn :wopnd wopnd :wrequested wrequested)
              (adapt-to xb line opnd-type box-type)
              (classfile/accept-> xb (.convert-from wrequested)
                                  (type/of box-type))))]
    (cond
      (.isAssignableFrom requested-type opnd-type)
      nil

      (not (or (.isPrimitive opnd-type) (.isPrimitive requested-type)))
      (-> (.lineNumber xb line)
          (.checkcast (reflect/describe-class requested-type)))
      
      :else (let [wopnd (type/of opnd-type)
                  wrequested (type/of requested-type)]
              #_(prn :wopnd wopnd)
              #_(prn :wrequested wrequested)
              (if (and (not (type/same? Void/TYPE requested-type))
                       (.isPrimitive requested-type)
                       (not (.isPrimitive opnd-type)))
                (indirect-unbox wopnd wrequested)
                (classfile/accept-> xb (.convert-from wrequested) wopnd))))))

;;; Emit instruction to `xb` and adapt the stack operand it produces
;;; to `requested-type`.  Returns nil if the instruction returns
;;; control to the invoking method, and `xb` if execution continues in
;;; this method.
(defn opnd ^CodeBuilder [^CodeBuilder xb ^int line ^Class requested-type
                         ^CodeEmitter ce]
  ;; pre: (some? xb)
  (let [on-stack-type (.emit-opnd* ce xb line requested-type)]
    (cond
      (and (type/poly-reference? on-stack-type) ;Void is on the stack
           (not (.isPrimitive requested-type)) ;a reference type is requested
           (model/const-null? ce))      ;ACONST_NULL was just emitted
      xb   ;elide redundant checkcast of ACONST_NULL to reference type

      (type/exits-method? on-stack-type)
      nil       ;instruction does not return: cannot continue at all
      
      ;; FIXME... optimize for this "nothing to do" case?  it should be
      ;; the most common scenario.  handle this in the caller of this
      ;; function?
      (identical? on-stack-type requested-type)
      (when (type/continues? on-stack-type) xb)
      
      (type/exits-method? requested-type)
      (do (.return_ xb (TypeKind/from on-stack-type)) nil)

      :else (do (adapt-to xb line on-stack-type requested-type) xb))))
(defn method-return ^CodeBuilder [^CodeBuilder xb ^CodeEmitter ce]
  (opnd xb cfg/no-line-number type/exits-method ce))

(defn opnds-of-type ^CodeBuilder [^CodeBuilder xb ^int line
                                   ^Class requested-type ^CodeEmitter/1 ces]
  (let [end (dec (alength ces))]
    (loop [i 0]
      (let [ce (aget ces i)]
        (if (< i end)
          (when (opnd xb line Void/TYPE ce)
            (recur (inc i)))
          (opnd xb line requested-type ce))))))

(defn typed-opnds
  (^CodeBuilder [^CodeBuilder xb ^int line ^Class/1 requested-types
                 ^CodeEmitter/1 ces]
   (typed-opnds xb line requested-types ces 0 (alength requested-types)))
  (^CodeBuilder [^CodeBuilder xb ^int line ^Class/1 requested-types
                 ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (if (< i end)
       (when (opnd xb line (aget requested-types i) (aget ces i))
         (recur (inc i)))
       xb))))
