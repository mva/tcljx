(ns tcljx.classgen.emit
  (:require
   (tcljx.data [config :as cfg] [type :as type] [model :as model]
               [reflect :as reflect])
   (tcljx.classgen [classfile :as classfile]))
  (:import
   (tcljx.data.type Wrapper)
   (tcljx.data.model CodeEmitter)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant MethodTypeDesc)))

;;; Emit instruction to `xb` and adapt the stack operand it produces
;;; to `requested-type`.  Returns nil if the instruction returns
;;; control to the invoking method, and `xb` if execution continues in
;;; this method.
(defn opnd ^CodeBuilder [^CodeBuilder xb ^int line ^Class requested-type
                         ^CodeEmitter ce]
  (letfn [(return-from-method ^CodeBuilder [^CodeBuilder xb ^Class opnd-type]
            (.return_ xb (TypeKind/from opnd-type))
            nil)
          (pop-operand ^CodeBuilder [^CodeBuilder xb ^Class opnd-type]
            ;; pre: `opnd-type` is not Void/TYPE
            (if (or (identical? Long/TYPE opnd-type)
                    (identical? Double/TYPE opnd-type))
              (-> xb .pop2)
              (-> xb .pop)))
          
          (unbox-reference ^CodeBuilder [^CodeBuilder xb
                                         ^Class requested-type
                                         ^Class opnd-type]
            ;; pre: (.isPrimitive requested-type)
            (let [box-type (.class-reference (type/of requested-type))
                  mtd (MethodTypeDesc/of (reflect/describe-class requested-type))]
              (-> (cast-from-reference xb box-type opnd-type)
                  (.lineNumber line)
                  (.invokevirtual (reflect/describe-class box-type)
                                  (str (.getSimpleName requested-type) "Value")
                                  mtd))))
          (cast-from-reference ^CodeBuilder [^CodeBuilder xb
                                             ^Class requested-type
                                             ^Class opnd-type]
            ;; pre: `opnd-type` is reference type
            ;; pre: `opnd-type` is not Void/TYPE
            ;; pre: `requested-type` is not void
            (cond
              (.isPrimitive requested-type)
              (unbox-reference xb requested-type opnd-type)

              (or (.isAssignableFrom requested-type opnd-type)
                  (model/const-null? ce))
              xb
              
              :else (-> (.lineNumber xb line)
                        (.checkcast (reflect/describe-class requested-type)))))

          (box-primitive ^CodeBuilder [^CodeBuilder xb
                                       ^Class requested-type
                                       ^Class opnd-type]
            ;; pre: (.isPrimitive opnd-type) but it is not void
            (let [box-type (.class-reference (type/of opnd-type))
                  cd-box (reflect/describe-class box-type)
                  mtd (MethodTypeDesc/of cd-box (reflect/describe-class opnd-type))]
              (-> (.invokestatic xb cd-box "valueOf" mtd)
                  (cast-from-reference requested-type box-type))))
          (convert-from-primitive ^CodeBuilder [^CodeBuilder xb
                                                ^Class requested-type
                                                ^Class opnd-type]
            ;; pre: `opnd-type` is primitive type including void
            ;; pre: `requested-type` is not void
            (cond
              (.isPrimitive requested-type)
              (classfile/accept-> xb (.convert-from (type/of requested-type))
                                  (type/of opnd-type))
              ;; here holds: requested type is reference
              
              (identical? Void/TYPE opnd-type)
              (-> xb .aconst_null)
              
              :else
              (box-primitive xb requested-type opnd-type)))]
    
    ;; pre: (some? xb)
    (when-some [on-stack-type (.emit-opnd* ce xb line requested-type)]
      ;; here holds: (not (type/exits-method? on-stack-type))
      (cond
        (identical? on-stack-type requested-type)
        xb      ;here holds: (not (type/exits-method? requested-type))
        
        (type/exits-method? requested-type)
        (return-from-method xb on-stack-type)

        (identical? Void/TYPE requested-type)
        (pop-operand xb on-stack-type) ;here `on-stack-type` is not void
        ;; here holds: this function leaves an operand on the stack

        (.isPrimitive on-stack-type)
        (convert-from-primitive xb requested-type on-stack-type)
        
        :else (cast-from-reference xb requested-type on-stack-type)))))
(defn method-return ^CodeBuilder [^CodeBuilder xb ^CodeEmitter ce]
  (opnd xb cfg/no-line-number type/exits-method ce))

(defn opnds-of-type ^CodeBuilder [^CodeBuilder xb ^int line
                                   ^Class requested-type ^CodeEmitter/1 ces]
  (let [end (dec (alength ces))]
    (loop [i 0]
      (let [ce (aget ces i)]
        (if (< i end)
          (when (opnd xb line Void/TYPE ce)
            (recur (inc i)))
          (opnd xb line requested-type ce))))))

(defn typed-opnds
  (^CodeBuilder [^CodeBuilder xb ^int line ^Class/1 requested-types
                 ^CodeEmitter/1 ces]
   (typed-opnds xb line requested-types ces 0 (alength requested-types)))
  (^CodeBuilder [^CodeBuilder xb ^int line ^Class/1 requested-types
                 ^CodeEmitter/1 ces ^int start ^int end]
   (loop [i start]
     (if (< i end)
       (when (opnd xb line (aget requested-types i) (aget ces i))
         (recur (inc i)))
       xb))))
