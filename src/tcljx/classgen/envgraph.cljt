(ns tcljx.classgen.envgraph
  (:require (tcljx.data [config :as cfg] [ir :as ir] [code :as code]))
  (:import (tcljx.data.ir CodeEmitter Entity FnUsage EntityFactory
                          MethodSpec FieldSpec)
           (java.lang.constant ClassDesc)
           (java.util HashMap Map$Entry)))

(definterface IDisplay
  (set-emit-entity! ^void [^Entity ent]))

;;; Local copy of a value taken from the entity `origin`, where
;;; `origin` is defined by a parent of the current function (or reify,
;;; or interface function).
(deftype Display [^Entity origin ^int local-entity-id ^String local-name
                  ^:unsynchronized-mutable ^Entity __emit]
  CodeEmitter
  (emit-insn* [_ xb consumed-type then-leave?]
    (.emit-insn* __emit xb consumed-type then-leave?))
  Entity
  (value-type [_]
    (.value-type origin))
  (entity-id [_]
    local-entity-id)
  (invoke* [this fctx form opt-f m-idx xs]
    (.invoke* origin fctx form this m-idx xs))
  IDisplay
  (set-emit-entity! [_ ent]
    (set! __emit ent)))

;;; ------------------------------------------------------------------------

(deftype EnvDisplayPairs [^Entity/1 aorigin, ^Display/1 adisplay])

(letfn [(sort-by-origin ^EnvDisplayPairs [^Entity/1 aorigin ^Display/1 adisplay]
          (let [n (alength aorigin)
                aorigin* (new Entity/1 n)
                adisplay* (new Display/1 n)
                idxs (new long/1 n)]
            (dotimes [i n]
              (aset idxs i (-> (long (.entity-id (aget aorigin i)))
                               (bit-shift-left 16)
                               (bit-or i))))
            (java.util.Arrays/sort idxs)
            (dotimes [i n]
              (let [j (bit-and (int (aget idxs i)) 0xFFFF)]
                (aset aorigin* i (aget aorigin j))
                (aset adisplay* i (aget adisplay j))))
            (EnvDisplayPairs. aorigin* adisplay*)))]
  
  (defn sorted-eds ^EnvDisplayPairs [^HashMap origin-to-display]
    (let [n (.size origin-to-display)
          aorigin (new Entity/1 n)
          adisplay (new Display/1 n)
          it (-> origin-to-display .entrySet .iterator)]
      (loop [i 0]
        (when (.hasNext it)
          (let [entry ^Map$Entry (.next it)]
            (aset aorigin i (.getKey entry))
            (aset adisplay i (.getValue entry))
            (recur (inc i)))))
      (if (<= n 1)
        (EnvDisplayPairs. aorigin adisplay)
        (sort-by-origin aorigin adisplay)))))

(defn value-of ^Entity [^EntityFactory etf ^Entity ent ^symbol form]
  #_(prn :cbp-level (.closure-level em)
         :ent-level (ir/closure-level ent)
         :sequence-number (ir/sequence-number ent)
         :using-scope (.scope-name em)
         :form form
         :ent-class (class ent)
         :closes-over? (closes-over? em ent))
  (if (.closes-over? etf ent)
    (.display-of! etf ent (name form))
    ent))

(defn invocation-of ^Entity [^EntityFactory etf ^Entity inv ^seq form]
  (if (.closes-over? etf inv)
    (.display-of! etf inv (name ^symbol (first form)))
    inv))

(defn fn-closes-over-env? ^boolean [^Entity fn-p ^MethodSpec/1 method-specs]
  (letfn [(some-materialized-display? ^boolean [^MethodSpec spec]
            (let [it (-> spec .env-to-display .keySet .iterator)]
              (loop []
                (when (.hasNext it)
                  (let [origin (.next it)]
                    (cond
                      (identical? origin fn-p) ;fn refers to itself?
                      (recur)
                      (instance? FnUsage origin)
                      (or (FnUsage/.value-use? origin) (recur))
                      :else true))))))]
    (loop [i (dec (alength method-specs))]
      (cond (neg? i) false
            (some-materialized-display? (aget method-specs i)) true
            :else (recur (dec i))))))

(defn merged-env-to-display ^HashMap [^MethodSpec/1 method-specs]
  (let [acc (HashMap.)]
    (loop [i (dec (alength method-specs))]
      (when-not (neg? i)
        (.putAll acc (.env-to-display (aget method-specs i)))
        (recur (dec i))))
    acc))

;;; FIXME... is there a way that different environment values get
;;; assigned the same field name?  when both name and type align, this
;;; would result in an invalid class file (applies to fn* and reify*)
(defn fields-exact ^FieldSpec/1 [^int d ^ClassDesc owner
                                 ^EnvDisplayPairs construction-ops]
  (let [aorigin (.aorigin construction-ops),  adisplay (.adisplay construction-ops)
        a (new FieldSpec/1 (+ (alength aorigin) d))]
    (dotimes [i (alength aorigin)]
      (let [origin (aget aorigin i), display (aget adisplay i)]
        (aset a (+ i d) (FieldSpec. owner (cfg/munge-name (.local-name display))
                                    nil (ir/acc* private final)
                                    (.value-type-exact origin)
                                    (.value-type origin)))))
    a))
(defn- entity-getfield ^Entity [^FieldSpec fs]
  (reify Entity
    (emit-insn* [_ xb _ _] (code/get-field xb fs) (.type fs))
    (value-type [_] (.type fs))
    (value-type-exact [_] (.type-desc fs))
    (entity-id [_] -1)))
(defn field-entity-map ^HashMap [^Entity/1 aorigin ^FieldSpec/1 fields ^int d]
  (let [acc (HashMap.)]
    (dotimes [i (alength aorigin)]
      (.put acc (aget aorigin i) (entity-getfield (aget fields (+ i d)))))
    acc))
