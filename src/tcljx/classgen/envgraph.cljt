(ns tcljx.classgen.envgraph
  (:require (tcljx.data [model :as model]))
  (:import (tcljx.data.model CodeEmitter Entity)
           (java.lang.constant ClassDesc ConstantDescs)
           (java.util ArrayList HashMap Map$Entry)
           (java.util.concurrent ConcurrentHashMap)
           (java.util.function Consumer Function BiFunction)))

(deftype OtherClass [^ClassDesc this-class ^int flags ^ClassDesc super-class
                     ^Consumer class-handler])
(deftype SegmentAcc [^ArrayList segment-elements ;of Consumer
                     ^ArrayList clinit-statms    ;of CodeEmitter
                     ^ArrayList other-classes]   ;of OtherClass
  java.lang.Record)

(defn add-segment-elements ^SegmentAcc [^SegmentAcc acc ^Consumer class-handler]
  (.add (.segment-elements acc) class-handler)
  acc)
(defn add-clinit-statm ^SegmentAcc [^SegmentAcc acc ^CodeEmitter emitter]
  (.add (.clinit-statms acc) emitter)
  acc)
(defn add-class-file ^SegmentAcc [^SegmentAcc acc ^ClassDesc this-class
                                  ^int flags ^ClassDesc super-class
                                  ^Consumer class-handler]
  (.add (.other-classes acc)
        (OtherClass. this-class flags super-class class-handler))
  acc)

;;; ------------------------------------------------------------------------

(definterface IEmitProxy
  :extends [Entity]
  (set-emit-entity! ^void [^Entity ent])
  (get-emit-entity ^Entity []))

;;; Local copy of a value taken from the entity `origin`, where
;;; `origin` is defined by a parent of the current function (or reify,
;;; or interface function).
(deftype EnvProxy [^Entity origin ^int local-entity-id ^String local-name
                   ^:unsynchronized-mutable ^Entity __emit-entity]
  CodeEmitter
  (emit-insn* [_ xb consumed-type then-leave?]
    (.emit-insn* __emit-entity xb consumed-type then-leave?))
  Entity
  (value-type [_]
    (.value-type origin))
  (entity-id [_]
    local-entity-id)
  (invoke* [this fctx form opt-f at-idx xs]
    (.invoke* origin fctx form this at-idx xs))
  IEmitProxy
  (set-emit-entity! [_ ent]
    (set! __emit-entity ent))
  (get-emit-entity [_]
    __emit-entity))

(deftype OriginProxyPairs [^Entity/1 aorigin, ^EnvProxy/1 aproxy])

(defn sorted-ops ^OriginProxyPairs [^HashMap origin-to-proxy]
  (let [n (.size origin-to-proxy)
        aorigin (new Entity/1 n)
        aproxy (new EnvProxy/1 n)
        it (-> origin-to-proxy .entrySet .iterator)]
    (loop [i 0]
      (when (.hasNext it)
        (let [entry ^Map$Entry (.next it)]
          (aset aorigin i (.getKey entry))
          (aset aproxy i (.getValue entry))
          (recur (inc i)))))
    (assert (= n 1))
    (OriginProxyPairs. aorigin aproxy)))

;;; ------------------------------------------------------------------------

(definterface IEnvSegment
  (stage-task! ^void [task])
  (size-staged ^int []))

(deftype EnvSegment [^ConcurrentHashMap private-name-map
                     ^ClassDesc segment-class
                     ^ArrayList tasks
                     ^String pkg-name
                     ^ClassDesc super-class
                     ^int segment-id]
  IEnvSegment
  (stage-task! [_ task]
    (.add tasks task))
  (size-staged [_]
    (.size tasks)))

(letfn [(segment-cld ^ClassDesc [^String pkg-name ^int segm-id]
          (ClassDesc/of pkg-name (str "_" segm-id)))]
  (defn mk-first-segment ^EnvSegment [^String pkg-name]
    (let [segm-id 10]
      (EnvSegment. (ConcurrentHashMap.) (segment-cld pkg-name segm-id)
                   (ArrayList.) pkg-name ConstantDescs/CD_Object segm-id)))
  (defn next-segment ^EnvSegment [^EnvSegment segm]
    (let [pkg-name (-> segm .pkg-name), segm-id (-> segm .segment-id (inc))]
      (EnvSegment. (.private-name-map segm) (segment-cld pkg-name segm-id)
                   (ArrayList.) pkg-name (.segment-class segm) segm-id))))

(defn capstone-class ^ClassDesc [^EnvSegment segm]
  (ClassDesc/of (.pkg-name segm) "___"))

(def ^:private ZERO (object 0))

;; Generates unique names for fn* and reify* instances within a given
;; namespace.  In case of name clashes the result is not
;; deterministic, unless all of the namespace's processing happens
;; within a single thread.
(defn- pick-unique-name ^String [^EnvSegment segm ^String dflt-nm]
  (let [n ^int (.compute (.private-name-map segm) dflt-nm
                         (^BiFunction fn ^Integer [_ ^Integer v]
                          (if (nil? v) ZERO (object (inc ^int v)))))]
    (cond-> dflt-nm (pos? n) (str "^" n))))

;;; ------------------------------------------------------------------------

(definterface IEnvMethod
  (scope-name ^String [])
  (closure-level ^int [])               ;of this class/entity
  (next-entity-id ^int [])
  
  (stage-task! ^void [task])
  (add-env-proxy! ^Entity [^Entity origin ^String local-name]))

;;; An EnvMethod acts as a buffer between the information gathering
;;; phase of parsing and the build step that emits the class files.
;;; It encapsulates mutable state and all updates are initiated from a
;;; single thread.  EnvMethods are usually nested, and capture
;;; information about a given closure's environment.
(deftype EnvMethod [^int method-index   ;within this EnvClass
                    ^:unsynchronized-mutable ^int curr-entity-id
                    ^String class-name  ;if turned into separate class
                    ^EnvMethod parent ;provides this environment's values
                    ^HashMap origin-to-proxy
                    ^String this-name   ;name of any receiver locals
                    ^Entity this-fn-proxy ;to detect self recursive calls
                    ^ArrayList tasks
                    ^EnvSegment segment]
  Object
  (toString [_]
    (str class-name "[" method-index "]"))
  IEnvMethod
  (scope-name [_]
    class-name)
  (closure-level [_]
    (unsigned-bit-shift-right curr-entity-id 16))
  (next-entity-id [_]
    (set! curr-entity-id (inc curr-entity-id)))
  
  (stage-task! [_ task]
    (.add tasks task))
  (add-env-proxy! [this origin local-name]
    #_(prn :closure-level (model/closure-level ent)
           :sequence-number (model/sequence-number ent)
           :using-scope (.scope-name cbp))
    (->> (^Function fn [origin]
          (EnvProxy. origin (.next-entity-id this) local-name nil))
         (.computeIfAbsent origin-to-proxy origin))))

(defn mk-method-clinit ^EnvMethod [^EnvSegment segm]
  (let [initial-entity-id (model/entity-id-of model/closure-level-clinit)]
    (EnvMethod. 0 initial-entity-id nil nil nil nil nil (.tasks segm) segm)))

(def ^:private this-fn-reference ;FIXME... is this only a temporary workaround?
  (reify Entity
    (emit-insn* [_ xb _ _]
      (.aload xb (.receiverSlot xb))
      tinyclj.lang.AFnMh)))

(defn- closes-over? ^boolean [^EnvMethod em ^Entity ent]
  (let [origin (model/closure-level ent)]
    (and (>= origin model/closure-level-clinit)
         (not= origin (.closure-level em)))))

(defn value-of ^Entity [^EnvMethod em ^Entity ent ^Object form]
  #_(prn :cbp-level (.closure-level em)
         :ent-level (model/closure-level ent)
         :sequence-number (model/sequence-number ent)
         :using-scope (.scope-name em)
         :form form
         :ent-class (class ent)
         :closes-over? (closes-over? em ent))
  (if (closes-over? em ent)
    (.add-env-proxy! em ent (name ^symbol form))
    ent))

(defn invocation-of ^Entity [^EnvMethod em ^Entity inv ^seq form]
  (if (closes-over? em inv)
    (if (identical? (.this-fn-proxy em) inv)
      this-fn-reference      ;invocation of fn from one of its arities
      (.add-env-proxy! em inv (name ^symbol (first form))))
    inv))

;;; ------------------------------------------------------------------------

(deftype EnvClass [^Entity fn-proxy
                   ^EnvSegment segment
                   ^String class-name   ;if turned into separate class
                   ^EnvMethod/1 methods])

(defn namespace-class ^ClassDesc [^EnvClass class]
  (ClassDesc/of (-> class .segment .pkg-name) (-> class .class-name)))

(letfn [(method ^EnvMethod [^EnvMethod parent
                            ^String unique-nm ^int method-index
                            ^String this-name ^Entity this-fn-proxy]
          (let [level' (if (some? unique-nm)
                         (inc (.closure-level parent))
                         model/closure-level-clinit)]
            (EnvMethod. method-index (model/entity-id-of level') unique-nm
                        parent (HashMap.) this-name this-fn-proxy (ArrayList.)
                        (.segment parent))))]
  
  (defn mk-methods ^EnvMethod/1 [^EnvMethod parent ^String scope-name-suffix
                                 ^Entity this-fn-proxy ^int n]
    (let [parent-name (.scope-name parent)
          nm-str (cond->> scope-name-suffix
                   (some? parent-name) (str parent-name "$"))
          unique-nm (pick-unique-name (.segment parent) nm-str)
          a (new EnvMethod/1 n)]
      (dotimes [i (alength a)]
        (aset a i (method parent unique-nm i scope-name-suffix this-fn-proxy)))
      a)))

(defn closes-over-env? ^boolean [^EnvClass class]
  (let [ms (.methods class)]
    (loop [i (dec (alength ms))]
      (cond (neg? i) false
            (.isEmpty (.origin-to-proxy (aget ms i))) (recur (dec i))
            :else true))))

(defn class-origin-to-proxy ^HashMap [^EnvClass class]
  (let [methods (.methods class), n (alength methods)]
    (if (= n 1)
      (.origin-to-proxy (aget methods 0))
      (let [acc ^HashMap (.clone (.origin-to-proxy (aget methods (dec n))))]
        (loop [i (- n 2)]
          (when (>= i 0)
            (.putAll acc (.origin-to-proxy (aget methods i)))
            (recur (dec i))))
        acc))))


;;; Can add clinit code, class elements, or whole classes to the
;;; segment under construction.
(definterface PreparationTask
  (extend-segment ^SegmentAcc [^SegmentAcc acc ^EnvClass class]))

(defn run-task ^SegmentAcc [^SegmentAcc acc ^PreparationTask task ^EnvClass class]
  (.extend-segment task acc class))


(deftype EnvGraph [^EnvClass/1 classes])

;;; ------------------------------------------------------------------------

(defn mk-graph ^EnvGraph [^ArrayList tasks ^int tasks-end]
  (let [acc-classes (ArrayList.)]
    (letfn [(add-class! ^void [^EnvMethod parent ^EnvClass class]
              (let [n (alength (.methods class))]
                (dotimes [i n]
                  (let [method (aget (.methods class) i)
                        tasks (.tasks method)]
                    (add-tasks! method tasks (.size tasks))))
                (.add acc-classes class)))
            (add-tasks! ^void [^EnvMethod parent ^ArrayList tasks ^int tasks-end]
              (dotimes [i tasks-end]
                (let [task (.get tasks i)]
                  (when (instance? EnvClass task)
                    (add-class! parent task)))))]
      (add-tasks! nil tasks tasks-end)
      (EnvGraph. (.toArray acc-classes (new EnvClass/1 0))))))
