(ns tcljx.classgen.envgraph
  (:require (tcljx.data [config :as cfg] [model :as model]))
  (:import (tcljx.data.model CodeEmitter Entity Expr NmspClass)
           (java.lang.constant ClassDesc ConstantDescs)
           (java.util ArrayList HashMap Map$Entry)
           (java.util.concurrent ConcurrentHashMap)
           (java.util.function Consumer Function BiFunction)))

(deftype SegmentAcc [^ArrayList segment-elements ;of Consumer
                     ^ArrayList clinit-statms    ;of Expr
                     ^ArrayList other-classes]   ;of NmspClass
  java.lang.Record)

(defn add-segment-elements ^SegmentAcc [^SegmentAcc acc ^Consumer class-handler]
  (.add (.segment-elements acc) class-handler)
  acc)
(defn add-clinit-statm ^SegmentAcc [^SegmentAcc acc ^Expr expr]
  (.add (.clinit-statms acc) expr)
  acc)
(defn add-class-file ^SegmentAcc [^SegmentAcc acc ^NmspClass ncl]
  (.add (.other-classes acc) ncl)
  acc)

;;; ------------------------------------------------------------------------

(definterface IEmitProxy
  :extends [Entity]
  (set-emit-entity! ^void [^Entity ent])
  (get-emit-entity ^Entity []))
(definterface IEnvProxy
  :extends [IEmitProxy]
  (materialized-as-value? ^boolean [])
  (mark-as-materialized! ^void []))

;;; Local copy of a value taken from the entity `origin`, where
;;; `origin` is defined by a parent of the current function (or reify,
;;; or interface function).
(deftype EnvProxy [^Entity origin ^int local-entity-id ^String local-name
                   ^:unsynchronized-mutable ^Entity __emit
                   ^:unsynchronized-mutable ^boolean __materialized?]
  CodeEmitter
  (emit-insn* [_ xb consumed-type then-leave?]
    (.emit-insn* __emit xb consumed-type then-leave?))
  Entity
  (value-type [_]
    (.value-type origin))
  (entity-id [_]
    local-entity-id)
  (invoke* [this fctx form opt-f m-idx xs]
    (.invoke* origin fctx form this m-idx xs))
  IEnvProxy
  (set-emit-entity! [_ ent]
    (set! __emit ent))
  (get-emit-entity [_]
    __emit)
  (materialized-as-value? [_]
    __materialized?)
  (mark-as-materialized! [_]
    (set! __materialized? true)))

(deftype OriginProxyPairs [^Entity/1 aorigin, ^EnvProxy/1 aproxy])

(letfn [(sort-by-origin ^OriginProxyPairs [^Entity/1 aorigin ^EnvProxy/1 aproxy]
          (let [n (alength aorigin)
                aorigin* (new Entity/1 n)
                aproxy* (new EnvProxy/1 n)
                idxs (new long/1 n)]
            (dotimes [i n]
              (aset idxs i (-> (long (.entity-id (aget aorigin i)))
                               (bit-shift-left 16)
                               (bit-or i))))
            (java.util.Arrays/sort idxs)
            (dotimes [i n]
              (let [j (bit-and (int (aget idxs i)) 0xFFFF)]
                (aset aorigin* i (aget aorigin j))
                (aset aproxy* i (aget aproxy j))))
            (OriginProxyPairs. aorigin* aproxy*)))]
  
  (defn sorted-ops ^OriginProxyPairs [^HashMap origin-to-proxy]
    (let [n (.size origin-to-proxy)
          aorigin (new Entity/1 n)
          aproxy (new EnvProxy/1 n)
          it (-> origin-to-proxy .entrySet .iterator)]
      (loop [i 0]
        (when (.hasNext it)
          (let [entry ^Map$Entry (.next it)]
            (aset aorigin i (.getKey entry))
            (aset aproxy i (.getValue entry))
            (recur (inc i)))))
      (if (<= n 1)
        (OriginProxyPairs. aorigin aproxy)
        (sort-by-origin aorigin aproxy)))))

;;; ------------------------------------------------------------------------

(definterface IEnvSegment
  (stage-task! ^void [task])
  (size-staged ^int []))

(deftype EnvSegment [^ConcurrentHashMap private-name-map
                     ^ClassDesc segment-class
                     ^ArrayList tasks
                     ^String pkg-name
                     ^ClassDesc super-class
                     ^int segment-id]
  IEnvSegment
  (stage-task! [_ task]
    (.add tasks task))
  (size-staged [_]
    (.size tasks)))

(letfn [(segment-cld ^ClassDesc [^String pkg-name ^int segm-id]
          (ClassDesc/of pkg-name (str "_" segm-id)))]
  (defn mk-first-segment ^EnvSegment [^String pkg-name]
    (let [segm-id 10]
      (EnvSegment. (ConcurrentHashMap.) (segment-cld pkg-name segm-id)
                   (ArrayList.) pkg-name ConstantDescs/CD_Object segm-id)))
  (defn next-segment ^EnvSegment [^EnvSegment segm]
    (let [pkg-name (-> segm .pkg-name), segm-id (-> segm .segment-id (inc))]
      (EnvSegment. (.private-name-map segm) (segment-cld pkg-name segm-id)
                   (ArrayList.) pkg-name (.segment-class segm) segm-id))))

(defn capstone-class ^ClassDesc [^EnvSegment segm]
  (ClassDesc/of (.pkg-name segm) "___"))

(def ^:private ZERO (object 0))

;; Generates unique names for fn* and reify* instances within a given
;; namespace.  In case of name clashes the result is not
;; deterministic, unless all of the namespace's processing happens
;; within a single thread.
(defn- pick-unique-name ^String [^EnvSegment segm ^String dflt-nm]
  (let [n ^int (.compute (.private-name-map segm) dflt-nm
                         (^BiFunction fn ^Integer [_ ^Integer v]
                          (if (nil? v) ZERO (object (inc ^int v)))))]
    (cond-> dflt-nm (pos? n) (str "^" n))))

;;; ------------------------------------------------------------------------

(definterface IEnvMethod
  (scope-name ^String [])
  (closure-level ^int [])               ;of this class/entity
  (next-entity-id ^int [])
  
  (stage-task! ^void [task])
  (env-proxy-of! ^EnvProxy [^Entity origin ^String local-name]))

;;; An EnvMethod acts as a buffer between the information gathering
;;; phase of parsing and the build step that emits the class files.
;;; It encapsulates mutable state and all updates are initiated from a
;;; single thread.  EnvMethods are usually nested, and capture
;;; information about a given closure's environment.
(deftype EnvMethod [^int method-index   ;within this EnvClass
                    ^:unsynchronized-mutable ^int curr-entity-id
                    ^String class-name  ;if turned into separate class
                    ^EnvMethod parent ;provides this environment's values
                    ^HashMap origin-to-proxy
                    ^String this-name   ;name of any receiver locals
                    ^ArrayList tasks
                    ^EnvSegment segment]
  Object
  (toString [_]
    (str class-name "[" method-index "]"))
  IEnvMethod
  (scope-name [_]
    class-name)
  (closure-level [_]
    (unsigned-bit-shift-right curr-entity-id 16))
  (next-entity-id [_]
    (set! curr-entity-id (inc curr-entity-id)))
  
  (stage-task! [_ task]
    (.add tasks task))
  (env-proxy-of! [this origin local-name]
    #_(prn :closure-level (model/closure-level ent)
           :sequence-number (model/sequence-number ent)
           :using-scope (.scope-name cbp))
    (->> (^Function fn [origin]
          (EnvProxy. origin (.next-entity-id this) local-name nil false))
         (.computeIfAbsent origin-to-proxy origin))))

(defn mk-method-clinit ^EnvMethod [^EnvSegment segm]
  (let [initial-entity-id (model/entity-id-of model/closure-level-clinit)]
    (EnvMethod. 0 initial-entity-id nil nil nil nil (.tasks segm) segm)))

(defn- closes-over? ^boolean [^EnvMethod em ^Entity ent]
  (let [origin (model/closure-level ent)]
    (and (>= origin model/closure-level-clinit)
         (not= origin (.closure-level em)))))

(defn value-of ^Entity [^EnvMethod em ^Entity ent ^Object form]
  #_(prn :cbp-level (.closure-level em)
         :ent-level (model/closure-level ent)
         :sequence-number (model/sequence-number ent)
         :using-scope (.scope-name em)
         :form form
         :ent-class (class ent)
         :closes-over? (closes-over? em ent))
  (if (closes-over? em ent)
    (doto (.env-proxy-of! em ent (name ^symbol form))
      (.mark-as-materialized!))
    ent))

(defn invocation-of ^Entity [^EnvMethod em ^Entity inv ^seq form]
  (if (closes-over? em inv)
    (.env-proxy-of! em inv (name ^symbol (first form)))
    inv))

;;; ------------------------------------------------------------------------

;;; Can add clinit code, class elements, or whole classes to the
;;; segment under construction.
(definterface PreparationTask
  (extend-segment ^SegmentAcc [^SegmentAcc acc ^EnvClass class]))

;;; Represents an entity that may be turned into a decicated class
;;; description while compiling.  Other alternative: a lambda
;;; expression generating a hidden class, a generic shared class
;;; provided by the core library, or the class is elided altogether.
(deftype EnvClass [^PreparationTask class-task
                   ^EnvSegment segment
                   ^String class-name   ;if turned into separate class
                   ^EnvMethod/1 methods])

(defn namespace-class ^ClassDesc [^EnvClass class]
  (ClassDesc/of (-> class .segment .pkg-name) (-> class .class-name)))

(defn run-task ^SegmentAcc [^SegmentAcc acc ^PreparationTask task ^EnvClass class]
  (.extend-segment task acc class))

(defn mk-methods
  (^EnvMethod/1 [^EnvMethod parent ^Class itf-class]
   (mk-methods parent (.getSimpleName itf-class) 1 0))
  (^EnvMethod/1 [^EnvMethod parent ^String scope-name-suffix
                 ^int n ^int preassigned-entity-ids]
   (letfn [(method ^EnvMethod [^String unique-nm ^int method-index]
             (let [level' (if (some? unique-nm)
                            (inc (.closure-level parent))
                            model/closure-level-clinit)
                   entity-id (model/entity-id-of level' preassigned-entity-ids)]
               (EnvMethod. method-index entity-id unique-nm parent (HashMap.)
                           scope-name-suffix (ArrayList.) (.segment parent))))]
     (let [parent-name (.scope-name parent)
           nm-str (cond->> (cfg/munge-name scope-name-suffix)
                    (some? parent-name) (str parent-name "$"))
           unique-nm (pick-unique-name (.segment parent) nm-str)
           a (new EnvMethod/1 n)]
       (dotimes [i (alength a)]
         (aset a i (method unique-nm i)))
       a))))

(letfn [(method-closes-over-env? ^boolean [^EnvMethod m]
          (let [it (-> m .origin-to-proxy .values .iterator)]
            (loop [] (when (.hasNext it)
                       (or (.materialized-as-value? ^EnvProxy (.next it))
                           (recur))))))]
  (defn fn-closes-over-env? ^boolean [^EnvClass class]
    (let [ms (.methods class)]
      (loop [i (dec (alength ms))]
        (cond (neg? i) false
              (method-closes-over-env? (aget ms i)) true
              :else (recur (dec i)))))))

(defn class-origin-to-proxy ^HashMap [^EnvClass class]
  (let [methods (.methods class), n (alength methods)]
    (if (= n 1)
      (.origin-to-proxy (aget methods 0))
      (let [acc ^HashMap (.clone (.origin-to-proxy (aget methods (dec n))))]
        (loop [i (- n 2)]
          (when (>= i 0)
            (.putAll acc (.origin-to-proxy (aget methods i)))
            (recur (dec i))))
        acc))))


(deftype EnvGraph [^EnvClass/1 classes])

;;; ------------------------------------------------------------------------

(defn mk-graph ^EnvGraph [^ArrayList tasks ^int tasks-end]
  (let [acc-classes (ArrayList.)]
    (letfn [(add-class! ^void [^EnvMethod parent ^EnvClass class]
              (let [n (alength (.methods class))]
                (dotimes [i n]
                  (let [method (aget (.methods class) i)
                        tasks (.tasks method)]
                    (add-tasks! method tasks (.size tasks))))
                (.add acc-classes class)))
            (add-tasks! ^void [^EnvMethod parent ^ArrayList tasks ^int tasks-end]
              (dotimes [i tasks-end]
                (let [task (.get tasks i)]
                  (when (instance? EnvClass task)
                    (add-class! parent task)))))]
      (add-tasks! nil tasks tasks-end)
      (EnvGraph. (.toArray acc-classes (new EnvClass/1 0))))))
