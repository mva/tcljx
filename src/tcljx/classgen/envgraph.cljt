(ns tcljx.classgen.envgraph
  (:require (tcljx.data model)
            (tcljx.classgen emit))
  (:import (tcljx.data.model Entity)
           (tcljx.classgen.emit EnvProxy ClosureBlueprint SegmentAcc)
           (java.lang.constant ClassDesc)
           (java.util ArrayList HashMap Map$Entry)))

(deftype CodeBearingFragment [^ClassDesc owner ;if inlined into nmsp segment
                              ^String class-name ;if turned into separate class
                              ^String this-name ;name of any receiver locals
                              ^Entity fn-proxy
                              ^ClosureBlueprint/1 closures])

;;; ------------------------------------------------------------------------

(deftype OriginProxyPairs [^Entity/1 aorigin, ^EnvProxy/1 aproxy])

(defn sorted-ops ^OriginProxyPairs [^HashMap origin-to-proxy]
  (let [n (.size origin-to-proxy)
        aorigin (new Entity/1 n)
        aproxy (new EnvProxy/1 n)
        it (-> origin-to-proxy .entrySet .iterator)]
    (loop [i 0]
      (when (.hasNext it)
        (let [entry ^Map$Entry (.next it)]
          (aset aorigin i (.getKey entry))
          (aset aproxy i (.getValue entry))
          (recur (inc i)))))
    (assert (= n 1))
    (OriginProxyPairs. aorigin aproxy)))

;;; ------------------------------------------------------------------------

(deftype EnvMethod [^String class-name
                    ^int method-index   ;within this class
                    ^int closure-level  ;of this class/entity
                    ^EnvMethod parent ;provides this environment's values
                    ^HashMap origin-to-proxy]
  Object
  (toString [_]
    (str class-name "[" method-index "]")))

(defn- mk-method ^EnvMethod [^ClosureBlueprint closure ^int method-index
                             ^EnvMethod parent]
  #_(println :mk-method (str (.scope-name closure)
                             "[" method-index "] with level="
                             (.closure-level closure)
                             ", parent=" parent))
  (EnvMethod. (.scope-name closure) method-index (.closure-level closure)
              parent (.origin-to-proxy closure)))


(deftype EnvClass [^EnvMethod/1 methods
                   ^CodeBearingFragment cbf])

(defn closes-over-env? ^boolean [^EnvClass class]
  (let [ms (.methods class)]
    (loop [i (dec (alength ms))]
      (cond (neg? i) false
            (.isEmpty (.origin-to-proxy (aget ms i))) (recur (dec i))
            :else true))))

(defn class-origin-to-proxy ^HashMap [^EnvClass class]
  (let [methods (.methods class), n (alength methods)]
    (if (= n 1)
      (.origin-to-proxy (aget methods 0))
      (let [acc ^HashMap (.clone (.origin-to-proxy (aget methods (dec n))))]
        (loop [i (- n 2)]
          (when (>= i 0)
            (.putAll acc (.origin-to-proxy (aget methods i)))
            (recur (dec i))))
        acc))))


;;; Can add clinit code, class elements, or whole classes to the
;;; segment under construction.
(definterface PreparationTask
  (extend-segment ^SegmentAcc [^SegmentAcc acc ^EnvClass class]))

(defn run-task ^SegmentAcc [^SegmentAcc acc ^PreparationTask task ^EnvClass class]
  (.extend-segment task acc class))


(deftype EnvGraph [^EnvClass/1 classes])

;;; ------------------------------------------------------------------------

(defn mk-graph ^EnvGraph [^ArrayList tasks ^int tasks-end]
  (let [acc-classes (ArrayList.)]
    (letfn [(add-cbf! ^void [^EnvMethod parent ^CodeBearingFragment cbf]
              (let [closures (.closures cbf)
                    n (alength closures)
                    class-methods (new EnvMethod/1 n)]
                (dotimes [i n]
                  (let [closure (aget closures i)
                        tasks (.tasks closure)
                        method (mk-method closure i parent)]
                    ;; FIXME... drop closure's scope-name?
                    (assert (identical? (.class-name cbf) (.scope-name closure)))
                    (aset class-methods i method)
                    (add-tasks! method tasks (.size tasks))))
                (.add acc-classes (EnvClass. class-methods cbf))))
            (add-tasks! ^void [^EnvMethod parent ^ArrayList tasks ^int tasks-end]
              (dotimes [i tasks-end]
                (let [frag (.get tasks i)]
                  (condp instance? frag
                    CodeBearingFragment (add-cbf! parent frag)
                    #_else nil))))]
      (add-tasks! nil tasks tasks-end)
      (EnvGraph. (.toArray acc-classes (new EnvClass/1 0))))))
