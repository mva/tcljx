(ns tcljx.classgen.condgen
  (:require
   (tcljx.data [type :as type] [resolve :as resolve] [model :as model])
   (tcljx.classgen [insn :as insn] [entity :as entity] [emit :as emit]))
  (:import
   (tcljx.data.model CodeEmitter Invocable)
   (tcljx.classgen.insn Insn #_Insns)
   (java.lang.classfile CodeBuilder Opcode Label)))

(definterface Branching
  :extends [CodeEmitter]
  (emit-branch-if-false? ^boolean [^CodeBuilder xb ^int line ^Label target]))

;;; Values for `cmp-opcd`.
(def cmp-eq 0)
(def cmp-ne 1)
(def cmp-lt 2)
(def cmp-ge 3)
(def cmp-gt 4)
(def cmp-le 5)

(defn- negate-test ^int [^int cmp-opcd]
  (bit-xor cmp-opcd 0x1))               ;even -> inc, odd -> dec

(defn- swap-cmp ^int [^int cmp-opcd]
  (case cmp-opcd
    (0 1) cmp-opcd                      ;eq -> eq, ne -> ne
    (2 3) (+ cmp-opcd 2)                ;lt -> gt, ge -> le
    (4 5) (- cmp-opcd 2)))              ;gt -> lt, le -> ge

(defn- conditional ^CodeEmitter [^Branching branch
                                 ^CodeEmitter if-true ^CodeEmitter if-false]
  (^CodeEmitter fn [xb line requested-type]
   (let [start-false (.newLabel xb), end-false (.newLabel xb)]
     (when (.emit-branch-if-false? branch xb line start-false)
       
       (let [completing-true? (emit/insn? xb line requested-type if-true)]
         (when completing-true?
           (.goto_ xb end-false))
         
         (.labelBinding xb start-false)
         (let [completing-false? (emit/insn? xb line requested-type if-false)]
           (.labelBinding xb end-false)
           (when (or completing-true? completing-false?)
             requested-type)))))))

(defn- mk-branch* ^Branching [^int bytecode ^Class arg-type ^CodeEmitter/1 args]
  (reify Branching
    (emit-insn* [this xb line requested-type]
      (.emit-insn* (conditional this (.emitter entity/insn-true)
                                (.emitter entity/insn-false))
                   xb line requested-type))
    (emit-branch-if-false? [_ xb line target]
      (when (emit/insns? xb line arg-type args)
        (case (negate-test bytecode)
          153 (.ifeq xb target)
          154 (.ifne xb target)
          155 (.iflt xb target)
          156 (.ifge xb target)
          157 (.ifgt xb target)
          158 (.ifle xb target)
          159 (.if_icmpeq xb target)
          160 (.if_icmpne xb target)
          161 (.if_icmplt xb target)
          162 (.if_icmpge xb target)
          163 (.if_icmpgt xb target)
          164 (.if_icmple xb target)
          165 (.if_acmpeq xb target)
          166 (.if_acmpne xb target)
          198 (.ifnull xb target)
          199 (.ifnonnull xb target))
        true))))

(defn- mk-branch ^Branching [^Opcode eq-opc ^int cmp-opcd
                             ^Class arg-type ^CodeEmitter/1 args]
  (loop [opcd cmp-opcd
         left (aget args 0)
         right (aget args 1)]
    ;; loop body is executed at most twice
    (cond
      (model/ce-zero? right)            ;slide if_icmpeq to ifeq
      (mk-branch* (+ (- (.bytecode eq-opc) 6) opcd) arg-type
                  (doto (new CodeEmitter/1 1) (aset 0 left)))
      
      (model/ce-zero? left)
      (recur (swap-cmp opcd) right left)
                  
      (model/ce-null? right)            ;slide if_acmpeq to ifnull
      (mk-branch* (+ (+ (.bytecode eq-opc) 33) opcd) arg-type
                  (doto (new CodeEmitter/1 1) (aset 0 left)))
      
      (model/ce-null? left)
      (recur (swap-cmp opcd) right left)
      
      :else (mk-branch* (+ (.bytecode eq-opc) opcd) arg-type
                        (doto (new CodeEmitter/1 2)
                          (aset 0 left)
                          (aset 1 right))))))

(defn- cmp-expr ^Insn [^Opcode eq-opc ^int cmp-opcd
                       ^Class arg-type ^Insn arg0 ^Insn arg1]
  (insn/mk-insn (mk-branch eq-opc cmp-opcd arg-type
                           (.emitters (insn/insns-of arg0 arg1)))
                Boolean/TYPE))

;;; ------------------------------------------------------------------------

(letfn [(null-value-pred ^Boolean [^Insn x]
          ;; This function assumes that any `const-value` is produced
          ;; by compiler code, and that all non-NULL values (including
          ;; DynamicConstantDesc) always describe some literal and
          ;; known to be non-null value.
          (let [c (model/const-value x)]
            (cond (nil? c) nil                 ;may be null
                  (model/null? c) Boolean/TRUE ;is always null
                  :else Boolean/FALSE)))]      ;is never null
  
  (defn acmp ^Insn [^Insn arg0 ^Insn arg1 ^int cmp-opcd]
    (or (when-some [c0 (null-value-pred arg0)]
          (when-some [c1 (null-value-pred arg1)]
            (let [c0 ^boolean c0, c1 ^boolean c1]
              (when (or c0 c1)       ;both non-null means "don't know"
                (if (= (= cmp-opcd cmp-ne) (and c0 c1))
                  entity/insn-false
                  entity/insn-true)))))
        (cmp-expr Opcode/IF_ACMPEQ cmp-opcd Object arg0 arg1))))

;;; ------------------------------------------------------------------------

(def rt-boolean-cast
  (resolve/runtime-method clojure.lang.RT "booleanCast"
                          (doto (new Class/1 1) (aset 0 Object))))

;; Implements Clojure's idea of a "logically true" expression.
(defn logical-truth ^Insn [^Insn arg]
  (let [arg-tp (insn/expr-type arg)]
    (if (.isPrimitive arg-tp)
      (cond
        (type/same? Boolean/TYPE arg-tp)
        arg                    ;identity if `arg` is primitive boolean
        (type/polymorphic? arg-tp)
        entity/insn-false             ;polymorphic (aka void) is false
        :else
        entity/insn-true) ;all other primitive types are true
      (cond               ;important: any nil value is logically false
        ;; (model/ce-null? (.emitter arg)) ;argument is literal nil
        ;; entity/insn-false
        (.isAssignableFrom arg-tp Boolean) ;argument is a Boolean
        (insn/invoke-member rt-boolean-cast nil (insn/insns-of arg))
        :else   ;any reference that is a non-Boolean subtype of Object
        (acmp arg entity/insn-null cmp-ne)))))

(defn if-expr ^Insn [^Insn test ^Class expr-type ^Insn if-true ^Insn if-false]
  (let [test (logical-truth test)]
    (cond
      (identical? entity/insn-true test)
      if-true
      (identical? entity/insn-false test)
      if-false
      :else
      (-> (if (instance? Branching (.emitter test))
            (.emitter test)    ;`test` is already a branch instruction
            (mk-branch Opcode/IF_ICMPEQ cmp-ne Boolean/TYPE ;compare with zero!
                       (doto (new CodeEmitter/1 2)
                         (aset 0 (.emitter test)) ;the boolean value to test
                         (aset 1 (.emitter entity/insn-false))))) 
          (conditional (.emitter if-true) (.emitter if-false))
          (insn/mk-insn expr-type)))))
