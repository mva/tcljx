(ns tcljx.classgen.condgen
  (:require
   (tcljx.data [type :as type] [resolve :as resolve] [model :as model]
               [wrong :as wrong])
   (tcljx.classgen [insn :as insn] [entity :as entity] [emit :as emit]))
  (:import
   (tcljx.data.model CodeEmitter Invocable)
   (tcljx.classgen.insn Insn #_Insns)
   (java.lang.classfile CodeBuilder Opcode Label)))

(definterface Branching
  :extends [CodeEmitter]
  (emit-branch-if-false? ^boolean [^CodeBuilder xb ^int line ^Label target]))

;;; Values for `cmp-opcd`.
(def cmp-eq 0)
(def cmp-ne 1)
(def cmp-lt 2)
(def cmp-ge 3)
(def cmp-gt 4)
(def cmp-le 5)

(defn- negate-test ^int [^int cmp-opcd]
  (bit-xor cmp-opcd 0x1))               ;even -> inc, odd -> dec

(defn- swap-cmp ^int [^int cmp-opcd]
  (case cmp-opcd
    (0 1) cmp-opcd                      ;eq -> eq, ne -> ne
    (2 3) (+ cmp-opcd 2)                ;lt -> gt, ge -> le
    (4 5) (- cmp-opcd 2)))              ;gt -> lt, le -> ge

(defn- conditional ^CodeEmitter [^Branching branch
                                 ^CodeEmitter if-true ^CodeEmitter if-false]
  (^CodeEmitter fn [xb line consumed-type then-leave?]
   (let [start-false (.newLabel xb), end-false (.newLabel xb)]
     (when (.emit-branch-if-false? branch xb line start-false)
       
       (let [return-t? (emit/insn? xb line consumed-type if-true then-leave?)]
         (when return-t?
           (.goto_ xb end-false))
         
         (.labelBinding xb start-false)
         (let [return-f? (emit/insn? xb line consumed-type if-false then-leave?)]
           (.labelBinding xb end-false)
           (when (or return-t? return-f?)
             consumed-type)))))))

(defn- mk-branch* ^Branching [^int opcode-eq ^int cmp-opcd
                              ^Class arg-type ^CodeEmitter/1 args]
  (let [bytecode (+ opcode-eq (negate-test cmp-opcd))]
    (reify Branching
      (emit-insn* [this xb line consumed-type then-leave?]
        (.emit-insn* (conditional this (.emitter entity/insn-true)
                                  (.emitter entity/insn-false))
                     xb line consumed-type then-leave?))
      (emit-branch-if-false? [_ xb line target]
        (when (emit/insns? xb line arg-type args)
          (case bytecode
            153 (.ifeq xb target)
            154 (.ifne xb target)
            155 (.iflt xb target)
            156 (.ifge xb target)
            157 (.ifgt xb target)
            158 (.ifle xb target)
            159 (.if_icmpeq xb target)
            160 (.if_icmpne xb target)
            161 (.if_icmplt xb target)
            162 (.if_icmpge xb target)
            163 (.if_icmpgt xb target)
            164 (.if_icmple xb target)
            165 (.if_acmpeq xb target)
            166 (.if_acmpne xb target)
            198 (.ifnull xb target)
            199 (.ifnonnull xb target))
          true)))))

(defn- mk-branch ^Branching [^Opcode eq-opc ^int cmp-opcd
                             ^Class arg-type ^CodeEmitter/1 args]
  (loop [opcd cmp-opcd
         left (aget args 0)
         right (aget args 1)]
    ;; loop body is executed at most twice
    (cond
      (model/ce-zero? right)            ;slide if_icmpeq to ifeq
      (mk-branch* (- (.bytecode eq-opc) 6) opcd arg-type
                  (doto (new CodeEmitter/1 1) (aset 0 left)))
      
      (model/ce-zero? left)
      (recur (swap-cmp opcd) right left)
                  
      (model/ce-null? right)            ;slide if_acmpeq to ifnull
      (mk-branch* (+ (.bytecode eq-opc) 33) opcd arg-type
                  (doto (new CodeEmitter/1 1) (aset 0 left)))
      
      (model/ce-null? left)
      (recur (swap-cmp opcd) right left)
      
      :else
      (mk-branch* (.bytecode eq-opc) opcd arg-type
                  (doto (new CodeEmitter/1 2)
                    (aset 0 left)
                    (aset 1 right))))))

(defn- cmp-expr ^Insn [^Opcode eq-opc ^int cmp-opcd
                       ^Class arg-type ^Insn arg0 ^Insn arg1]
  (insn/mk-insn (mk-branch eq-opc cmp-opcd arg-type
                           (.emitters (insn/insns-of arg0 arg1)))
                Boolean/TYPE))

;;; ------------------------------------------------------------------------

(letfn [(null-value-pred ^Boolean [^Insn x]
          ;; This function assumes that any `const-value` is produced
          ;; by compiler code, and that all non-NULL values (including
          ;; DynamicConstantDesc) always describe some literal and
          ;; known to be non-null value.
          (let [c (model/const-value x)]
            (cond (nil? c) nil                 ;may be null
                  (model/null? c) Boolean/TRUE ;is always null
                  :else Boolean/FALSE)))]      ;is never null
  
  (defn acmp ^Insn [^Insn arg0 ^Insn arg1 ^int cmp-opcd]
    (or (when-some [c0 (null-value-pred arg0)]
          (when-some [c1 (null-value-pred arg1)]
            (let [c0 ^boolean c0, c1 ^boolean c1]
              (when (or c0 c1)       ;both non-null means "don't know"
                (if (= (= cmp-opcd cmp-ne) (and c0 c1))
                  entity/insn-false
                  entity/insn-true)))))
        (cmp-expr Opcode/IF_ACMPEQ cmp-opcd Object arg0 arg1))))

(defn icmp ^Insn [^Insn arg0 ^Insn arg1 ^int cmp-opcd]
  (or (when-some [c0 (model/const-value arg0)]
        (when-some [c1 (model/const-value arg1)]
          (let [n0 ^int c0, n1 ^int c1]
            (when (or c0 c1)         ;both non-null means "don't know"
              (if (case cmp-opcd
                    #_eq 0 (= n0 n1)
                    #_ne 1 (not= n0 n1)
                    #_lt 2 (< n0 n1)
                    #_ge 3 (>= n0 n1)
                    #_gt 4 (> n0 n1)
                    #_le 5 (<= n0 n1))
                entity/insn-true
                entity/insn-false)))))
      (cmp-expr Opcode/IF_ICMPEQ cmp-opcd Integer/TYPE arg0 arg1)))

;;; ------------------------------------------------------------------------

(def rt-boolean-cast
  (resolve/runtime-method clojure.lang.RT "booleanCast"
                          (doto (new Class/1 1) (aset 0 Object))))

;; Implements Clojure's idea of a "logically true" expression.
(defn logical-truth ^Insn [^Insn arg]
  (let [arg-tp (insn/expr-type arg)]
    (if (.isPrimitive arg-tp)
      (cond
        (type/same? Boolean/TYPE arg-tp)
        arg                    ;identity if `arg` is primitive boolean
        (type/polymorphic? arg-tp)
        entity/insn-false             ;polymorphic (aka void) is false
        :else
        entity/insn-true) ;all other primitive types are true
      (cond               ;important: any nil value is logically false
        ;; (model/ce-null? (.emitter arg)) ;argument is literal nil
        ;; entity/insn-false
        (.isAssignableFrom arg-tp Boolean) ;argument may be Boolean instance
        (insn/invoke-member rt-boolean-cast nil (insn/insns-of arg))
        :else   ;any reference that is a non-Boolean subtype of Object
        (acmp arg entity/insn-null cmp-ne)))))

;;; Throws if there is no type from which all paths in the given range
;;; of `types` are assignable.  pre: (< start end)
(defn join-type ^Class [^Class/1 types ^int start ^int end]
  (loop [candidate (aget types (dec end)), i (- end 2)]
    (if (< i start)
      candidate
      (let [tp (aget types i)]
        (cond
          (or (identical? candidate tp) (type/polymorphic? tp))
          (recur candidate (dec i))
          (type/polymorphic? candidate)
          (recur tp (dec i))
          :else
          (throw (wrong/wr-info (str "incompatible path types"
                                     (wrong/got-types types start end)))))))))

(defn mk-if ^CodeEmitter [^CodeEmitter test
                          ^CodeEmitter if-true ^CodeEmitter if-false]
  (-> (if (instance? Branching test)
        test                   ;`test` is already a branch instruction
        (mk-branch Opcode/IF_ICMPEQ cmp-ne Boolean/TYPE ;compare to zero!
                   (doto (new CodeEmitter/1 2)
                     (aset 0 test)      ;the boolean value to test
                     (aset 1 (.emitter entity/insn-false))))) 
      (conditional if-true if-false)))
