(ns tcljx.classgen.publics
  (:require
   (tcljx.data [config :as cfg] [wrong :as wrong] [reflect :as reflect]
               [type :as type] [resolve :as resolve] [member :as member]
               [ir :as ir])
   (tcljx.classgen [runtime :as rt] [segment :as segment] [insn :as insn]
                   [constgen :as constgen] [defgen :as defgen]
                   [fngen :as fngen]))
  (:import
   (tcljx.data.ir Entity ArityType MethodSpec ProvidedNamespace)
   (tcljx.classgen.defgen DefMethod DefField DefVarDeref)
   (tcljx.classgen.fngen FnStatic FnVirtual)
   (java.lang.constant ConstantDesc ClassDesc DirectMethodHandleDesc)
   (java.lang.invoke MethodType MethodHandle MethodHandles$Lookup)
   (java.lang.reflect Member Method Field)
   (java.util HashMap)))

(definterface PublicsBuilder
  (public-def-info ^Object/1 [^Member member])
  (fn-arities ^Object/1 [^Class tp ^Object value])
  (lookup-symbol ^Entity [^symbol sym])
  (capstone-for ^Class [^String ns-str])
  (require-strings ^String [^Class capstone])
  
  (for-namespace ^PublicsBuilder [^map known-ns ^Class capstone])
  (add-global ^void [^String mnm ^Entity ent])
  (finish-namespace ^map []))

(deftype PublicsBuilderImpl [^MethodHandles$Lookup lookup-in-pkg
                             ^MethodHandle pdf-mh
                             ^MethodHandle arity-handles-mh
                             ^map known-ns
                             ^Class this-capstone
                             ^String this-ns-str
                             ^HashMap this-globals]
  PublicsBuilder
  (public-def-info [_ member]
    ^Object/1 (.invokeExact pdf-mh lookup-in-pkg member))
  (fn-arities [_ tp value]
    ^MethodHandle/1 (.invokeExact arity-handles-mh lookup-in-pkg tp value))
  (lookup-symbol [_ sym]
    (let [nmsp (namespace sym), nm (name sym)]
      (if-some [pn (.valAt known-ns nmsp nil)]
        (.valAt (.globals ^ProvidedNamespace pn) nm nil)
        (when (= nmsp this-ns-str)
          (.getOrDefault this-globals nm nil)))))
  (capstone-for [_ ns-str]
    (.resolveConstantDesc (segment/capstone-class ns-str) lookup-in-pkg))
  (require-strings [_ capstone]
    ^String (.invokeExact (.findStatic lookup-in-pkg capstone rt/name-requires
                                       (MethodType/methodType String))))
  
  (for-namespace [_ known-ns capstone]
    (let [ns-str (.getPackageName capstone)]
      (assert (not (contains? known-ns ns-str)))
      (PublicsBuilderImpl. lookup-in-pkg pdf-mh arity-handles-mh
                           known-ns capstone ns-str (HashMap.))))
  (add-global [_ mnm ent]
    (.put this-globals (cfg/demunge-name mnm) ent))
  (finish-namespace [_]
    (let [globals (into {} this-globals)]
      (->>  (insn/insns-of (insn/constant this-capstone Class))
            (insn/invoke-member resolve/ensure-initialized nil)
            (ProvidedNamespace. this-ns-str globals)
            (assoc known-ns this-ns-str)))))

(letfn [(method-specs-of ^MethodSpec/1 [^boolean virtual? ^MethodHandle/1 mhs]
          (let [mspecs (new MethodSpec/1 (alength mhs))]
            (dotimes [i (alength mspecs)]
              (let [mh (aget mhs i), mt (.type mh)]
                (aset mspecs i
                      (-> (ArityType. (.returnType mt) (.parameterArray mt)
                                      nil (.isVarargsCollector mh) false)
                          (MethodSpec. nil nil nil i nil)))))
            mspecs))]
  
  (defn- import-fn ^Entity [^PublicsBuilder pb ^Class declared-tp ^Object value]
    (when-some [mhs (.fn-arities pb declared-tp value)]
      (let [static? (type/same-name? tinyclj.lang.StaticFn declared-tp)
            mspecs (method-specs-of (not static?) mhs)
            mhds (new DirectMethodHandleDesc/1 (alength mhs))]
        (dotimes [i (alength mhds)]
          (aset mhds i (reflect/describe (aget mhs i))))
        (if static?
          (FnStatic. -1 mspecs mhds)
          (FnVirtual. -1 mspecs mhds (reflect/describe declared-tp)
                      nil nil nil -1))))))

(defn- add-methods! ^PublicsBuilder [^PublicsBuilder pb ^ClassDesc owner
                                     ^Method/1 am]
  (dotimes [i (alength am)]
    (let [m (aget am i), mnm (.getName m)]
      (when (and (member/acc-public? (.getModifiers m))
                 (zero? (.getParameterCount m))
                 (neg? (.lastIndexOf mnm (int \~))))
        (->> (let [value (.invoke m nil), tp (.getReturnType m)]
               ;; logic mirrors tcljx.parser.constant/parse-constant-nometa
               (cond
                 (or (nil? value) (instance? ConstantDesc value))
                 (constgen/constant value tp)
                 (boolean? value)
                 (constgen/constant (int ^boolean value) tp)
                 (char? value)
                 (constgen/constant (int ^char value) tp)
                 (number? value) ;any non-ConstantDesc number: Byte and Short
                 (constgen/constant (int ^Number value) tp)
                 :else ;keyword, symbol, pattern, collection, or FnStatic
                 (let [pdf (.public-def-info pb m)]
                   (case (some-> pdf (aget 0))
                     ":macro" (DefMethod. ir/entity-id-def-macro 0 owner mnm
                                tp nil value)
                     #_else (DefMethod. ir/entity-id-def 0 owner mnm tp
                              (import-fn pb tp value) nil)))))
             (.add-global pb mnm)))))
  pb)

(defn- add-fields! ^PublicsBuilder [^PublicsBuilder pb ^ClassDesc owner
                                    ^Field/1 af]
  (letfn [(of-def ^DefField [^Field f ^Entity init-ce]
            (DefField. ir/entity-id-def (.getModifiers f) owner (.getName f)
              (.getType f) init-ce nil nil))
          (of-alias ^Entity [^String sym-str]
            (let [sym (symbol sym-str)]
              (or (.lookup-symbol pb sym)
                  (wrong/other (str "alias refers to :private def "
                                    (wrong/q sym))))))
          (of-macro ^DefField [^Field f]
            (DefField. ir/entity-id-def-macro (.getModifiers f) owner
              (.getName f) (.getType f) nil nil (.get f nil)))]
    (dotimes [i (alength af)]
      (let [f (aget af i), mnm (.getName f), pdf (.public-def-info pb f)]
        (when (member/acc-public? (.getModifiers f))
          (->> (case (some-> pdf (aget 0))
                 ":var" (DefVarDeref. (of-def f nil) (aget pdf 1))
                 ":alias" (of-alias (aget pdf 1))
                 ":macro" (of-macro f)
                 #_else (of-def f (import-fn pb (.getType f) (.get f nil))))
               (.add-global pb mnm))))))
  pb)

(defn- mk-import-namespace* [^PublicsBuilder pb-tmpl]
  (letfn [(segments-into! ^PublicsBuilder [^PublicsBuilder pb ^Class segment]
            (let [owner (reflect/describe-class segment)]
              (cond-> pb
                (not (identical? Object segment))
                (-> (segments-into! (.getSuperclass segment))
                    (add-methods! owner (.getDeclaredMethods segment))
                    (add-fields! owner (.getDeclaredFields segment))))))
          (import-requires ^map [^map known-ns ^Class capstone]
            (let [req-strs (.require-strings pb-tmpl capstone)]
              (loop [known-ns known-ns, i 0]
                (let [j (.indexOf req-strs (int \,) i)]
                  (if (neg? j)
                    known-ns
                    (let [ns-str (.substring req-strs i j)]
                      (-> (cond-> known-ns
                            (not (contains? known-ns ns-str))
                            (import-namespace (.capstone-for pb-tmpl ns-str)))
                          (recur (inc j)))))))))
          (import-namespace ^map [^map known-ns ^Class capstone]
            (let [known-ns (import-requires known-ns capstone)]
              (-> (.for-namespace pb-tmpl known-ns capstone)
                  (segments-into! (.getSuperclass capstone))
                  (.finish-namespace))))]
    (fn ^map [^map known-ns ^Class capstone]
      (cond-> known-ns
        (not (contains? known-ns (.getPackageName capstone)))
        (import-namespace capstone)))))

(defn mk-import-namespace [^MethodHandles$Lookup lookup-in-pkg
                           ^MethodHandles$Lookup rt-lookup]
  (let [pdf-mh (.resolveConstantDesc rt/mhd-publicDefInfo rt-lookup)
        arity-handles-mh (.resolveConstantDesc rt/mhd-arityHandlesIfFn rt-lookup)]
    (-> (PublicsBuilderImpl. lookup-in-pkg pdf-mh arity-handles-mh
                             nil nil nil nil)
        (mk-import-namespace*))))
