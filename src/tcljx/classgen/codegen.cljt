(ns tcljx.classgen.codegen
  (:require
   (tcljx [config :as cfg] [type :as type] [model :as model]
          [resolve :as resolve] [reflect :as reflect])
   (tcljx.classgen [classfile :as classfile] [runtime :as rt] [emit :as emit]
                   [segmgen :as segmgen] [methodgen :as methodgen]))
  (:import
   (tcljx.model Expr CodeEmitter Entity Parameter Constant
                FnLiteral ExprFactory NamespaceBuilder)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc)
   (java.lang.reflect Member Constructor)
   (java.util ArrayList)
   (java.util.function Consumer)))

(definterface ClassElementEmitter
  (emit-class-element ^void [^ClassBuilder cb]))
(defn class-element-emitter? ^boolean [x]
  (instance? ClassElementEmitter x))
(defn emit-class-element ^CodeBuilder [^ClassBuilder cb ^ClassElementEmitter cee]
  (.emit-class-element cee cb))

;;; The code generator's implementation of Expr.  The class in
;;; `expr-type` is the Clojure(!) type of the expression after parsing
;;; it in isolation.  Phrased differently, it is the expression's own
;;; idea of its type in terms of Clojure's type system, disregarding
;;; the context in which it appears.  By design, an Insn instance does
;;; not expose the internal structure of a non-constant expression.
;;; Only constants are discoverable, enabling bottom up constant
;;; folding while building the expression tree.
(deftype Insn [^CodeEmitter emitter
               ^Class expr-type]
  ;; FIXME... Valhalla value?
  java.lang.Record
  Expr
  (entity [_]
    (when (instance? Entity emitter)
      emitter)))
(defn- expr-type
  (^Class [^Insn insn]
   (.expr-type insn))
  (^Class [^Insn/1 insns ^int i]
   (expr-type (aget insns i))))
(defn- logical-type ^Class [^Insn insn]
  (type/expr-to-logical (expr-type insn)))

(def empty-insn (Insn. (^CodeEmitter fn [xb requested-type line] Void/TYPE)
                       type/polymorphic))

;;; Emit instruction to `xb` and adapt the stack operand it produces
;;; to `requested-type`.  Returns false if the instruction returns
;;; control to the invoking method, and true if execution continues in
;;; this method.
(defn emit-code-logical? ^boolean [^CodeBuilder xb ^Insn insn]
  (emit/more? xb (logical-type insn) insn cfg/no-line-number))

(defn emit-code*?
  (^boolean [^CodeBuilder xb ^Class requested-type ^Insn/1 insns
             ^int line]
   (let [end (dec (alength insns))]
     (loop [i 0]
       (let [insn (aget insns i)]
         (if (< i end)
           (if (emit/more? xb Void/TYPE insn line)
             (recur (inc i))
             false)
           (emit/more? xb requested-type insn line))))))
  (^boolean [^CodeBuilder xb ^Class/1 requested-types ^Insn/1 insns
             ^boolean skip-receiver? ^int line]
   (loop [i 0]
     (if (< i (alength requested-types))
       (if (emit/more? xb (aget requested-types i)
                       (aget insns (+ (int skip-receiver?) i)) line)
         (recur (inc i))
         false)
       true))))

(defn- with-line-number ^Insn [^Insn insn ^int line]
  (Insn. (^CodeEmitter fn [xb requested-type _]
          (when (emit/more? xb requested-type insn line)
            requested-type))
         (expr-type insn)))

(deftype ConstantImpl [^Class type ^Object const-value]
  java.lang.Record
  Constant
  (emit-code* [_ xb requested-type line]
    (.loadConstant xb (if (instance? ConstantDesc const-value)
                        ^ConstantDesc const-value
                        (reflect/describe const-value)))
    type))

(defn- progn ^Insn [^Insn/1 insns]
  (if (zero? (alength insns))
    empty-insn
    (Insn. (^CodeEmitter fn [xb requested-type line]
            (when (emit/more-of-type*? xb requested-type insns line)
              requested-type))
           (expr-type insns (dec (alength insns))))))

(defn- invoke ^Insn [^Class owner ^Member member ^Insn receiver ^Insn/1 args]
  (let [opnd-type (reflect/invoke-member-type owner member)]
    (Insn. (^CodeEmitter fn [xb requested-type line]
            (when (instance? Constructor member)
              ;; new-dup-dance when create a new instance of `owner`
              (-> xb (.new_ (reflect/describe-class owner)) (.dup)))
            (when (or (nil? receiver) (emit-code-logical? xb receiver))
              (when (emit/more-of-types*? xb (reflect/parameter-types member)
                                          args line)
                (-> (.lineNumber xb line)
                    (reflect/invoke-member owner member))))
            opnd-type)
           opnd-type)))

;;; ------------------------------------------------------------------------

;;; Helper function for the local variable protocol.  When a method's
;;; code attribute is produced, the Binding is established first: its
;;; `emit-code` sets a private mutable field to the allocated slot
;;; value.  The binding's `bound-value` method returns an Insn whose
;;; own `emit-code` closes over the Binding instance (not the mutable
;;; slot value in the mutable field!), allowing it to retrieve the
;;; previously stored value via `allocated-slot`.  Initializiation
;;; should set the undefined slot value to -1.
(definterface LocalVariableSlot
  (allocated-slot ^int []))

(deftype ParameterImpl [^int param-no ^String name ^Class type
                        ^:unsynchronized-mutable ^int slot]
  Parameter
  (emit-code* [this xb requested-type line]
    (set! slot (.parameterSlot xb param-no))
    (.localVariable xb slot name (reflect/describe-class type)
                    (.startLabel xb) (.endLabel xb))
    Void/TYPE)
  (name [_]
    name)
  (namespace [_]
    nil)
  (init [_]
    nil)
  (bound-value [this]
    (Insn. (^CodeEmitter fn [xb requested-type line]
            (.loadLocal xb (TypeKind/from type) (.allocated-slot this))
            type)
           type))
  (type [_]
    type)
  
  LocalVariableSlot
  (allocated-slot [_]
    slot))

;;; ------------------------------------------------------------------------

(defn process-functions! ^void [^ArrayList segment-elements
                                ^ArrayList pending-functions]
  (doseq [^FnLiteral fn-literal pending-functions
          :when (nil? (aget (.arity-redirections fn-literal) 0))]
    (.add segment-elements
          (^ClassElementEmitter fn [cb]
           (let [at (aget (.arity-types fn-literal) 0)
                 body (aget (.arity-bodies fn-literal) 0)
                 mnm (str (.mangled-name fn-literal) "~" (.parameter-count at))
                 mtd (model/mtd-of-arity-type at)]
             (classfile/with-method-body-> cb
               [mnm mtd classfile/acc-method-static]
               (emit/method-code body))))))
  (.clear pending-functions))

;;; ------------------------------------------------------------------------

(defn- arg-types ^Class/1 [^Insn/1 args]
  (let [a (new Class/1 (alength args))]
    (dotimes [i (alength a)]
      (aset a i (expr-type args i)))
    a))

(def ^:private empty-insn-array (new Insn/1 0))

(deftype ExprFactoryImpl [^ArrayList segment-elements ;shared with NmspBuilder
                          ^ArrayList pending-functions ;shared with NmspBuilder
                          ^Class class-static-fn]
  ExprFactory
  (new-array [_ n]
    (if (zero? n) empty-insn-array (new Insn/1 n)))
  (empty [_]
    empty-insn)
  (line-number [_ line insn]
    (cond-> insn (some? line) (with-line-number ^int line)))
  (progn [_ xs]
    (progn xs))
  (new-constant [_ expr-type value]
    (Insn. (ConstantImpl. expr-type value) expr-type))
  
  (new-def-init [_ nmsp nm init]
    (let [init ^Insn init]
      (.add segment-elements
            (^ClassElementEmitter fn [cb]
             (let [opnd-type (logical-type init)
                   mtd (MethodTypeDesc/of (reflect/describe-class opnd-type))]
               (classfile/with-method-body-> cb
                 [nm mtd classfile/acc-method-static]
                 (emit/method-code init)))))
      empty-insn))
  (new-def-alias [_ nmsp nm other]
    (assert false))

  (new-parameter [_ param-no name type]
    (Insn. (ParameterImpl. param-no name type -1) Void/TYPE))
  (new-function [this fn-literal]
    ;; overwrite any auto-return-marker return types
    (let [ats (.arity-types fn-literal)]
      (dotimes [i (alength ats)]
        (let [at (aget ats i)]
          (when (type/auto-return-marker? (.return-type at))
            (let [body (aget (.arity-bodies fn-literal) i)]
              (aset ats i (.with-return-type at (logical-type body))))))))
    
    (.add pending-functions fn-literal)
    (let [owner (ClassDesc/of "pkg.ns0._10")]
      (.new-constant this class-static-fn
                     (methodgen/static-fn-desc owner fn-literal))))
  
  (invoke-constructor [_ owner args]
    (let [args ^Insn/1 args
          ms (resolve/members-by-param-tags false owner "new" (arg-types args))]
      (assert (= (count ms) 1))
      (invoke owner (first ms) nil args)))
  (invoke-static-member [_ invoke-member-of-field? owner mnm args]
    (let [args ^Insn/1 args
          ms (resolve/members-by-param-tags false owner mnm (arg-types args))]
      (assert (= (count ms) 1))
      (let [m (first ms)
            insn (invoke owner m nil args)]
        (if (and invoke-member-of-field? (instance? java.lang.reflect.Field m))
          (assert false)
          insn))))
  (invoke-virtual-member [_ receiver mnm args]
    (let [args ^Insn/1 args
          owner (expr-type receiver)
          ms (resolve/members-by-param-tags true owner mnm (arg-types args))]
      (assert (= (count ms) 1))
      (let [m (first ms)]
        (invoke owner m receiver args))))
  
  (mk-expr [_ form]
    (throw (UnsupportedOperationException. (str form)))))

(defn mk-code-generator ^ExprFactory [^ArrayList segment-elements
                                      ^ArrayList pending-functions
                                      ^Class class-static-fn]
  (ExprFactoryImpl. segment-elements pending-functions class-static-fn))
