(ns tcljx.classgen.codegen
  (:require
   (tcljx.data [config :as cfg] [wrong :as wrong] [type :as type]
               [model :as model] [resolve :as resolve] [reflect :as reflect])
   (tcljx.classgen [classfile :as classfile] [runtime :as rt] [emit :as emit]
                   [segmgen :as segmgen] [methodgen :as methodgen]))
  (:import
   (tcljx.data.model Expr Exprs ExprFactory CodeEmitter Entity Parameter Constant
                     FnLiteral NamespaceBuilder)
   (tcljx.data.resolve Match)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc ConstantDescs)
   (java.lang.reflect Member Constructor Field)
   (java.util ArrayList)
   (java.util.function Consumer)))

(definterface ClassElementEmitter
  (emit-class-element ^void [^ClassBuilder cb]))
(defn class-element-emitter? ^boolean [x]
  (instance? ClassElementEmitter x))
(defn emit-class-element ^CodeBuilder [^ClassBuilder cb ^ClassElementEmitter cee]
  (.emit-class-element cee cb))

;;; The code generator's implementation of Expr.  The class in
;;; `expr-type` is the Clojure(!) type of the expression after parsing
;;; it in isolation.  Phrased differently, it is the expression's own
;;; idea of its type in terms of Clojure's type system, disregarding
;;; the context in which it appears.  By design, an Insn instance does
;;; not expose the internal structure of a non-constant expression.
;;; Only constants are discoverable, enabling bottom up constant
;;; folding while building the expression tree.
(deftype Insn [^CodeEmitter emitter
               ^Class expr-type]
  ;; FIXME... Valhalla value?
  java.lang.Record
  Expr
  (entity [_]
    (when (instance? Entity emitter)
      emitter)))

(def insn-empty (Insn. (^CodeEmitter fn [xb requested-type line] Void/TYPE)
                       type/polymorphic))

;;; Compilation centers around arrays of types and arrays of code
;;; emitters.  For a sequence of forms, the parser vie ExprFactory
;;; creates an instance of Insns: an array of code emitters and the
;;; array with the emitters' (context free) expression types.  Using
;;; method invocation as a generic example, the expression types are
;;; then matched against JVM level parameter types to which they will
;;; be passed.  This is the second kind of array of types, the
;;; requested JVM level operand types.  When producing the bytecode
;;; instructions, each of the emitters is called and, if necessary,
;;; its operand type is adjusted to match the requested operand type.
(deftype Insns [^CodeEmitter/1 emitters ^Class/1 expr-types]
  ;; FIXME... Valhalla value?
  java.lang.Record
  Exprs
  (length [_]
    (alength emitters))
  (empty? [_]
    (zero? (alength emitters)))
  (set [_ i x]
    (aset emitters i (.emitter ^Insn x))
    (aset expr-types i (.expr-type ^Insn x)))
  (entity [_ i]
    (let [ce (aget emitters i)]
      (when (instance? Entity ce)
        ce))))

(defn emitter
  (^CodeEmitter [^Insn insn]
   (.emitter insn))
  (^CodeEmitter [^Insns insns ^int i]
   (aget (.emitters insns) i)))
(defn- expr-type
  (^Class [^Insn insn]
   (.expr-type insn))
  (^Class [^Insns insns ^int i]
   (aget (.expr-types insns) i)))
(defn- logical-type
  (^Class [^Insn insn]
   (type/expr-to-logical (expr-type insn)))
  (^Class [^Insns insns ^int i]
   (type/expr-to-logical (expr-type insns i))))

(def ^:private empty-insns (Insns. (new CodeEmitter/1 0) (new Class/1 0)))


(defn emit-opnd-logical ^CodeBuilder [^CodeBuilder xb ^Insn insn]
  (emit/opnd xb cfg/no-line-number (logical-type insn) (.emitter insn)))

(defn- with-line-number ^Insn [^Insn insn ^int line]
  (Insn. (^CodeEmitter fn [xb _ requested-type]
          (when (emit/opnd xb line requested-type (.emitter insn))
            requested-type))
         (expr-type insn)))

(deftype ConstantImpl [^Class type ^Object const-value]
  java.lang.Record
  Constant
  (emit-opnd* [_ xb line requested-type]
    (.loadConstant xb (if (instance? ConstantDesc const-value)
                        ^ConstantDesc const-value
                        (reflect/describe const-value)))
    type))

(def insn-null (Insn. (ConstantImpl. type/poly-reference ConstantDescs/NULL)
                      type/poly-reference))
(def insn-true (Insn. (ConstantImpl. Boolean/TYPE 1)
                      Boolean/TYPE))
(def insn-false (Insn. (ConstantImpl. Boolean/TYPE 0)
                       Boolean/TYPE))

(defn- progn ^Insn [^Insns insns ^Insn insn] ;`insns` should not be empty
  (let [ces (.emitters insns), ce (.emitter insn)]
    (Insn. (^CodeEmitter fn [xb line requested-type]
            (when (some-> xb
                          (emit/opnds-of-type line Void/TYPE ces)
                          (emit/opnd line requested-type ce))
              requested-type))
           (expr-type insn))))

(defn- identity ^Insn [^Class expr-type ^CodeEmitter ce]
  (Insn. (^CodeEmitter fn [xb line requested-type]
          (when (emit/opnd xb line expr-type ce)
            expr-type))
         expr-type))

(defn- emit-new-array ^CodeBuilder [^CodeBuilder xb ^Class component-type
                                    ^int length]
  (.loadConstant xb length)
  (if (.isPrimitive component-type)
    (.newarray xb (TypeKind/from component-type))
    (.anewarray xb (reflect/describe-class component-type))))

(defn- emit-array-of-more? ^CodeBuilder [^CodeBuilder xb ^Class component-type
                                         ^CodeEmitter/1 ces ^int start]
  (let [end (alength ces)
        component-tk (TypeKind/from component-type)]
    (emit-new-array xb component-type (- end start))
    (loop [i start]
      (if (< i end)
        (when (some->
               (-> (.dup xb)
                   (.loadConstant (- i start))
                   (emit/opnd cfg/no-line-number component-type (aget ces i)))
               (.arrayStore component-tk))
          (recur (inc i)))
        xb))))

(defn- invoke ^Insn [^Class owner ^Match m ^Insn receiver ^Insns args]
  (-> (^CodeEmitter fn [xb line requested-type]
       (letfn [(emit-varargs? ^CodeBuilder [^CodeBuilder xb ^Class varargs-tp
                                            ^int start]
                 (if (= (.invocation-mode m) resolve/invoke-tail-into-array)
                   (emit-array-of-more? xb (.getComponentType varargs-tp)
                                        (.emitters args) start)
                   (assert false)))]
         (let [fixed (resolve/end-of-fixed-parameters m)
               varargs-tp (resolve/varargs-parameter-type m)]
           (some->
            xb
            ;; new-dup-dance when creating a new instance of `owner`
            (cond-> (instance? Constructor (.member m))
              (-> (.new_ (reflect/describe-class owner)) (.dup)))
            ;; instance field or method require receiver argument
            (cond-> (some? receiver)
              (emit-opnd-logical receiver))
            ;; all fixed (i.e. non-vararg) arguments
            (emit/typed-opnds line (.parameter-types m)
                                  (.emitters args) 0 fixed)
            ;; optionally: all vararg arguments
            (cond-> (some? varargs-tp)
              (emit-varargs? varargs-tp fixed))
            ;; the actual invoke instruction
            (-> (.lineNumber line) (reflect/invoke-member owner (.member m)))))
         (.return-type m)))
      (Insn. (.return-type m))))

;;; ------------------------------------------------------------------------

;;; Helper function for the local variable protocol.  When a method's
;;; code attribute is produced, the Binding is established first: its
;;; `emit-opnd` sets a private mutable field to the allocated slot
;;; value.  The binding's `bound-value` method returns an Insn whose
;;; own `emit-opnd` closes over the Binding instance (not the mutable
;;; slot value in the mutable field!), allowing it to retrieve the
;;; previously stored value via `allocated-slot`.  Initializiation
;;; should set the undefined slot value to -1.
(definterface LocalVariableSlot
  (allocated-slot ^int []))

(deftype ParameterImpl [^int param-no ^String name ^Class type
                        ^:unsynchronized-mutable ^int slot]
  Parameter
  (emit-opnd* [this xb line requested-type]
    (set! slot (.parameterSlot xb param-no))
    (.localVariable xb slot name (reflect/describe-class type)
                    (.startLabel xb) (.endLabel xb))
    Void/TYPE)
  (name [_]
    name)
  (namespace [_]
    nil)
  (init [_]
    nil)
  (bound-value [this]
    (Insn. (^CodeEmitter fn [xb line requested-type]
            (.loadLocal xb (TypeKind/from type) (.allocated-slot this))
            type)
           type))
  (type [_]
    type)
  
  LocalVariableSlot
  (allocated-slot [_]
    slot))

;;; ------------------------------------------------------------------------

(defn process-functions! ^void [^ArrayList segment-elements
                                ^ArrayList pending-functions]
  (doseq [^FnLiteral fn-literal pending-functions
          :when (nil? (aget (.arity-redirections fn-literal) 0))]
    (.add segment-elements
          (^ClassElementEmitter fn [cb]
           (let [at (aget (.arity-types fn-literal) 0)
                 ce-body (emitter (.arity-bodies fn-literal) 0)
                 mnm (str (.mangled-name fn-literal) "~" (.parameter-count at))
                 mtd (model/mtd-of-arity-type at)]
             (classfile/with-method-body-> cb
               [mnm mtd classfile/acc-method-static]
               (emit/method-return ce-body))))))
  (.clear pending-functions))

;;; ------------------------------------------------------------------------

(defn- pick-match ^Match [^seq ms]
  (when (nil? (next ms))
    (first ms)))

(defn- info-unresolved-member ^Throwable [^seq ms ^Class owner ^String mnm
                                          ^Insns args ^String label]
  ;; label is one of "static", "virtual", or "constructor"
  (let [entity (str label (when (not= label "constructor")
                            (if (.empty? args) " member" " method")))
        mnm (cond->> mnm (= label "virtual") (str "."))
        member (wrong/q-as-symbol owner mnm)]
    (wrong/wr-info (if (nil? (seq ms))
                     (str "no " entity " matching " member)
                     (str "multiple " entity "s matching " member)))))

;;; ------------------------------------------------------------------------

(deftype ExprFactoryImpl [^ArrayList segment-elements ;shared with NmspBuilder
                          ^ArrayList pending-functions ;shared with NmspBuilder
                          ^Class class-static-fn]
  ExprFactory
  (empty-expr [_]
    insn-empty)
  (new-exprs [_ n]
    (if (zero? n)
      empty-insns
      (Insns. (new CodeEmitter/1 n) (new Class/1 n))))
  (progn-expr [_ xs x]
    (if (zero? (.length xs)) x (progn xs x)))
  
  (line-number [_ line insn]
    (cond-> insn ;preserve visibility of constant `insn` by not wrapping it
      (and (some? line) (not (model/const? insn)))
      (with-line-number ^int line)))
  (new-constant [_ expr-type value]
    #_(prn :new-constant expr-type value)
    (java.util.Objects/requireNonNull value)
    (cond
      (identical? ConstantDescs/NULL value)
      insn-null
      
      (type/same? Boolean/TYPE expr-type)
      (if ^boolean value insn-true insn-false) ;enforce singletons
      
      :else (Insn. (ConstantImpl. expr-type value) expr-type)))
  
  (new-def-init [_ nmsp nm init]
    (let [init ^Insn init]
      (.add segment-elements
            (^ClassElementEmitter fn [cb]
             (let [opnd-type (logical-type init)
                   mtd (MethodTypeDesc/of (reflect/describe-class opnd-type))]
               (classfile/with-method-body-> cb
                 [nm mtd classfile/acc-method-static]
                 (emit/method-return (.emitter ^Insn init))))))
      insn-empty))
  (new-def-alias [_ nmsp nm other]
    (assert false))

  (new-parameter [_ param-no name type]
    (Insn. (ParameterImpl. param-no name type -1) Void/TYPE))
  (new-function [this fn-literal]
    ;; overwrite any auto-return-marker return types and adjust their
    ;; body Insn to match the new type
    (let [ats (.arity-types fn-literal)
          bodies ^Insns (.arity-bodies fn-literal)]
      (dotimes [i (alength ats)]
        (let [at (aget ats i)]
          (when (type/auto-return-marker? (.return-type at))
            (let [body-tp (logical-type bodies i)
                  logical-tp (if (type/polymorphic? body-tp)
                               Void/TYPE
                               body-tp)
                  body-emitter (emitter bodies i)]
              (aset ats i (.with-return-type at logical-tp))
              (.set bodies i (identity logical-tp body-emitter)))))))
    
    (.add pending-functions fn-literal)
    (let [owner (ClassDesc/of "pkg.ns0._10")]
      (.new-constant this class-static-fn
                     (methodgen/static-fn-desc owner fn-literal))))
  
  (invoke-constructor [_ owner args]
    (let [args ^Insns args
          mnm resolve/constructor-name
          ms (resolve/members-by-arg-types false owner mnm (.expr-types args))]
      (if-some [m (pick-match ms)]
        (invoke owner m nil args)
        (throw (info-unresolved-member ms owner mnm args "constructor")))))
  (invoke-static-member [_ invoke-member-if-field? owner mnm args]
    (let [args ^Insns args
          ms (resolve/members-by-arg-types true owner mnm (.expr-types args))]
      ;; (prn :et (seq (.expr-types args)))
      ;; (prn :ms (seq ms))
      ;; (prn :invoke-member-if-field? invoke-member-if-field?)
      (if-some [m (pick-match ms)]
        (let [insn (invoke owner m nil args)]
          (if (and invoke-member-if-field? (instance? Field (.member m)))
            (assert false "not yet implemented")
            insn))
        (throw (info-unresolved-member ms owner mnm args "static")))))
  (invoke-virtual-member [_ receiver mnm args]
    (let [args ^Insns args
          owner (expr-type receiver)
          ms (resolve/members-by-arg-types false owner mnm (.expr-types args))]
      #_(prn :et (seq (.expr-types args)))
      #_(prn :ms (seq ms))
      (if-some [m (pick-match ms)]
        (invoke owner m receiver args)
        (throw (info-unresolved-member ms owner mnm args "virtual")))))

  (get-static-field [_ owner mnm]
    (let [args empty-insns
          ms (resolve/field-exact nil true owner mnm resolve/empty-class-array)]
      (if-some [m (pick-match ms)]
        (invoke owner m nil args)
        (throw (info-unresolved-member ms owner mnm args "static")))))
  
  (mk-expr [_ form]
    (throw (UnsupportedOperationException. (str form)))))

(defn mk-code-generator ^ExprFactory [^ArrayList segment-elements
                                      ^ArrayList pending-functions
                                      ^Class class-static-fn]
  (ExprFactoryImpl. segment-elements pending-functions class-static-fn))
