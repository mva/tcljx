(ns tcljx.classgen.codegen
  (:require
   (tcljx [config :as cfg] [model :as model])
   (tcljx.classgen [classfile :as classfile] [runtime :as rt]
                   [resolve :as resolve] [reflect :as reflect]
                   [segmgen :as segmgen] [methodgen :as methodgen]))
  (:import
   (tcljx.model Expr CodeEmitter Entity Parameter ExprFactory
                NamespaceBuilder)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc)
   (java.lang.reflect Member)
   (java.util ArrayList)
   (java.util.function Consumer)))

(definterface ClassElementEmitter
  (emit-class-element ^void [^ClassBuilder cb]))
(defn class-element-emitter? ^boolean [x]
  (instance? ClassElementEmitter x))
(defn emit-class-element ^CodeBuilder [^ClassBuilder cb ^ClassElementEmitter cee]
  (.emit-class-element cee cb))

;;; The code generator's implementation of Expr.  The class in
;;; `expr-type` is the Clojure(!) type of the expression after parsing
;;; it in isolation.  Phrased differently, it is the expression's own
;;; idea of its type in terms of Clojure's type system, disregarding
;;; the context in which it appears.  By design, an Insn instance does
;;; not expose the internal structure of a non-constant expression.
;;; Only constants are discoverable, enabling bottom up constant
;;; folding while building the expression tree.
(deftype Insn [^CodeEmitter emitter
               ^Class expr-type]
  ;; FIXME... Valhalla value?
  java.lang.Record
  Expr
  (entity [_]
    (when (instance? Entity emitter)
      emitter)))

(def empty-insn (Insn. (^CodeEmitter fn [xb line] Void/TYPE) Void/TYPE))

(defn emit-code
  (^CodeBuilder [^CodeBuilder xb ^Insn insn]
   (emit-code xb insn cfg/no-line-number))
  (^CodeBuilder [^CodeBuilder xb ^Insn insn ^int line]
   (.emit-code (.emitter insn) xb line)
   xb))
(defn emit-code* ^CodeBuilder [^CodeBuilder xb ^Insn/1 insns ^int line]
  (dotimes [i (alength insns)]
    (emit-code xb (aget insns i) line))
  xb)

(defn- with-line-number ^Insn [^Insn insn ^int line]
  (Insn. (^CodeEmitter fn [xb _]
          (emit-code xb insn line))
         (.expr-type insn)))

(deftype Constant [^Object value]
  CodeEmitter
  (emit-code [_ xb line]
    (.loadConstant xb ^ConstantDesc value)))
(defn const? ^boolean [^Insn insn]
  (instance? Constant (.emitter insn)))
(defn const-value ^Object [^Insn insn]  ;nil if not a constant
  (when (const? insn)
    (.value ^Constant (.emitter insn))))
(defn- constant ^Insn [^Class tp value]
  (Insn. (Constant. value) tp))

(defn- progn ^Insn [^Insn/1 insns]
  (Insn. (^CodeEmitter fn [xb line]
          (emit-code* xb insns line))
         (.expr-type (aget insns (dec (alength insns))))))

(defn- invoke ^Insn [^Class owner ^Member member ^Insn/1 args]
  (Insn. (^CodeEmitter fn [xb line]
          (-> (emit-code* xb args line)
              (.lineNumber line)
              (reflect/invoke-member owner member)))
         (reflect/invoke-member-type owner member)))

;;; ------------------------------------------------------------------------

;;; Helper function for the local variable protocol.  When a method's
;;; code attribute is produced, the Binding is established first: its
;;; `emit-code` sets a private mutable field to the allocated slot
;;; value.  The binding's `bound-value` method returns an Insn whose
;;; own `emit-code` closes over the Binding instance (not the mutable
;;; slot value in the mutable field!), allowing it to retrieve the
;;; previously stored value via `allocated-slot`.  Initializiation
;;; should set the undefined slot value to -1.
(definterface LocalVariableSlot
  (allocated-slot ^int []))

(deftype ParameterImpl [^int param-no ^String name ^Class type
                        ^:unsynchronized-mutable ^int slot]
  CodeEmitter
  (emit-code [this xb line]
    (set! slot (.parameterSlot xb param-no))
    (.localVariable xb slot name
                    (rt/describe-class type) (.startLabel xb) (.endLabel xb)))
  
  Parameter
  (name [_]
    name)
  (namespace [_]
    nil)
  (init [_]
    nil)
  (bound-value [this]
    (Insn. (^CodeEmitter fn [xb line]
            (.loadLocal xb (TypeKind/from type) (.allocated-slot this)))
           type))

  LocalVariableSlot
  (allocated-slot [_]
    slot))

;;; ------------------------------------------------------------------------

(defn- arg-types ^Class/1 [^Insn/1 args]
  (let [a (new Class/1 (alength args))]
    (dotimes [i (alength a)]
      (aset a i (.expr-type (aget args i))))
    a))

(def ^:private empty-insn-array (new Insn/1 0))

(deftype ExprFactoryImpl [^ArrayList segment-elements ;shared with NmspBuilder
                          ^Class class-static-fn]
  ExprFactory
  (new-array [_ n]
    (if (zero? n) empty-insn-array (new Insn/1 n)))
  (empty [_]
    empty-insn)
  (line-number [_ line insn]
    (cond-> insn (some? line) (with-line-number ^int line)))
  (constant [_ value]
    (constant Integer/TYPE value))
  (progn [_ xs]
    (progn xs))
  
  (new-def-init [_ nmsp nm init]
    (let [init ^Insn init]
      (.add segment-elements
            (^ClassElementEmitter fn [cb]
             (let [mtd (MethodTypeDesc/of (rt/describe-class (.expr-type init)))]
               (classfile/with-method-body-> cb
                 [nm mtd classfile/acc-method-static]
                 (-> (emit-code init) (.areturn))))))
      empty-insn))
  (new-def-alias [_ nmsp nm other]
    (assert false))

  (parameter [_ param-no name type]
    (Insn. (ParameterImpl. param-no name type -1) Void/TYPE))
  (new-function [this fn-literal]
    (.add segment-elements
          (^ClassElementEmitter fn [cb]
           (let [at (aget (.arity-types fn-literal) 0)
                 body (aget (.arity-bodies fn-literal) 0)
                 mnm (str (.mangled-name fn-literal) "~" (.parameter-count at))
                 mtd (methodgen/mtd-of-arity-type at)]
             (classfile/with-method-body-> cb
               [mnm mtd classfile/acc-method-static]
               (-> (emit-code body) (.areturn))))))
    (let [owner (ClassDesc/of "pkg.ns0._10")]
      (constant class-static-fn (methodgen/static-fn-desc owner fn-literal))))
  
  (invoke-static-member [_ owner mnm args]
    (let [args ^Insn/1 args
          ms (resolve/members false owner mnm (arg-types args))]
      (assert (= (count ms) 1))
      (assert (not (instance? java.lang.reflect.Field (first ms))))
      (invoke owner (first ms) args)))
  
  (mk-expr [_ form]
    nil))

(defn mk-code-generator ^ExprFactory [^ArrayList segment-elements
                                      ^Class class-static-fn]
  (ExprFactoryImpl. segment-elements class-static-fn))
