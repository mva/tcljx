(ns tcljx.classgen.codegen
  (:require
   (tcljx.data [config :as cfg] [wrong :as wrong] [type :as type]
               [model :as model] [resolve :as resolve] [reflect :as reflect])
   (tcljx.classgen [classfile :as classfile] [runtime :as rt] [emit :as emit]
                   [insn :as insn] [entity :as entity]
                   [segmgen :as segmgen] [methodgen :as methodgen]))
  (:import
   (tcljx.data.model Expr Exprs ExprFactory CodeEmitter ArityType
                     NamespaceBuilder)
   (tcljx.data.resolve Match)
   (tcljx.classgen.insn Insn Insns)
   (tcljx.classgen.methodgen FnLiteral)
   (java.lang.classfile ClassBuilder CodeBuilder Opcode)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc MethodHandleDesc
                       ConstantDescs)
   (java.lang.reflect Member Constructor Field)
   (java.util ArrayList)
   (java.util.function Consumer)))

(letfn [(find-factory ^Match [^String method-name]
          (resolve/runtime-method tinyclj.lang.Literal method-name
                                  (doto (new Class/1 1) (aset 0 Object/1))))]
  (def ^:private literal-vector (find-factory "vector")) ;type/vector
  (def ^:private literal-map (find-factory "map"))       ;type/map
  (def ^:private literal-set (find-factory "set"))       ;type/set
  (def ^:private literal-list (find-factory "list")))    ;type/list

(definterface ClassElementEmitter
  (emit-class-element ^void [^ClassBuilder cb]))
(defn class-element-emitter? ^boolean [x]
  (instance? ClassElementEmitter x))
(defn emit-class-element ^CodeBuilder [^ClassBuilder cb ^ClassElementEmitter cee]
  (.emit-class-element cee cb))


(defn- with-line-number ^Insn [^Insn insn ^int line]
  (insn/mk-insn (^CodeEmitter fn [xb _ requested-type]
                 (when (emit/insn? xb line requested-type (.emitter insn))
                   requested-type))
                (insn/expr-type insn)))

;;; ------------------------------------------------------------------------

(defn process-functions! ^void [^ArrayList segment-elements
                                ^ArrayList pending-functions]
  (doseq [^FnLiteral fn-literal pending-functions
          :when (nil? (aget (.arity-redirections fn-literal) 0))]
    (.add segment-elements
          (^ClassElementEmitter fn [cb]
           (let [at (aget (.arity-types fn-literal) 0)
                 mnm (str (.mangled-name fn-literal) "~" (.parameter-count at))
                 mtd (model/mtd-of-arity-type at)]
             (classfile/with-method-body-> cb
               [mnm mtd classfile/acc-method-static]
               ;; pick up any fixed auto-return-type
               (insn/emit-return (.return-type at)
                                 (.get (.arity-bodies fn-literal) 0)))))))
  (.clear pending-functions))

;;; ------------------------------------------------------------------------

(defn- invoke-single-match ^Insn [^seq ms ^Insn receiver ^Insns args]
  (when (nil? (next ms))
    (when-some [m (first ms)]
      (insn/invoke-member m receiver args))))

(defn- info-unresolved-member ^Throwable [^seq ms ^Class owner ^String mnm
                                          ^Insns args ^String label]
  ;; label is one of "static", "virtual", or "constructor"
  (let [entity (str label (when (not= label "constructor")
                            (if (.empty? args) " member" " method")))
        mnm (cond->> mnm (= label "virtual") (str "."))
        member (wrong/q-as-symbol owner mnm)]
    (wrong/wr-info (if (nil? (seq ms))
                     (str "no " entity " matching " member)
                     (str "multiple " entity "s matching " member)))))

;;; This indicates an error regarding the type *of* an expression.
(defn info-type
  (^Throwable [^String msg-prefix ^Expr x]
   (info-type msg-prefix x (insn/expr-type x)))
  (^Throwable [^String msg-prefix ^Expr x ^Class tp]
   (wrong/wr-info (str msg-prefix (wrong/got-type tp)))))

(defn ensure-assignable ^void [^Class target-type ^Class arg-type]
  (when-not (type/assignable-from? target-type arg-type)
    (throw (info-type (str "cannot assign to " (wrong/q target-type)
                           #_(when (some? dest-descr)
                               (str " of " (wrong/q-symbol dest-descr))))
                      nil arg-type))))

;;; ------------------------------------------------------------------------


;;; Note: To save work, this code generator assumes that it can use
;;; types available at compile time to refer to runtime types of the
;;; compiled application.  For example, it uses tinyclj.lang.StaticFn
;;; as expression type, instead of the type (currently of the same
;;; name) used by the application to hold a static function instance.
;;; Likewise for symbols, keywords, vectors, and so on.  This works
;;; only as long as compiler and application agree on the names of
;;; their runtime classes.
(deftype ExprFactoryImpl [^ArrayList segment-elements ;shared with NmspBuilder
                          ^ArrayList pending-functions ;shared with NmspBuilder
                          ]
  ExprFactory
  (empty-expr [_]
    insn/insn-empty)
  (new-exprs [_ n]
    (if (zero? n)
      insn/empty-insns
      (Insns. (new CodeEmitter/1 n) (new Class/1 n))))
  (line-number [_ line insn]
    (cond-> insn ;preserve visibility of constant `insn` by not wrapping it
      (and (some? line) (not (model/const? insn)))
      (with-line-number ^int line)))
  
  (new-constant [_ expr-type value]
    (entity/new-constant expr-type value))

  (attach-meta-to [_ meta arg]
    (assert false))
  (new-vector [this args]
    (let [args ^Insns args]
      (if (entity/constants? args)
        (->> (entity/as-typed-constants args)
             (vec)
             (.new-constant this type/vector))
        (insn/invoke-member literal-vector nil args))))
  (new-map [this args]
    (let [args ^Insns args]
      (if (entity/constants? args)
        (->> (entity/as-typed-constants args)
             (apply array-map)
             (.new-constant this type/map))
        (insn/invoke-member literal-map nil args))))
  (new-set [this args]
    (let [args ^Insns args]
      (if (entity/constants? args)
        (->> (entity/as-typed-constants args)
             (set)
             (.new-constant this type/set))
        (insn/invoke-member literal-set nil args))))
  (new-list [this args]
    (let [args ^Insns args]
      (if (entity/constants? args)
        (.new-constant this type/list (-> (entity/as-typed-constants args)
                                          (seq)
                                          (or ())))
        (insn/invoke-member literal-list nil args))))

  (progn-expr [_ xs x]
    (insn/progn xs x))
  
  (invoke [this form inv args]
    (.invoke* inv form args))
  
  (new-def-init [this nmsp nm init]
    (let [init ^Insn init]
      (.add segment-elements
            (^ClassElementEmitter fn [cb]
             (let [opnd-type (insn/logical-type init)
                   mtd (MethodTypeDesc/of (reflect/describe-class opnd-type))]
               (classfile/with-method-body-> cb
                 [nm mtd classfile/acc-method-static]
                 (insn/emit-return opnd-type init)))))
      insn/insn-empty))
  (new-def-alias [_ nmsp nm other]
    (assert false))

  (new-parameter [_ param-no name type]
    (Insn. (entity/mk-parameter param-no name type) Void/TYPE))
  (new-local [_ name init]
    (insn/mk-insn (entity/mk-local name init) Void/TYPE))
  (block-let [_ bindings body]
    (let [block (insn/progn bindings body)]
      (-> (^CodeEmitter fn [xb line requested-type]
           (.block xb (^Consumer fn ^void [^CodeBuilder xb]
                       (emit/insn? xb line requested-type (.emitter block))))
           requested-type) ;cannot report back `leaving` if insn? is false
          (insn/mk-insn (insn/expr-type block)))))
  
  (new-function [this mangled-name arity-types arity-bodies arity-redirections]
    ;; update body expressions to match return types and overwrite any
    ;; auto-return-marker return types
    (dotimes [i (alength arity-types)]
      (let [at (aget arity-types i)]
        (if (type/auto-return-marker? (.return-type at))
          (let [expr-tp (insn/expr-type arity-bodies i)
                logical-tp (type/expr-to-logical expr-tp)]
            (aset arity-types i (.with-return-type at logical-tp)))
          (ensure-assignable (.return-type at)
                             (insn/expr-type arity-bodies i)))))
    
    (let [fn-literal (FnLiteral. mangled-name arity-types
                                 arity-bodies arity-redirections)]
      (.add pending-functions fn-literal)
      (let [owner (ClassDesc/of "pkg.ns0._10")]
        (.new-constant this tinyclj.lang.StaticFn
                       (methodgen/static-fn-desc owner fn-literal)))))
  
  (type-cast [this target-type arg]
    (let [arg-tp (insn/expr-type arg)]
      (letfn [(wr-info-invalid-cast ^Throwable []
                (wrong/wr-info (str "cannot cast to " (wrong/q-type target-type)
                                    (wrong/got-type arg-tp))))
              (checkcast ^Insn [^Class ref-target ^Insn ref-arg]
                (let [arg-tp (insn/expr-type ref-arg)]
                  (if (or (.isAssignableFrom ref-target arg-tp) ;empty
                          (.isAssignableFrom arg-tp ref-target)) ;checkcast
                    (insn/cast-into ref-target ref-arg)
                    (throw (wr-info-invalid-cast)))))
              (box-arg-into ^Insn [^Class prim-tp]
                (insn/cast-into (.class-reference (type/of prim-tp)) arg))]
        (cond
          (type/same? target-type arg-tp)
          arg
          
          (or (type/polymorphic? target-type) ;force void context
              (type/polymorphic? arg-tp))
          (insn/cast-into target-type arg)

          (.isPrimitive target-type)
          (if (.isPrimitive arg-tp)
            (throw (wr-info-invalid-cast)) ;no cast between different primitives
            (checkcast arg-tp (box-arg-into target-type)))
          
          ;; here holds: `target-type` is reference
          (.isPrimitive arg-tp)
          (checkcast target-type (box-arg-into arg-tp))
          
          ;; here holds: both `target-type` and `arg-tp` are reference
          :else (checkcast target-type arg)))))
  (invoke-constructor [_ owner args]
    (let [args ^Insns args
          mnm resolve/constructor-name
          ms (resolve/members-by-arg-types false owner mnm (.expr-types args))]
      (or (invoke-single-match ms nil args)
          (throw (info-unresolved-member ms owner mnm args "constructor")))))
  (invoke-static-member [_ invoke-member-if-field? owner mnm args]
    (let [args ^Insns args
          ms (resolve/members-by-arg-types true owner mnm (.expr-types args))]
      ;; (prn :et (seq (.expr-types args)))
      ;; (prn :ms (seq ms))
      ;; (prn :invoke-member-if-field? invoke-member-if-field?)
      (or (when-some [insn (invoke-single-match ms nil args)]
            (if (and invoke-member-if-field?
                     (instance? Field (.member ^Match (first ms))))
              (assert false "not yet implemented")
              insn))
          (throw (info-unresolved-member ms owner mnm args "static")))))
  (invoke-virtual-member [_ receiver mnm args]
    (let [receiver ^Insn receiver
          args ^Insns args
          owner (insn/expr-type receiver)
          ms (resolve/members-by-arg-types false owner mnm
                                           (.expr-types args))]
      #_(prn :et (seq (.expr-types args)))
      #_(prn :ms (seq ms))
      (or (invoke-single-match ms receiver args)
          (throw (info-unresolved-member ms owner mnm args "virtual")))))

  (get-static-field [_ owner mnm]
    (let [args insn/empty-insns
          ms (resolve/field-exact nil true owner mnm resolve/empty-class-array)]
      (or (invoke-single-match ms nil args)
          (throw (info-unresolved-member ms owner mnm args "static")))))

  (throw-expr [_ arg]
    (let [arg ^Insn arg]
      (if (.isAssignableFrom Throwable (insn/logical-type arg))
        (-> (^CodeEmitter fn [xb line requested-type]
             (when (emit/insn? xb line Throwable (.emitter arg))
               (-> xb (.lineNumber line) (.athrow))
               emit/leaving))         ;type seen by the code generator
            (insn/mk-insn Void/TYPE)) ;type seen by the parser
        (throw (info-type "expect instance of Throwable" arg)))))
  
  (mk-expr [_ form]
    (throw (UnsupportedOperationException. (str form)))))

(defn mk-code-generator ^ExprFactory [^ArrayList segment-elements
                                      ^ArrayList pending-functions]
  (ExprFactoryImpl. segment-elements pending-functions))
