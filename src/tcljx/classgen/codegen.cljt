(ns tcljx.classgen.codegen
  (:require
   (tcljx.data
    [config :as cfg] [wrong :as wrong] [context :as context] [type :as type]
    [model :as model] [resolve :as resolve] [reflect :as reflect])
   (tcljx.classgen
    [classfile :as classfile] [runtime :as rt] [emit :as emit] [insn :as insn]
    [entity :as entity] [condgen :as condgen] [switchgen :as switchgen]
    [trygen :as trygen] [defgen :as defgen]
    [segmgen :as segmgen] [methodgen :as methodgen]))
  (:import
   (tcljx.data.model Expr Exprs ExprFactory CodeEmitter ArityType
                     NamespaceBuilder)
   (tcljx.data.resolve Match)
   (tcljx.classgen.classfile ClassElementEmitter)
   (tcljx.classgen.insn Insn Insns)
   (tcljx.classgen.methodgen FnLiteral)
   (java.lang.classfile ClassBuilder CodeBuilder Opcode TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc MethodHandleDesc
                       ConstantDescs)
   (java.lang.reflect Member Constructor Field)
   (java.util ArrayList)
   (java.util.function Consumer)))

(letfn [(find-factory ^Match [^String method-name]
          (resolve/runtime-method tinyclj.lang.Literal method-name
                                  (doto (new Class/1 1) (aset 0 Object/1))))]
  (def ^:private literal-vector (find-factory "vector")) ;type/vector
  (def ^:private literal-map (find-factory "map"))       ;type/map
  (def ^:private literal-set (find-factory "set"))       ;type/set
  (def ^:private literal-list (find-factory "list"))     ;type/list
  (def ^:private literal-with-meta
    (resolve/runtime-method tinyclj.lang.Literal "with_meta"
                            (doto (new Class/1 2)
                              (aset 0 clojure.lang.IObj)
                              (aset 1 clojure.lang.IPersistentMap)))))

;;; ------------------------------------------------------------------------

(defn process-functions! ^void [^ArrayList segment-elements
                                ^ArrayList pending-functions]
  (doseq [^FnLiteral fn-literal pending-functions
          :when (nil? (aget (.arity-redirections fn-literal) 0))]
    (.add segment-elements
          (^ClassElementEmitter fn [cb]
           (let [at (aget (.arity-types fn-literal) 0)
                 mnm (str (.mangled-name fn-literal) "~" (.parameter-count at))
                 mtd (model/mtd-of-arity-type at)]
             (classfile/with-method-body-> cb
               [mnm mtd classfile/acc-method-static]
               ;; pick up any fixed auto-return-type
               (insn/emit-return (.return-type at)
                                 (.get (.arity-bodies fn-literal) 0)))))))
  (.clear pending-functions))

;;; ------------------------------------------------------------------------

(defn- invoke-single-match ^Insn [^seq ms ^Insn receiver ^Insns args ^long fctx]
  (when (nil? (next ms))
    (when-some [m (first ms)]
      (insn/invoke-member m receiver args fctx))))

(defn- info-unresolved-member ^Throwable [^seq ms ^Class owner ^String mnm
                                          ^Insns args ^String label]
  ;; label is one of "static", "virtual", or "constructor"
  (let [entity (str label (when (not= label "constructor")
                            (if (.empty? args) " member" " method")))
        mnm (cond->> mnm (= label "virtual") (str "."))
        member (wrong/q-as-symbol owner mnm)]
    (wrong/wr-info (if (nil? (seq ms))
                     (str "no " entity " matching " member)
                     (str "multiple " entity "s matching " member)))))

;;; ------------------------------------------------------------------------

;;; Note: To save work, this code generator assumes that it can use
;;; types available at compile time to refer to runtime types of the
;;; compiled application.  For example, it uses tinyclj.lang.StaticFn
;;; as expression type, instead of the type (currently of the same
;;; name) used by the application to hold a static function instance.
;;; Likewise for symbols, keywords, vectors, and so on.  This works
;;; only as long as compiler and application agree on the names of
;;; their runtime classes.
(deftype ExprFactoryImpl [^ArrayList pending-functions ;shared with NmspBuilder
                          ]
  ExprFactory
  (empty-expr [_]
    insn/insn-empty)
  (new-exprs [_ n]
    (if (zero? n)
      insn/empty-insns
      (Insns. (new CodeEmitter/1 n) (new Class/1 n))))
  
  (new-constant [_ expr-type value]
    (entity/new-constant value expr-type))
  (new-loadable [_ expr-type value]
    (-> value (entity/mk-loadable expr-type false) (insn/mk-insn expr-type)))

  (attach-meta-to [this meta arg]
    (if (and (model/loadable? arg) (model/loadable? meta))
      (let [tp (insn/expr-type arg)]
        (-> (doto (new CodeEmitter/1 2)
              (aset 0 (.emitter arg))
              (aset 1 (.emitter meta)))
            (entity/mk-loadable tp true)
            (insn/mk-insn tp)))
      (insn/invoke-runtime literal-with-meta (insn/insns-of arg meta))))
  (new-vector [this args]
    (let [args ^Insns args]
      (if (entity/loadables? args)
        (.new-loadable this type/vector (.emitters args))
        (insn/invoke-runtime literal-vector args))))
  (new-map [this args]
    (let [args ^Insns args]
      (if (entity/loadables? args)
        (.new-loadable this type/map (.emitters args))
        (insn/invoke-runtime literal-map args))))
  (new-set [this args]
    (let [args ^Insns args]
      (if (entity/loadables? args)
        (.new-loadable this type/set (.emitters args))
        (insn/invoke-runtime literal-set args))))
  (new-list [this args]
    (let [args ^Insns args]
      (if (entity/loadables? args)
        (.new-loadable this type/list (.emitters args))
        (insn/invoke-runtime literal-list args))))
  (new-array [_ fctx array-type dims]
    (let [dims ^Insns dims]
      (dotimes [i (.length dims)]
        (insn/ensure-assignable Integer/TYPE dims i))
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insns? xb fctx Integer/TYPE (.emitters dims))
             (if (= (.length dims) 1)
               (let [component-type (.getComponentType array-type)]
                 (if (.isPrimitive component-type)
                   (.newarray xb (TypeKind/from component-type))
                   (.anewarray xb (reflect/describe-class component-type))))
               (.multianewarray xb (reflect/describe-class array-type)
                                (.length dims)))
             array-type))
          (insn/mk-insn array-type))))
  
  (progn-expr [_ xs x]
    (insn/progn xs x))
  (if-expr [_ fctx xs]
    (let [xs ^Insns xs
          tp (condgen/join-type (.expr-types xs) 1 (.length xs))
          ce-false (if (= (.length xs) 3)
                     (insn/emitter xs 2)
                     (.emitter insn/insn-empty))]
      (-> (.emitter (condgen/logical-truth (.get xs 0) fctx))
          (condgen/mk-if (insn/emitter xs 1) ce-false fctx)
          (insn/mk-insn tp))))
  (case-expr [this select guards paths-and-default fctx error-contexts]
    (let [select-tp (switchgen/adjust-numeric-type (insn/expr-type select))
          n-paths (.length paths-and-default)
          join-tp (-> (Insns/.expr-types paths-and-default)
                      (condgen/join-type 0 n-paths))
          default-path (if (= (alength guards) n-paths)
                         ;; Important: This evaluates the select
                         ;; expression a second time!  One possible
                         ;; idea: dup the select, consume it in the
                         ;; error path, and pop it immediately after
                         ;; the end-of-switch label.
                         (->> (switchgen/invoke-no-matching-clause select fctx)
                              (.throw-expr this fctx))
                         (.get paths-and-default (dec n-paths)))]
      (switchgen/validate-guards select-tp guards fctx error-contexts)
      (-> (if (switchgen/switch-on-int? select-tp)
            (switchgen/switch-int (.emitter select) guards
                                  (Insns/.emitters paths-and-default)
                                  (.emitter default-path) fctx)
            (switchgen/switch-map (.emitter select) guards
                                  (Insns/.emitters paths-and-default)
                                  (.emitter default-path) fctx))
          (insn/mk-insn join-tp))))
  (invoke [this fctx form inv args]
    (.invoke* inv fctx form args))
  
  (new-parameter [_ param-no name type]
    (Insn. (entity/parameter-binding param-no name type) Void/TYPE))
  
  (new-local [_ fctx opt-type name init-or-binding]
    (when opt-type    ;presence of type tag means this is not an alias
      (insn/ensure-assignable opt-type init-or-binding))
    (-> (entity/local-binding opt-type name init-or-binding fctx)
        (insn/mk-insn Void/TYPE)))
  (block-let [_ fctx bindings body]
    (let [block (insn/progn bindings body)]
      (-> (^CodeEmitter fn [xb consumed-type then-leave?]
           ;; FIXME... emit lineNumber here?
           (.block xb (^Consumer fn ^void [^CodeBuilder xb]
                       ;; FIXME... or emit lineNumber here?
                       (emit/then-leave? xb fctx consumed-type
                                         (.emitter block) then-leave?)))
           (when-not then-leave? ;can the then-leave? above return true?
             consumed-type))
          (insn/mk-insn (insn/expr-type block)))))
  
  (new-catching-local [_ fctx type name]
    (let [ex-provider (insn/mk-insn (^CodeEmitter fn [_ _ _] type) type)]
      (-> (entity/local-binding type name ex-provider fctx)
          (insn/mk-insn Void/TYPE))))
  (try-catch-finally [_ fctx body+catches catch-types finally]
    (let [insns ^Insns body+catches
          tp (condgen/join-type (.expr-types insns) 0 (.length insns))]
      (-> (if (some? finally)
            (trygen/try-catch-finally (.emitters insns) catch-types
                                      (.emitter finally) fctx)
            (trygen/try-catch (.emitters insns) catch-types fctx))
          (insn/mk-insn tp))))
  
  (new-function [this mangled-name arity-types arity-bodies arity-redirections]
    ;; update body expressions to match return types and overwrite any
    ;; auto-return-marker return types
    (dotimes [i (alength arity-types)]
      (let [at (aget arity-types i)]
        (if (type/auto-return-marker? (.return-type at))
          (let [expr-tp (insn/expr-type arity-bodies i)
                logical-tp (type/expr-to-logical expr-tp)]
            (aset arity-types i (.with-return-type at logical-tp)))
          (insn/ensure-assignable (.return-type at) arity-bodies i))))
    
    (let [fn-literal (FnLiteral. mangled-name arity-types
                                 arity-bodies arity-redirections)]
      (.add pending-functions fn-literal)
      (let [owner (ClassDesc/of "pkg.ns0._10")]
        (.new-constant this tinyclj.lang.StaticFn
                       (methodgen/static-fn-desc owner fn-literal)))))
  
  (type-cast [this fctx target-type arg]
    (let [arg-tp (insn/expr-type arg)]
      (letfn [(wr-info-invalid-cast ^Throwable []
                (wrong/wr-info (str "cannot cast to " (wrong/q-type target-type)
                                    (wrong/got-type arg-tp))))
              (checkcast ^Insn [^Insn ref-arg ^Class ref-target]
                (let [arg-tp (insn/expr-type ref-arg)]
                  (if (or (.isInterface ref-target)
                          (.isAssignableFrom ref-target arg-tp) ;empty
                          (.isAssignableFrom arg-tp ref-target) ;checkcast
                          (type/poly-reference? arg-tp)) ;cast from nil
                    (insn/cast-to ref-arg ref-target fctx)
                    (throw (wr-info-invalid-cast)))))
              (boxed-arg ^Insn [^Class prim-tp]
                (insn/cast-to arg (.class-reference (type/of prim-tp))
                              context/fctx-none))]
        (cond
          (or (type/polymorphic? target-type) ;force void context
              (type/polymorphic? arg-tp))
          (-> arg (insn/cast-to target-type fctx))

          (type/same? target-type arg-tp)
          arg
          
          (.isPrimitive target-type)
          (if (.isPrimitive arg-tp)
            (throw (wr-info-invalid-cast)) ;no cast between different primitives
            (-> (boxed-arg target-type) (insn/cast-to target-type fctx)))
          
          ;; here holds: `target-type` is reference
          (.isPrimitive arg-tp)
          (-> (boxed-arg arg-tp) (checkcast target-type))
          
          ;; here holds: both `target-type` and `arg-tp` are reference
          :else (-> arg (checkcast target-type))))))
  (invoke-constructor [_ fctx owner args]
    (let [args ^Insns args
          mnm resolve/constructor-name
          ms (resolve/members-by-arg-types false owner mnm (.expr-types args))]
      (or (invoke-single-match ms nil args fctx)
          (throw (info-unresolved-member ms owner mnm args "constructor")))))
  (invoke-static-member [_ fctx invoke-member-if-field? owner mnm args]
    (let [args ^Insns args
          ms (resolve/members-by-arg-types true owner mnm (.expr-types args))]
      ;; (prn :et (seq (.expr-types args)))
      ;; (prn :ms (seq ms))
      ;; (prn :invoke-member-if-field? invoke-member-if-field?)
      (or (when-some [insn (invoke-single-match ms nil args fctx)]
            (if (and invoke-member-if-field?
                     (instance? Field (.member ^Match (first ms))))
              (assert false "not yet implemented")
              insn))
          (throw (info-unresolved-member ms owner mnm args "static")))))
  (invoke-virtual-member [_ fctx receiver mnm args]
    (let [receiver ^Insn receiver
          args ^Insns args
          owner (insn/expr-type receiver)
          ms (resolve/members-by-arg-types false owner mnm (.expr-types args))]
      (or (invoke-single-match ms receiver args fctx)
          (throw (info-unresolved-member ms owner mnm args "virtual")))))

  (get-static-field [_ fctx owner mnm]
    (let [args insn/empty-insns
          ms (resolve/field-exact nil true owner mnm resolve/empty-class-array)]
      (or (invoke-single-match ms nil args fctx)
          (throw (info-unresolved-member ms owner mnm args "static")))))
  (get-virtual-field [_ fctx receiver mnm]
    (let [receiver ^Insn receiver
          args insn/empty-insns
          owner (insn/expr-type receiver)
          ms (resolve/field-exact nil false owner mnm (.expr-types args))]
      (or (invoke-single-match ms receiver args fctx)
          (throw (wrong/wr-info (str "no virtual field matching "
                                     (wrong/q-as-symbol owner mnm)))))))

  (instanceof-expr [_ fctx type arg]
    (let [arg ^Insn arg]
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insn? xb context/fctx-none Object (.emitter arg))
             (-> (emit/with-line-number xb fctx)
                 (.instanceOf (reflect/describe-class type)))
             Boolean/TYPE))
          (insn/mk-insn Boolean/TYPE))))
  (throw-expr [_ fctx arg]
    (let [arg ^Insn arg]
      (if (.isAssignableFrom Throwable (insn/logical-type arg))
        (-> (^CodeEmitter fn [xb _ _]
             (when (insn/emit-insn-logical? xb arg)
               (-> xb (emit/with-line-number fctx) (.athrow))
               nil))         ;operand type reported when emitting code
            (insn/mk-insn Void/TYPE))   ;type used while parsing
        (throw (insn/info-type "expect instance of Throwable" arg)))))
  
  (mk-expr [_ form]
    (throw (UnsupportedOperationException. (str form)))))

(defn mk-code-generator ^ExprFactory [^ArrayList pending-functions]
  (ExprFactoryImpl. pending-functions))
