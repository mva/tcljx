(ns tcljx.classgen.codegen
  (:require
   (tcljx.data [config :as cfg] [type :as type] [model :as model]
               [resolve :as resolve] [reflect :as reflect])
   (tcljx.classgen [classfile :as classfile] [runtime :as rt] [emit :as emit]
                   [segmgen :as segmgen] [methodgen :as methodgen]))
  (:import
   (tcljx.data.model Expr Exprs ExprFactory CodeEmitter Entity Parameter Constant
                     FnLiteral NamespaceBuilder)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc)
   (java.lang.reflect Member Constructor)
   (java.util ArrayList)
   (java.util.function Consumer)))

(definterface ClassElementEmitter
  (emit-class-element ^void [^ClassBuilder cb]))
(defn class-element-emitter? ^boolean [x]
  (instance? ClassElementEmitter x))
(defn emit-class-element ^CodeBuilder [^ClassBuilder cb ^ClassElementEmitter cee]
  (.emit-class-element cee cb))

;;; The code generator's implementation of Expr.  The class in
;;; `expr-type` is the Clojure(!) type of the expression after parsing
;;; it in isolation.  Phrased differently, it is the expression's own
;;; idea of its type in terms of Clojure's type system, disregarding
;;; the context in which it appears.  By design, an Insn instance does
;;; not expose the internal structure of a non-constant expression.
;;; Only constants are discoverable, enabling bottom up constant
;;; folding while building the expression tree.
(deftype Insn [^CodeEmitter emitter
               ^Class expr-type]
  ;; FIXME... Valhalla value?
  java.lang.Record
  Expr
  (entity [_]
    (when (instance? Entity emitter)
      emitter)))

(def empty-insn (Insn. (^CodeEmitter fn [xb requested-type line] Void/TYPE)
                       type/polymorphic))

(deftype Insns [^CodeEmitter/1 emitters ^Class/1 expr-types]
  ;; FIXME... Valhalla value?
  java.lang.Record
  Exprs
  (length [_]
    (alength emitters))
  (set [_ i x]
    (aset emitters i (.emitter ^Insn x))
    (aset expr-types i (.expr-type ^Insn x)))
  (entity [_ i]
    (let [ce (aget emitters i)]
      (when (instance? Entity ce)
        ce))))

(defn- emitter
  (^CodeEmitter [^Insn insn]
   (.emitter insn))
  (^CodeEmitter [^Insns insns ^int i]
   (aget (.emitters insns) i)))
(defn- expr-type
  (^Class [^Insn insn]
   (.expr-type insn))
  (^Class [^Insns insns ^int i]
   (aget (.expr-types insns) i)))
(defn- logical-type
  (^Class [^Insn insn]
   (type/expr-to-logical (expr-type insn)))
  (^Class [^Insns insns ^int i]
   (type/expr-to-logical (expr-type insns i))))

(def ^:private empty-insns (Insns. (new CodeEmitter/1 0) (new Class/1 0)))


(defn emit-code-logical? ^boolean [^CodeBuilder xb ^Insn insn]
  (emit/more? xb (logical-type insn) (.emitter insn) cfg/no-line-number))

(defn- with-line-number ^Insn [^Insn insn ^int line]
  (Insn. (^CodeEmitter fn [xb requested-type _]
          (when (emit/more? xb requested-type (.emitter insn) line)
            requested-type))
         (expr-type insn)))

(deftype ConstantImpl [^Class type ^Object const-value]
  java.lang.Record
  Constant
  (emit-code* [_ xb requested-type line]
    (.loadConstant xb (if (instance? ConstantDesc const-value)
                        ^ConstantDesc const-value
                        (reflect/describe const-value)))
    type))

(defn- progn ^Insn [^Insns insns ^Insn insn] ;`insns` should not be empty
  (let [ces (.emitters insns), ce (.emitter insn)]
    (Insn. (^CodeEmitter fn [xb requested-type line]
            (when (emit/more-of-type*? xb Void/TYPE ces line)
              (when (emit/more? xb requested-type ce line)
                requested-type)))
           (expr-type insn))))

(defn- invoke ^Insn [^Class owner ^Member member ^Insn receiver ^Insns args]
  (let [opnd-type (reflect/invoke-member-type owner member)]
    (Insn. (^CodeEmitter fn [xb requested-type line]
            (when (instance? Constructor member)
              ;; new-dup-dance when create a new instance of `owner`
              (-> xb (.new_ (reflect/describe-class owner)) (.dup)))
            (when (or (nil? receiver) (emit-code-logical? xb receiver))
              (when (emit/more-of-types*? xb (reflect/parameter-types member)
                                          (.emitters args) line)
                (-> (.lineNumber xb line)
                    (reflect/invoke-member owner member))))
            opnd-type)
           opnd-type)))

;;; ------------------------------------------------------------------------

;;; Helper function for the local variable protocol.  When a method's
;;; code attribute is produced, the Binding is established first: its
;;; `emit-code` sets a private mutable field to the allocated slot
;;; value.  The binding's `bound-value` method returns an Insn whose
;;; own `emit-code` closes over the Binding instance (not the mutable
;;; slot value in the mutable field!), allowing it to retrieve the
;;; previously stored value via `allocated-slot`.  Initializiation
;;; should set the undefined slot value to -1.
(definterface LocalVariableSlot
  (allocated-slot ^int []))

(deftype ParameterImpl [^int param-no ^String name ^Class type
                        ^:unsynchronized-mutable ^int slot]
  Parameter
  (emit-code* [this xb requested-type line]
    (set! slot (.parameterSlot xb param-no))
    (.localVariable xb slot name (reflect/describe-class type)
                    (.startLabel xb) (.endLabel xb))
    Void/TYPE)
  (name [_]
    name)
  (namespace [_]
    nil)
  (init [_]
    nil)
  (bound-value [this]
    (Insn. (^CodeEmitter fn [xb requested-type line]
            (.loadLocal xb (TypeKind/from type) (.allocated-slot this))
            type)
           type))
  (type [_]
    type)
  
  LocalVariableSlot
  (allocated-slot [_]
    slot))

;;; ------------------------------------------------------------------------

(defn process-functions! ^void [^ArrayList segment-elements
                                ^ArrayList pending-functions]
  (doseq [^FnLiteral fn-literal pending-functions
          :when (nil? (aget (.arity-redirections fn-literal) 0))]
    (.add segment-elements
          (^ClassElementEmitter fn [cb]
           (let [at (aget (.arity-types fn-literal) 0)
                 ce-body (emitter (.arity-bodies fn-literal) 0)
                 mnm (str (.mangled-name fn-literal) "~" (.parameter-count at))
                 mtd (model/mtd-of-arity-type at)]
             (classfile/with-method-body-> cb
               [mnm mtd classfile/acc-method-static]
               (emit/method-code ce-body))))))
  (.clear pending-functions))

;;; ------------------------------------------------------------------------

(deftype ExprFactoryImpl [^ArrayList segment-elements ;shared with NmspBuilder
                          ^ArrayList pending-functions ;shared with NmspBuilder
                          ^Class class-static-fn]
  ExprFactory
  (new-exprs [_ n]
    (if (zero? n)
      empty-insns
      (Insns. (new CodeEmitter/1 n) (new Class/1 n))))
  (exprs-of [this xs]
    (let [insns (.new-exprs this (alength xs))]
      (dotimes [i (alength xs)]
        (.set insns i (aget xs i)))
      insns))
  (empty-expr [_]
    empty-insn)
  (progn-expr [_ xs x]
    (if (zero? (.length xs)) x (progn xs x)))
  
  (line-number [_ line insn]
    (cond-> insn (some? line) (with-line-number ^int line)))
  (new-constant [_ expr-type value]
    (Insn. (ConstantImpl. expr-type value) expr-type))
  
  (new-def-init [_ nmsp nm init]
    (let [init ^Insn init]
      (.add segment-elements
            (^ClassElementEmitter fn [cb]
             (let [opnd-type (logical-type init)
                   mtd (MethodTypeDesc/of (reflect/describe-class opnd-type))]
               (classfile/with-method-body-> cb
                 [nm mtd classfile/acc-method-static]
                 (emit/method-code (.emitter ^Insn init))))))
      empty-insn))
  (new-def-alias [_ nmsp nm other]
    (assert false))

  (new-parameter [_ param-no name type]
    (Insn. (ParameterImpl. param-no name type -1) Void/TYPE))
  (new-function [this fn-literal]
    ;; overwrite any auto-return-marker return types
    (let [ats (.arity-types fn-literal)
          bodies ^Insns (.arity-bodies fn-literal)]
      (dotimes [i (alength ats)]
        (let [at (aget ats i)]
          (when (type/auto-return-marker? (.return-type at))
            (aset ats i (.with-return-type at (logical-type bodies i)))))))
    
    (.add pending-functions fn-literal)
    (let [owner (ClassDesc/of "pkg.ns0._10")]
      (.new-constant this class-static-fn
                     (methodgen/static-fn-desc owner fn-literal))))
  
  (invoke-constructor [_ owner args]
    (let [args ^Insns args
          ms (resolve/members-by-param-tags false owner "new" (.expr-types args))]
      (assert (= (count ms) 1))
      (invoke owner (first ms) nil args)))
  (invoke-static-member [_ invoke-member-of-field? owner mnm args]
    (let [args ^Insns args
          ms (resolve/members-by-param-tags false owner mnm (.expr-types args))]
      (assert (= (count ms) 1))
      (let [m (first ms)
            insn (invoke owner m nil args)]
        (if (and invoke-member-of-field? (instance? java.lang.reflect.Field m))
          (assert false)
          insn))))
  (invoke-virtual-member [_ receiver mnm args]
    (let [args ^Insns args
          owner (expr-type receiver)
          ms (resolve/members-by-param-tags true owner mnm (.expr-types args))]
      (assert (= (count ms) 1))
      (let [m (first ms)]
        (invoke owner m receiver args))))
  
  (mk-expr [_ form]
    (throw (UnsupportedOperationException. (str form)))))

(defn mk-code-generator ^ExprFactory [^ArrayList segment-elements
                                      ^ArrayList pending-functions
                                      ^Class class-static-fn]
  (ExprFactoryImpl. segment-elements pending-functions class-static-fn))
