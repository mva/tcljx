(ns tcljx.classgen.codegen
  (:require
   (tcljx.data
    [config :as cfg] [wrong :as wrong] [context :as context] [type :as type]
    [model :as model] [resolve :as resolve] [reflect :as reflect])
   (tcljx.classgen
    [classfile :as classfile] [runtime :as rt] [emit :as emit]
    [envgraph :as envgraph] [insn :as insn] [entity :as entity]
    [primitive :as primitive] [condgen :as condgen] [switchgen :as switchgen]
    [trygen :as trygen] [defgen :as defgen] [fngen :as fngen]))
  (:import
   (tcljx.data.model Expr Exprs ExprFactory CodeEmitter Binding Entity
                     ArityType MethodSpec FieldSpec NamespaceBuilder)
   (tcljx.data.resolve Match)
   (tcljx.classgen.envgraph EnvClass EnvMethod)
   (tcljx.classgen.entity LocalVariable)
   (tcljx.classgen.insn Insn Insns)
   (java.lang.classfile ClassBuilder CodeBuilder Opcode Label TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc MethodHandleDesc
                       ConstantDescs)
   (java.util.function Consumer)))

(letfn [(find-factory ^Match [^String method-name]
          (resolve/runtime-method tinyclj.lang.Literal method-name
                                  (doto (new Class/1 1) (aset 0 Object/1))))]
  (def ^:private literal-vector (find-factory "vector")) ;type/vector
  (def ^:private literal-map (find-factory "map"))       ;type/map
  (def ^:private literal-set (find-factory "set"))       ;type/set
  (def ^:private literal-list (find-factory "list"))     ;type/list
  (def ^:private literal-with-meta
    (resolve/runtime-method tinyclj.lang.Literal "with_meta"
                            (doto (new Class/1 2)
                              (aset 0 clojure.lang.IObj)
                              (aset 1 clojure.lang.IPersistentMap)))))

;;; ------------------------------------------------------------------------

(defn- invoke-single-match ^Insn [^seq ms ^Insn receiver ^Insns args ^long fctx]
  (when (nil? (next ms))
    (when-some [m (first ms)]
      (insn/invoke-member m receiver args fctx))))

(defn- info-unresolved-member ^Throwable [^seq ms ^Class owner ^String mnm
                                          ^Insns args ^String label]
  ;; label is one of "static", "virtual", or "constructor"
  (let [entity (str label (when (not= label "constructor")
                            (if (.empty? args) " member" " method")))
        mnm (cond->> mnm (= label "virtual") (str "."))
        member (wrong/q-as-symbol owner mnm)]
    (wrong/wr-info (if (nil? (seq ms))
                     (str "no " entity " matching " member)
                     (str "multiple " entity "s matching " member)))))

(defn- recur-iinc-deltas ^int/1 [^Entity/1 entities ^CodeEmitter/1 ces]
  (let [a (new int/1 (alength entities))]
    (dotimes [i (alength a)]
      (aset a i (primitive/iinc-delta (aget entities i) (aget ces i))))
    a))

;;; ------------------------------------------------------------------------

(defn- method-index ^int [^MethodSpec/1 method-specs ^int arg-count]
  (loop [i (dec (alength method-specs))]
    (cond
      (neg? i) (assert false)
      (= (-> method-specs (aget i) .at .parameter-count) arg-count) i
      :else (recur (dec i)))))

(defn- select-method-for-arity ^int [^MethodSpec/1 method-specs ^Insns xs]
  (let [m-idx (method-index method-specs (.length xs))
        at (.at (aget method-specs m-idx))
        ptypes (.parameter-types at)
        fixed (model/fixed-parameter-count at)]
    (insn/ensure-assignables ptypes xs fixed)
    (when (< fixed (alength ptypes)) ;any arguments passed as varargs?
      (insn/ensure-assignable* (.getComponentType (aget ptypes fixed))
                               xs fixed))
    m-idx))

(defn- entity-dt-field [^ClassDesc owner ^FieldSpec spec ^int entity-id]
  (reify Entity
    (emit-insn* [_ xb _ _]
      (-> (.aload xb (.receiverSlot xb))
          (.getfield owner (.field-name spec) (.type-desc spec)))
      (.type spec))
    (value-type [_]
      (.type spec))
    (value-type-exact [_]
      (.type-desc spec))
    (entity-id [_]
      entity-id)))

(definterface InsnFactory
  :extends [ExprFactory]
  (get-recur-target ^Label [])
  (set-recur-target! ^void [^Label target]) ;on this copy of InsnFactory!
  (with-method ^InsnFactory [^EnvMethod method]))

;;; Note: To save work, this code generator assumes that it can use
;;; types available at compile time to refer to runtime types of the
;;; compiled application.  For example, it uses tinyclj.lang.StaticFn
;;; as expression type, instead of the type (accidentally of the same
;;; name) used by the application to hold a static function instance.
;;; Likewise for symbols, keywords, vectors, and so on.  This works
;;; only as long as compiler and application agree on the names of
;;; their runtime classes.
(deftype InsnFactoryImpl [^EnvMethod method ^Entity/1 recur-variables
                          ^:unsynchronized-mutable ^Label __recur-target]
  InsnFactory
  (empty-expr [_]
    insn/insn-empty)
  (new-exprs [_ n]
    (if (zero? n)
      insn/empty-insns
      (Insns. (new CodeEmitter/1 n) (new Class/1 n))))

  (value-of [_ ent form]
    (insn/value-of (envgraph/value-of method ent form) form))
  (invoke-entity [this fctx form inv args]
    (let [specs (.method-specs inv)]
      (condp identical? specs
        model/method-specs-primitive-fn
        (.invoke* inv fctx form nil -1 args)
        model/method-specs-invoke-dynamic
        (.invoke-value this fctx (.value-of this inv (first form)) args)
        #_else
        (let [m-idx (select-method-for-arity specs args)
              inv* (envgraph/invocation-of method inv form)]
          (.invoke* inv fctx form inv* m-idx args)))))
  
  (entity-constant [_ value type]
    (entity/constant value type))
  (entity-class-member [this m]
    (fngen/class-member-fn m))
  
  (new-loadable [_ value expr-type]
    (-> value (entity/collection expr-type false) (insn/mk-insn expr-type)))

  (attach-meta-to [this meta arg]
    (if (and (insn/const? arg) (insn/const? meta))
      (let [tp (insn/expr-type arg)]
        (-> (doto (new CodeEmitter/1 2)
              (aset 0 (.emitter arg))
              (aset 1 (.emitter meta)))
            (entity/collection tp true)
            (insn/mk-insn tp)))
      (insn/invoke-runtime literal-with-meta (insn/insns-of arg meta))))
  (new-collection [this coll-type args]
    (let [args ^Insns args]
      (if (insn/loadables? args)
        (.new-loadable this (.emitters args) coll-type)
        (-> (condp identical? coll-type
              type/vector literal-vector
              type/map literal-map
              type/set literal-set
              type/list literal-list)
            (insn/invoke-runtime args)))))
  (new-array [_ fctx array-type dims]
    (let [dims ^Insns dims]
      (insn/ensure-assignable* Integer/TYPE dims)
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insns? xb fctx Integer/TYPE (.emitters dims))
             (if (= (.length dims) 1)
               (let [component-type (.getComponentType array-type)]
                 (if (.isPrimitive component-type)
                   (.newarray xb (TypeKind/from component-type))
                   (.anewarray xb (reflect/describe-class component-type))))
               (.multianewarray xb (reflect/describe-class array-type)
                                (.length dims)))
             array-type))
          (insn/mk-insn array-type))))
  
  (progn-expr [_ xs x]
    (insn/progn xs x))
  (if-expr [_ fctx xs]
    (let [xs ^Insns xs
          tp (condgen/join-type (.expr-types xs) 1 (.length xs))
          ce-false (if (= (.length xs) 3)
                     (insn/emitter xs 2)
                     (.emitter insn/insn-empty))]
      (-> (.emitter (condgen/logical-truth (.get xs 0) fctx))
          (condgen/mk-if tp (insn/emitter xs 1) ce-false fctx)
          (insn/mk-insn tp))))
  (case-expr [this select guards paths-and-default fctx error-contexts]
    (let [select-tp (switchgen/adjust-numeric-type (insn/expr-type select))
          n-paths (.length paths-and-default)
          join-tp (-> (Insns/.expr-types paths-and-default)
                      (condgen/join-type 0 n-paths))
          default-path (if (= (alength guards) n-paths)
                         ;; Important: This evaluates the select
                         ;; expression a second time!  One possible
                         ;; idea: dup the select, consume it in the
                         ;; error path, and pop it immediately after
                         ;; the end-of-switch label.
                         (->> (switchgen/invoke-no-matching-clause select fctx)
                              (.throw-expr this fctx))
                         (.get paths-and-default (dec n-paths)))]
      (switchgen/validate-guards select-tp guards fctx error-contexts)
      (-> (if (switchgen/switch-on-int? select-tp)
            (switchgen/switch-int (.emitter select) join-tp guards
                                  (.emitters paths-and-default)
                                  (.emitter default-path) fctx)
            (switchgen/switch-map (.emitter select) join-tp guards
                                  (.emitters paths-and-default)
                                  (.emitter default-path) fctx))
          (insn/mk-insn join-tp))))
  (invoke-value [this fctx f args]
    (let [f ^Insn f
          args ^Insns args
          f-tp (insn/logical-type f)]
      (if (or (type/same? Object f-tp) (.isInterface f-tp)
              (.isAssignableFrom clojure.lang.IFn f-tp))
        (-> (^CodeEmitter fn [xb consumed-type _]
             (let [cpb (.constantPool xb)
                   atypes (insn/logical-types args)
                   mhe (.methodHandleEntry cpb rt/bsm-invoke-fn)
                   bsm (.bsmEntry cpb mhe (java.util.List/of))
                   mtd (insn/mtd-of-fn-poly consumed-type f-tp atypes)
                   nat (.nameAndTypeEntry cpb ConstantDescs/DEFAULT_NAME mtd)]
               (when (emit/insn? xb fctx f-tp (.emitter f))
                 (when (emit/typed-insns? xb fctx atypes (.emitters args))
                   (-> (emit/with-line-number xb fctx)
                       (.invokedynamic (.invokeDynamicEntry cpb bsm nat)))
                   consumed-type))))
            (insn/mk-insn type/polymorphic))
        (throw (insn/wr-type "called function's type does not implement `IFn`"
                             f)))))
  
  (binding-parameter [_ name type]
    (model/mk-binding (entity/parameter method name type) name false))

  (binding-alias [_ fctx name ent]
    (model/mk-binding ent name true))
  (binding-fresh [_ fctx opt-type name init]
    (when opt-type
      (insn/ensure-assignable opt-type init))
    (let [tp (or opt-type (insn/logical-type init))
          ce (-> init (insn/cast-to tp fctx) .emitter)]
      (model/mk-binding (entity/local-variable method name tp ce) name false)))
  (block-bindings [this fctx bindings body recur-to-body?]
    (-> (^CodeEmitter fn [xb consumed-type then-leave?]
         (.block xb (^Consumer fn ^void [^CodeBuilder xb]
                     (when (emit/statms? xb bindings)
                       (when recur-to-body?
                         (let [start-of-body (.newLabel xb)]
                           (.labelBinding xb start-of-body)
                           (.set-recur-target! this start-of-body)))
                       (emit/then-leave? xb fctx consumed-type (.emitter body)
                                         then-leave?))))
         (when-not then-leave? ;can the then-leave? above return true?
           consumed-type))
        (insn/mk-insn (insn/expr-type body))))
  (emitter-method [this fctx body]
    (^CodeEmitter fn [xb consumed-type then-leave?]
     (.set-recur-target! this (.startLabel xb)) ;method recur goes to bci 0
     (when (emit/then-leave? xb fctx consumed-type (.emitter body) then-leave?)
       consumed-type)))

  (set-recur-target! [this target]
    (assert (nil? __recur-target)) ;wrong if single `finally` is emitted twice
    (set! __recur-target target))
  (get-recur-target [this]
    __recur-target)
  (with-recur-variables [_ variables]
    (InsnFactoryImpl. method variables nil)) ;clear __recur-target
  (recur-expr [this fctx args]
    (let [args ^Insns args
          arg-types (.expr-types args)
          ces (.emitters args)
          entities recur-variables]
      
      (when-not (= (alength arg-types) (alength entities))
        (-> (str "recur expects " (alength entities) " arguments"
                 (wrong/got-int (alength arg-types)))
            (wrong/wr-info)
            (throw)))
      (dotimes [i (alength arg-types)]
        (let [exp (.value-type (aget entities i))
              act (aget arg-types i)]
          (when-not (type/assignable-from? exp act)
            (-> (str "recur expects " (wrong/q-type exp) " for argument #"
                     (inc i) (wrong/got-types arg-types))
                (wrong/wr-info)
                (throw)))))

      (-> (^CodeEmitter fn [xb _ _]
           (let [iinc-deltas (recur-iinc-deltas entities ces)]
             (loop [i 0]
               (if (< i (alength ces))
                 ;; push operand or skip when rewriting as IINC
                 (when (or (primitive/valid-iinc-const? (aget iinc-deltas i))
                           (emit/insn? xb fctx (.value-type (aget entities i))
                                       (aget ces i)))
                   (recur (inc i)))
                 
                 ;; emit all store/iinc instructions
                 (loop [i (dec (alength entities))]
                   (if (neg? i)
                     (do (.goto_ xb (.get-recur-target this))
                         nil) ;operand type reported when emitting code
                     (let [d (aget iinc-deltas i)
                           ent (aget entities i)]
                       (if (primitive/valid-iinc-const? d)
                         (when-not (zero? d) ;elide for unchanged entity 
                           (.emit-iinc ent xb d))
                         (.emit-store ent xb))
                       (recur (dec i)))))))))
          (insn/mk-statm))))        ;`void` is type used while parsing
  
  (binding-catching-local [this fctx type name]
    (let [ex-provider (insn/mk-insn (^CodeEmitter fn [_ _ _] type) type)]
      (.binding-fresh this fctx type name ex-provider)))
  (try-catch-finally [_ fctx body+catches catch-types finally]
    (let [insns ^Insns body+catches
          tp (condgen/join-type (.expr-types insns) 0 (.length insns))]
      (-> (if (some? finally)
            (trygen/try-catch-finally tp (.emitters insns) catch-types
                                      (.emitters finally) fctx)
            (trygen/try-catch tp (.emitters insns) catch-types fctx))
          (insn/mk-insn tp))))

  (with-method [_ method]
    (InsnFactoryImpl. method recur-variables __recur-target))
  (new-function [this parser parse-arity-body fn-nm arity-specs]
    (let [name-suffix (if (some? fn-nm) (name fn-nm) "fn")
          fn-proxy (fngen/partial-fn-literal (.next-entity-id method) arity-specs)
          n (alength arity-specs)
          arity-methods (new MethodSpec/1 n)
          methods' (envgraph/mk-methods method name-suffix n 0)]
      (dotimes [i n]
        (let [method' (aget methods' i)
              expr-factory' (.with-method this method')
              parser' (cond-> (.with-expr-factory parser expr-factory')
                        (some? fn-nm)
                        (model/with-local-binding (name fn-nm) fn-proxy))
              
              spec (aget arity-specs i)
              mspec (.apply parse-arity-body parser' spec i)
              rt (-> spec .at .return-type)]
          (when-not (type/auto-return-marker? rt)
            (insn/ensure-assignable rt (.x-body mspec)))
          (aset arity-methods i mspec)))
      
      (let [fn-proxy (fngen/update-arities fn-proxy arity-methods)
            scope-name' (.scope-name (aget methods' 0))
            class (EnvClass. fn-proxy (.segment method) scope-name' methods')]
        (.stage-task! method class)
        (.value-of this fn-proxy nil))))
  (new-itf-fn [this parser parse-arity-body itf-class itf-method arity-specs]
    (let [arity-methods (new MethodSpec/1 1)
          itf-fn (fngen/itf-fn arity-methods itf-class itf-method)
          methods' (envgraph/mk-methods method itf-class)]
      
      (let [expr-factory' (.with-method this (aget methods' 0))
            parser' (.with-expr-factory parser expr-factory')
            aspec (aget arity-specs 0)
            mspec (.apply parse-arity-body parser' aspec 0)]
        (insn/ensure-assignable (-> aspec .at .return-type) (.x-body mspec))
        (aset arity-methods 0 mspec))
      
      (let [scope-name' (.scope-name (aget methods' 0))
            class (EnvClass. itf-fn (.segment method) scope-name' methods')]
        (.stage-task! method class)
        (insn/mk-insn itf-fn itf-class))))
  
  (type-cast [this fctx target-type arg]
    (let [arg-tp (insn/expr-type arg)]
      (letfn [(wr-info-invalid-cast ^Throwable []
                (wrong/wr-info (str "cannot cast to " (wrong/q-type target-type)
                                    (wrong/got-type arg-tp))))
              (checkcast ^Insn [^Insn ref-arg ^Class ref-target]
                (let [arg-tp (insn/expr-type ref-arg)]
                  (if (or (.isInterface ref-target)
                          (.isAssignableFrom ref-target arg-tp) ;empty
                          (.isAssignableFrom arg-tp ref-target) ;checkcast
                          (type/poly-reference? arg-tp)) ;cast from nil
                    (insn/cast-to ref-arg ref-target fctx)
                    (throw (wr-info-invalid-cast)))))
              (boxed-arg ^Insn [^Class prim-tp]
                (insn/cast-to arg (.class-reference (type/of prim-tp))
                              context/fctx-none))]
        (cond
          (or (type/polymorphic? target-type) ;force void context
              (type/polymorphic? arg-tp))
          (-> arg (insn/cast-to target-type fctx))

          (type/same? target-type arg-tp)
          arg
          
          (.isPrimitive target-type)
          (if (.isPrimitive arg-tp)
            (throw (wr-info-invalid-cast)) ;no cast between different primitives
            (-> (boxed-arg target-type) (insn/cast-to target-type fctx)))
          
          ;; here holds: `target-type` is reference
          (.isPrimitive arg-tp)
          (-> (boxed-arg arg-tp) (checkcast target-type))
          
          ;; here holds: both `target-type` and `arg-tp` are reference
          :else (-> arg (checkcast target-type))))))
  (invoke-constructor [_ fctx owner args]
    (let [args ^Insns args
          mnm resolve/constructor-name
          ms (resolve/members-by-arg-types false owner mnm (.expr-types args))]
      (or (invoke-single-match ms nil args fctx)
          (throw (info-unresolved-member ms owner mnm args "constructor")))))
  (invoke-static-member [_ fctx invoke-member-if-field? owner mnm args]
    (let [args ^Insns args
          ms (resolve/members-by-arg-types true owner mnm (.expr-types args))]
      ;; (prn :et (seq (.expr-types args)))
      ;; (prn :ms (seq ms))
      ;; (prn :invoke-member-if-field? invoke-member-if-field?)
      (or (when-some [insn (invoke-single-match ms nil args fctx)]
            (if (and invoke-member-if-field? (resolve/field? (first ms)))
              (assert false "not yet implemented")
              insn))
          (throw (info-unresolved-member ms owner mnm args "static")))))
  (invoke-virtual-member [_ fctx receiver opt-owner mnm args]
    (let [receiver ^Insn receiver
          args ^Insns args
          owner (or opt-owner (insn/expr-type receiver))
          ms (resolve/members-by-arg-types false owner mnm (.expr-types args))]
      (or (invoke-single-match ms receiver args fctx)
          (throw (info-unresolved-member ms owner mnm args "virtual")))))

  (get-static-field [_ fctx owner mnm]
    (let [args insn/empty-insns
          ms (resolve/field-exact nil true owner mnm resolve/empty-class-array)]
      (or (invoke-single-match ms nil args fctx)
          (throw (info-unresolved-member ms owner mnm args "static")))))
  (get-virtual-field [_ fctx receiver mnm]
    (let [receiver ^Insn receiver
          args insn/empty-insns
          owner (insn/expr-type receiver)
          ms (resolve/field-exact nil false owner mnm (.expr-types args))]
      (or (invoke-single-match ms receiver args fctx)
          (throw (wrong/wr-info (str "no virtual field matching "
                                     (wrong/q-as-symbol owner mnm)))))))

  (instanceof-expr [_ fctx type arg]
    (let [arg ^Insn arg]
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insn? xb context/fctx-none Object (.emitter arg))
             (-> (emit/with-line-number xb fctx)
                 (.instanceOf (reflect/describe-class type)))
             Boolean/TYPE))
          (insn/mk-insn Boolean/TYPE))))
  (throw-expr [_ fctx arg]
    (let [arg ^Insn arg]
      (if (.isAssignableFrom Throwable (insn/logical-type arg))
        (-> (^CodeEmitter fn [xb _ _]
             (when (insn/emit-logical? xb arg)
               (-> xb (emit/with-line-number fctx) (.athrow))
               nil))         ;operand type reported when emitting code
            (insn/mk-insn Void/TYPE))   ;type used while parsing
        (throw (insn/info-type "expect instance of Throwable" arg)))))
  
  (ephemeral-class [this eph-class]
    (when (not= (.closure-level method) model/closure-level-clinit)
      (throw (wrong/wr-info "cannot define class in this position")))
    (let [const (.entity-constant this eph-class Class)]
      (.value-of this const nil)))
  (new-definterface [this eph-ncl]
    (.stage-task! method (fngen/task-definterface* eph-ncl))
    (.ephemeral-class this (.defined-class eph-ncl)))
  (new-deftype [this parser parse-method-body eph-ncl field-specs arity-specs
                java-record? defrecord?]
    (let [eph-cl (.defined-class eph-ncl)
          cl-name (.getSimpleName eph-cl)
          n-fields (alength field-specs)
          n-methods (alength arity-specs)
          fbnds (new Binding/1 (alength field-specs))
          arity-methods (new MethodSpec/1 n-methods)
          methods' (envgraph/mk-methods method cl-name n-methods n-fields)]
      (dotimes [i n-fields]
        (let [spec (aget field-specs i)
              ent-id (model/entity-id-of (inc (.closure-level method)) i)]
          (aset fbnds i (-> (entity-dt-field (.this-class eph-ncl) spec ent-id)
                            (model/mk-binding (.field-name spec) false)))))
      
      (dotimes [i n-methods]
        (let [method' (aget methods' i)
              expr-factory' (.with-method this method')
              ;; note: can call Resolver.globals() only on namespace thread
              parser' (-> (.with-expr-factory parser expr-factory')
                          (.with-bindings* (-> parser .resolver .globals))
                          (model/with-local-bindings fbnds))
              aspec (aget arity-specs i)
              mspec (.apply parse-method-body parser' aspec i)]
          (insn/ensure-assignable (-> mspec .at .return-type) (.x-body mspec))
          (aset arity-methods i mspec)))
      
      (let [class (-> (fngen/task-deftype* eph-ncl field-specs arity-methods
                                           java-record? defrecord?)
                      (EnvClass. (.segment method) cl-name methods'))]
        (.stage-task! method class)
        (.ephemeral-class this eph-cl))))
  (class-name-for-reify [_]
    (let [segm (.segment method)]
      (ClassDesc/of (.pkg-name segm)
                    (.pick-unique-name segm (.scope-name method) "reify"))))
  (new-reify [this parser parse-method-body eph-ncl interfaces meta arity-specs]
    (let [eph-cl (.defined-class eph-ncl)
          cl-name (.getSimpleName eph-cl)
          n-methods (alength arity-specs)
          arity-methods (new MethodSpec/1 n-methods)
          methods' (envgraph/mk-methods method cl-name n-methods 0)]
      (dotimes [i n-methods]
        (let [method' (aget methods' i)
              expr-factory' (.with-method this method')
              parser' (.with-expr-factory parser expr-factory')
              aspec (aget arity-specs i)
              mspec (.apply parse-method-body parser' aspec i)]
          (insn/ensure-assignable (-> mspec .at .return-type) (.x-body mspec))
          (aset arity-methods i mspec)))
      
      (let [reify (fngen/mk-reify* eph-ncl interfaces meta arity-methods)
            class (EnvClass. reify (.segment method) cl-name methods')]
        (.stage-task! method class)
        (insn/mk-insn reify (.defined-class eph-ncl))))))

(defn mk-factory ^ExprFactory [^EnvMethod segment]
  (InsnFactoryImpl. segment nil nil))
