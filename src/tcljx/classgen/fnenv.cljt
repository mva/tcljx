(ns tcljx.classgen.fnenv   ;supporting functions for fn, itf fn, reify
  (:require (tcljx.data [config :as cfg] [ir :as ir] [code :as code])
            (tcljx.classgen [util :as util] [segment :as segment]
                            [constgen :as constgen]))
  (:import (tcljx.data.ir CodeEmitter Entity FnPromise FieldSpec)
           (tcljx.classgen.segment CodePromise EnvFactory Display StoredEnv)
           (java.lang.classfile CodeBuilder)
           (java.lang.constant ClassDesc MethodTypeDesc ConstantDescs)
           (java.util Arrays List HashMap HashSet Map$Entry)
           (java.util.function BiConsumer)))

(defn load-env ^CodeBuilder [^CodeBuilder xb ^HashMap parent-e2d
                             ^Entity/1 aorigin]
  (dotimes [i (alength aorigin)]
    (let [origin (aget aorigin i)]
      (-> ^CodeEmitter (.getOrDefault parent-e2d origin origin)
          (.emit-insn* xb (.value-type origin) false))))
  xb)

(letfn [(sorted-idxs ^long/1 [^int n ^Entity/1 ao]
          (let [idxs (new long/1 n)]
            (dotimes [i (alength idxs)]
              (aset idxs i (-> (long (.entity-id (aget ao i)))
                               (bit-shift-left 16)
                               (bit-or i))))
            (java.util.Arrays/sort idxs)
            idxs))
        (index-after-sort ^int [^long/1 idxs ^int i]
          (bit-and (int (aget idxs i)) 0xFFFF))
        (sorted-stored-env ^StoredEnv [^int n ^Entity/1 ao ^Display/1 ad]
          (let [idxs (sorted-idxs n ao)
                aorigin (new Entity/1 n), adisplay (new Display/1 n)]
            (dotimes [i n]
              (let [j (index-after-sort idxs i)]
                (aset aorigin i (aget ao j))
                (aset adisplay i (aget ad j))))
            (StoredEnv. aorigin adisplay)))
        (sorted-stored-origin ^Entity/1 [^int n ^Entity/1 ao]
          (let [idxs (sorted-idxs n ao)
                aorigin (new Entity/1 n)]
            (dotimes [i n]
              (aset aorigin i (aget ao (index-after-sort idxs i))))
            aorigin))

        (flyweight-prefix ^CodeEmitter [^Entity/1 fw-env ^HashMap e2d]
          (^CodeEmitter fn [xb consumed-type _]
           (load-env xb e2d fw-env)
           consumed-type))]

  (defn mk-env-factory ^EnvFactory [^HashSet carries-env-set]
    (reify EnvFactory
      (fn-carries-env? [_ fn-p]
        (and (FnPromise/.value-use? fn-p) (.contains carries-env-set fn-p)))
      
      (stored-in-env? [this origin]
        (if (instance? FnPromise origin)
          (.fn-carries-env? this origin)
          true))

      ;; Sets display of closed over value/entity that is not *stored*
      ;; as part of the environment.  Returns a deterministically
      ;; sorted list of [origin, display] pairs that make up the
      ;; materialized environment and whose display must be filled.
      (stored-environment! [this cp this-emit]
        (let [env-to-display (.env-to-display cp)
              n* (-> env-to-display .size)
              it (-> env-to-display .entrySet .iterator)
              ao (new Entity/1 n*), ad (new Display/1 n*)]
          (loop [i 0]
            (if (.hasNext it)
              (let [entry ^Map$Entry (.next it)
                    o ^Entity (.getKey entry), d ^Display (.getValue entry)]
                (cond
                  (identical? o cp)
                  (do (.set-emitter! d this-emit) (recur i))
                  (.stored-in-env? this o)
                  (do (aset ao i o) (aset ad i d) (recur (inc i)))
                  ;; here holds: (instance? FnPromise o)
                  (FnPromise/.value-use? o)
                  (do (.set-emitter! d o) (recur i))
                  :else
                  (let [fw-env (.stored-origin this ^CodePromise o)]
                    (.set-emitter! d (flyweight-prefix fw-env env-to-display))
                    (recur i))))
              (if (and (= i n*) (<= n* 1))
                (StoredEnv. ao ad)
                (sorted-stored-env i ao ad))))))

      (stored-origin [this cp]      ;called for every flyweight invoke
        (let [n* (-> cp .env-to-display .size)
              it (-> cp .env-to-display .keySet .iterator)
              ao (new Entity/1 n*)]
          (loop [i 0]
            (if (.hasNext it)
              (let [o ^Entity (.next it)]
                (cond
                  (identical? o cp) (recur i)
                  (.stored-in-env? this o) (do (aset ao i o) (recur (inc i)))
                  :else (recur i)))
              (if (and (= i n*) (<= n* 1))
                ao
                (sorted-stored-origin i ao)))))))))

;;; ------------------------------------------------------------------------

(defn as-constants ^void [^HashMap env-to-display]
  (doseq [[o ^Display d] env-to-display]
    (.set-emitter! d o)))

(defn patched-field? ^boolean [^Entity/1 aforward ^int env-idx]
  (identical? constgen/entity-null (aget aforward env-idx)))
(defn mtd-of-patch ^MethodTypeDesc [^FieldSpec/1 fields]
  (letfn [(patched-type-desc ^ClassDesc [^FieldSpec fs]
            (when-not (code/final-field? fs) (.type-desc fs)))]
    (when-some [xs (seq (keep patched-type-desc fields))]
      (MethodTypeDesc/of ConstantDescs/CD_void ^List xs))))
(defn fields-exact ^FieldSpec/1 [^int start ^ClassDesc owner ^StoredEnv env
                                 ^Entity/1 aforward]
  (let [ao (.aorigin env),  ad (.adisplay env)
        a (new FieldSpec/1 (+ (alength ao) start))
        names (HashMap.)]
    (dotimes [i (alength ao)]
      (let [o (aget ao i), d (aget ad i)
            fnm (util/distinct-name names (cfg/munge-name (.local-name d)))
            flags (if (patched-field? aforward i)
                    (ir/acc* private)
                    (ir/acc* private final))]
        (aset a (+ i start) (FieldSpec. owner fnm nil flags
                                        (.value-type-exact o)
                                        (.value-type o)))))
    a))
(defn as-fields ^void [^int start ^FieldSpec/1 fields ^StoredEnv env]
  (dotimes [i (alength (.adisplay env))]
    (let [fs (aget fields (+ i start))]
      (.set-emitter! (aget (.adisplay env) i) (^CodeEmitter fn [xb _ _]
                                               (code/get-field xb fs)
                                               (.type fs))))))

(defn as-parameters ^int [^CodeBuilder xb ^StoredEnv env]
  (dotimes [i (alength (.aorigin env))]
    (let [o (aget (.aorigin env) i)
          d (aget (.adisplay env) i)
          ent (util/parameter* xb (.local-name d) (.value-type o)
                               (.value-type-exact o) i)]
      (.set-emitter! d ent)))
  (alength (.aorigin env)))

;;; ------------------------------------------------------------------------

(def ^:private empty-code-promises (new CodePromise/1 0))

;;; Computes a map of [succ, array of preds] pairs, where every `pred`
;;; must provide the complete set of environment values that `succ`
;;; closes over.  This is the input for a fixpoint iteration that
;;; grows the `env-to-display` maps of preds using the one from
;;; `succ`, until saturation is reached.
(defn- dataflow-predecessors ^HashMap [^HashMap acc ^HashSet dirty ^List tasks]
  (letfn [(add-edge! ^void [^CodePromise pred ^CodePromise succ]
            ;; environment values are passed from `pred` to `succ`
            (if-some [preds (.get acc succ)]
              (.add ^HashSet preds pred)
              (.put acc succ (doto (HashSet.) (.add pred)))))
          (invoke-only-fn? ^boolean [x]
            (and (instance? FnPromise x) (not (FnPromise/.value-use? x))))
          (register-flyweight-invokes ^void [^CodePromise cp]
            ;; if `cp` closes over an "invoke-only-fn", then this
            ;; means that it invokes it and must provide its
            ;; environment as part of the calling sequence
            (doseq [o (-> cp .env-to-display .keySet)
                    :when (invoke-only-fn? o)]
              (add-edge! cp o)))
          (process-cp ^void [^CodePromise cp ^CodePromise parent]
            (when-not (-> cp .env-to-display .isEmpty) ;pre: `cp` has methods
              (.add dirty cp))
            (register-flyweight-invokes cp)
            (when (some? parent)
              ;; all entities (incl. flyweight) take their environment
              ;; from the parent or transitively from any ancestor
              (add-edge! parent cp))
            (doseq [cp' (.!nested-parts cp)]
              (process-cp cp' cp)))]
    (doseq [task tasks
            :when (instance? CodePromise task)
            :let [cp ^CodePromise task]
            :when (some? (.child-methods cp))]
      (process-cp cp nil))
    (let [acc' (HashMap/newHashMap (.size acc))]
      (.forEach acc (^BiConsumer fn ^void [k ^HashSet preds]
                     (.put acc' k (.toArray preds empty-code-promises))))
      acc')))

(letfn [(propagated-to? ^boolean [^CodePromise cp ^CodePromise pred]
          (when (instance? Entity pred) ;`pred` may be a deftype
            (let [pred-level (ir/closure-level ^Entity pred)
                  pred-env-to-display (.env-to-display pred)
                  size-before (.size pred-env-to-display)]
              (doseq [^Map$Entry e (-> cp .env-to-display .entrySet)
                      :let [o ^Entity (.getKey e)] 
                      :when (<= (ir/closure-level o) pred-level)]
                (segment/display-of! pred-env-to-display o
                                     (.local-name ^Display (.getValue e))))
              (not= (.size pred-env-to-display) size-before))))
        (propagate! ^void [^HashSet dirty' ^HashMap preds-map ^HashSet dirty]
          (doseq [cp dirty
                  :let [^CodePromise/1 preds (.get preds-map cp)]
                  :when (some? preds)]
            (loop [i (dec (alength preds))]
              (when-not (neg? i)
                (let [pred (aget preds i)]
                  (when (propagated-to? cp pred)
                    (.add dirty' pred)))
                (recur (dec i))))))]
  (defn transitive-closure! ^List [^List tasks]
    (let [!dirty-0 (HashSet.)
          preds-map (dataflow-predecessors (HashMap.) !dirty-0 tasks)]
      (loop [dirty !dirty-0]
        (when-not (.isEmpty dirty)
          (let [!dirty' (HashSet.)]
            (propagate! !dirty' preds-map dirty)
            (recur !dirty')))))
    tasks))
