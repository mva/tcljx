(ns tcljx.classgen.fngen
  (:require
   (tcljx.data [config :as cfg] [context :as context] member [type :as type]
               [reflect :as reflect] [resolve :as resolve] [ir :as ir]
               [code :as code])
   (tcljx.classgen [classfile :as classfile] [runtime :as rt] [util :as util]
                   [emit :as emit] [segment :as segment] [constgen :as constgen]
                   [insn :as insn] [condgen :as condgen] [envgraph :as envgraph]))
  (:import
   (tcljx.data.ir CodeEmitter Entity Constant ArityType AritySpec MethodSpec
                  FieldSpec NmspClass Parser ExprFactory EntityFactory)
   (tcljx.data.member MemberHandle)
   (tcljx.classgen.segment CodePromise SegmentAcc)
   (tcljx.classgen.envgraph Display EnvDisplayPairs)
   (tcljx.classgen.insn Insn Insns PlainInvokeTest)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind Opcode Label
                        BootstrapMethodEntry)
   (java.lang.classfile.instruction SwitchCase)
   (java.lang.constant ClassDesc MethodTypeDesc MethodHandleDesc
                       ConstantDesc DirectMethodHandleDesc ConstantDescs
                       DirectMethodHandleDesc$Kind
                       DynamicConstantDesc DynamicCallSiteDesc)
   (java.lang.invoke MethodHandle)
   (java.lang.reflect Executable Method)
   (java.util ArrayList HashMap)
   (java.util.function Consumer)))

(deftype FnStatic [^int entity-id ^MethodSpec/1 method-specs
                   ^DirectMethodHandleDesc/1 mhds]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (-> (.computational-value this)
        (constgen/constant (.value-type this))
        (.emit-insn* xb consumed-type then-leave?)))
  
  Entity
  (value-type [_]
    tinyclj.lang.StaticFn)
  (value-type-exact [_]
    rt/StaticFn)
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    method-specs)
  (invoke* [this fctx form _ m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (insn/emit-invoke-arity (aget mhds m-idx) at xs fctx xb))
          (insn/mk-insn (.return-type at)))))
  
  Constant
  (computational-value [_] ;never nil, but may require owner to be known
    (DynamicConstantDesc/ofNamed rt/bsm-static-fn ConstantDescs/DEFAULT_NAME
                                 rt/StaticFn mhds)))

(letfn [(arity-parameter-types ^Class/1 [^MemberHandle m]
          (let [ptypes (.parameter-types m)]
            (if (reflect/takes-receiver? (.member m))
              (let [a (new Class/1 (inc (alength ptypes)))]
                (aset a 0 (.owner m))
                (System/arraycopy ptypes 0 a 1 (alength ptypes))
                a)
              ptypes)))
        (method-spec-of-match ^MethodSpec [^MemberHandle m]
          (let [varargs? (when (instance? Executable (.member m))
                           (.isVarArgs ^Executable (.member m)))
                ptypes (arity-parameter-types m)]
            (-> (ArityType. (.return-type m) ptypes nil varargs?)
                (MethodSpec. nil nil nil 0 nil nil))))]
  
  (defn class-member-fn ^FnStatic [^MemberHandle m]
    (FnStatic. ir/entity-id-constant
               (doto (new MethodSpec/1 1)
                 (aset 0 (method-spec-of-match m)))
               (doto (new DirectMethodHandleDesc/1 1)
                 (aset 0 (reflect/mhd-of-member (.owner m) (.member m)))))))

;;; ------------------------------------------------------------------------

(deftype FnVirtual [^int entity-id ^MethodSpec/1 method-specs
                    ^DirectMethodHandleDesc/1 mhds
                    ^ClassDesc this-class ^Entity/1 aorigin]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (-> (util/load-origin-values xb aorigin)
        (.invokestatic this-class rt/name-factory-method
                       (util/mtd-factory this-class aorigin)))
    tinyclj.lang.AFnMh)
  
  Entity
  (value-type [_]
    tinyclj.lang.AFnMh)
  (value-type-exact [_]
    this-class)
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    method-specs)
  (invoke* [this fctx form f m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insn? xb fctx tinyclj.lang.AFnMh f)
             (insn/emit-invoke-arity (aget mhds m-idx) at xs fctx xb)))
          (insn/mk-insn (.return-type at))))))

;;; -----------------------------------------------------------------------

(defn- source-order-idxs ^int/1 [^MethodSpec/1 mspecs]
  (let [source-order (new int/1 (alength mspecs))]
    (dotimes [i (alength mspecs)]
      (aset source-order (.source-idx (aget mspecs i)) i))
    source-order))

(defn- set-static-mhd!
  (^void [^DirectMethodHandleDesc/1 mhds ^ClassDesc owner ^String name-prefix
          ^MethodSpec/1 specs]
   (dotimes [i (alength mhds)]
     (let [spec (aget specs i), at (.at spec)
           nm (str name-prefix "~" (.parameter-count at))
           mhd (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                                          owner nm (util/mtd-of-arity-type at))
           body (-> spec .x-body .emitter)
           redir (when (instance? PlainInvokeTest body)
                   (.redirecting-to ^PlainInvokeTest body (.return-type at)
                                    (ir/translates-to-varargs? at)
                                    (.parameters spec)))]
       (aset mhds i (or redir mhd)))))
  (^void [^DirectMethodHandleDesc/1 mhds ^ClassDesc owner ^String name-prefix
          ^EnvDisplayPairs/1 aenv ^MethodSpec/1 specs]
   (dotimes [i (alength mhds)]
     (let [at (.at (aget specs i))
           nm (str name-prefix "~" (.parameter-count at))
           aorigin (.aorigin (aget aenv i))
           mtd (-> (util/mtd-of-arity-type at)
                   (.insertParameterTypes 0 (util/entity-type-exact* aorigin)))
           mhd (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                                          owner nm mtd)]
       (aset mhds i mhd)))))

(letfn [(provide-env-as-parameters ^CodeBuilder [^CodeBuilder xb
                                                 ^EnvDisplayPairs env]
          (dotimes [i (alength (.aorigin env))]
            (let [origin (aget (.aorigin env) i)
                  display (aget (.adisplay env) i)
                  ent (util/parameter* xb (.local-name display)
                                       (.value-type origin) i)]
              (.set-emit-entity! display ent)))
          xb)]
  (defn- class-elements-static ^void [^ClassBuilder cb ^MethodSpec/1 specs
                                      ^DirectMethodHandleDesc/1 mhds
                                      ^ClassDesc segment-class
                                      ^EnvDisplayPairs/1 aenv]
    (let [source-order (source-order-idxs specs)]
      (dotimes [j (alength specs)]
        (let [i (aget source-order j)
              spec (aget specs i)
              mhd (aget mhds i)
              mtd (MethodTypeDesc/ofDescriptor (.lookupDescriptor mhd))
              first-param-no (if (some? aenv)
                               (alength (.aorigin (aget aenv i)))
                               0)]
          (when (or (some? aenv) (identical? segment-class (.owner mhd)))
            (classfile/with-method-body-> cb
              [(.methodName mhd) mtd classfile/acc-method-static]
              (cond-> #_xb
                (some? aenv) (provide-env-as-parameters (aget aenv i))
                true (emit/body spec first-param-no)))))))))

(defn- as-fn-static ^Entity [^SegmentAcc acc ^Entity fn-p ^String name-prefix]
  (let [segment-class (.segment-class acc)
        method-specs (.invoke-methods fn-p)
        mhds (new DirectMethodHandleDesc/1 (alength method-specs))]
    (set-static-mhd! mhds segment-class name-prefix method-specs)
    
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (class-elements-static cb method-specs mhds segment-class nil))
         (segment/add-elements acc))
    (FnStatic. (.entity-id fn-p) method-specs mhds)))

;;; ------------------------------------------------------------------------

(defn- entity-this ^Entity [^ClassDesc owner]
  (reify Entity
    (emit-insn* [_ xb _ _] (.aload xb (.receiverSlot xb)) tinyclj.lang.AFnMh)
    (value-type [_] tinyclj.lang.AFnMh)
    (value-type-exact [_] owner)
    (entity-id [_] -1)))

(defn- set-virtual-mhd! ^void [^DirectMethodHandleDesc/1 mhds
                               ^ClassDesc owner ^MethodSpec/1 specs]
  (dotimes [i (alength mhds)]
    (let [at (.at (aget specs i))
          mnm (str "fn" (.parameter-count at))]
      (->> (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/VIRTUAL
                                      owner mnm (util/mtd-of-arity-type at))
           (aset mhds i)))))

(letfn [(provide-display! ^void [^HashMap origin-to-load ^MethodSpec mspec]
          (doseq [[origin ^Display display]
                  (-> mspec .env-to-display (.entrySet))]
            (.set-emit-entity! display (.get origin-to-load origin))))
        (fn-method-virtual ^void [^ClassBuilder cb ^MethodSpec spec
                                  ^ClassDesc this-class ^String method-name]
          (->> (^Consumer fn ^void [^CodeBuilder xb]
                (-> (.localVariable xb (.receiverSlot xb) (.name spec)
                                    this-class (.startLabel xb) (.endLabel xb))
                    (emit/body spec 0)))
               (.withMethodBody cb method-name
                                (util/mtd-of-arity-type (.at spec))
                                (ir/acc* public final))))

        (arity-parameter-count ^int [^DirectMethodHandleDesc mhd]
          (dec (.parameterCount (.invocationType mhd))))
        (arity-fixed-1 ^void [^CodeBuilder xb ^DirectMethodHandleDesc mhd]
          (let [n (arity-parameter-count mhd)
                test-args (doto (new CodeEmitter/1 2)
                            (aset 0 (util/parameter* xb nil Integer/TYPE 0))
                            (aset 1 (constgen/constant n Integer/TYPE)))]
            (-> (condgen/mk-cmp-pred Opcode/IF_ICMPEQ condgen/cmp-eq
                                     Integer/TYPE test-args context/fctx-none)
                (condgen/mk-if MethodHandle
                               (constgen/constant mhd MethodHandle)
                               constgen/emitter-empty context/fctx-none)
                (.emit-insn* xb MethodHandle true))))
        (arity-fixed-n ^void [^CodeBuilder xb ^DirectMethodHandleDesc/1 mhds]
          (let [scs (new SwitchCase/1 (alength mhds))
                target-default (.newLabel xb)]
            (dotimes [i (alength scs)]
              (aset scs i (SwitchCase/of (arity-parameter-count (aget mhds i))
                                         (.newLabel xb))))
            (-> (.iload xb (.parameterSlot xb 0))
                (.lookupswitch target-default (java.util.Arrays/asList scs)))
            (dotimes [i (alength scs)]
              (-> (.labelBinding xb (.target (aget scs i)))
                  (.ldc (aget mhds i))
                  (.areturn)))
            (-> (.labelBinding xb target-default)
                (.aconst_null)
                (.areturn))))]
  
  (defn- class-elements-virtual ^void [^ClassBuilder cb ^MethodSpec/1 specs
                                       ^DirectMethodHandleDesc/1 mhds
                                       ^ClassDesc this-class
                                       ^MethodTypeDesc factory-mtd
                                       ^FieldSpec/1 fields
                                       ^HashMap env-to-load]
    (let [constr-mtd (-> factory-mtd
                         (.insertParameterTypes 0 rt/map)
                         (.changeReturnType ConstantDescs/CD_void))]
      ;; virtual fields holding the closed over environment
      (code/with-field* cb fields)
      ;; virtual methods implementing the function arities
      (let [source-order (source-order-idxs specs)]
        (dotimes [j (alength specs)]
          (let [i (aget source-order j)]
            (provide-display! env-to-load (aget specs i))
            (fn-method-virtual cb (aget specs i) this-class
                               (.methodName (aget mhds i))))))
      ;; virtual method __arityOrNull
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (let [at-last (.at (aget specs (dec (alength specs))))]
              (assert (not (ir/translates-to-varargs? at-last)))
              (if (= (alength mhds) 1)
                (arity-fixed-1 xb (aget mhds 0))
                (arity-fixed-n xb mhds))))
           (.withMethodBody cb rt/name-arity-method
                            rt/mtd-arity-method
                            (ir/acc* public final synthetic)))
      ;; virtual method __directMethodHandles
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.loadConstant xb (alength mhds))
                (.anewarray rt/MethodHandle))
            (dotimes [i (alength mhds)]
              (-> (.dup xb)
                  (.loadConstant i)
                  (.ldc (aget mhds i))
                  (.aastore)))
            (.areturn xb))
           (.withMethodBody cb rt/name-dmh-method
                            rt/mtd-dmh-method
                            (ir/acc* public final synthetic)))
      ;; private constructor <init>
      (code/constructor cb fields rt/AFn (ir/acc* private synthetic)
                        (doto (new ClassDesc/1 1) (aset 0 rt/map)))
      ;; public static factory method __create
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> xb
                (.new_ this-class)
                (.dup)
                (.aconst_null))
            (dotimes [i (.parameterCount factory-mtd)]
              (.loadLocal xb (TypeKind/from (.parameterType factory-mtd i))
                          (.parameterSlot xb i)))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb rt/name-factory-method factory-mtd
                            (ir/acc* public static final synthetic)))
      ;; protected virtual method __withMetaImpl
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.new_ xb this-class)
                (.dup)
                (.aload (.parameterSlot xb 0)))
            (dotimes [i (alength fields)]
              (code/get-field xb (aget fields i)))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb rt/name-with-meta-impl
                            (MethodTypeDesc/of this-class rt/map)
                            (ir/acc* protected final synthetic))))))

(defn- as-fn-virtual ^Entity [^SegmentAcc acc ^Entity fn-p ^String unique-nm]
  (let [this-class (segment/namespace-class acc unique-nm)
        super-class rt/AFn
        method-specs (.invoke-methods fn-p)
        construction-ops (-> (envgraph/merged-env-to-display method-specs)
                             (doto (.remove fn-p))
                             (envgraph/sorted-eds))
        mhds (new DirectMethodHandleDesc/1 (alength method-specs))]
    (set-virtual-mhd! mhds this-class method-specs)
    
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (let [factory-mtd (util/mtd-factory this-class
                                              (.aorigin construction-ops))
                constr-mtd (-> (.insertParameterTypes factory-mtd 0 rt/map)
                               (.changeReturnType ConstantDescs/CD_void))
                fields (envgraph/fields-exact 0 this-class construction-ops)
                env-to-load (-> (.aorigin construction-ops)
                                (envgraph/field-entity-map fields 0)
                                (doto (.put fn-p (entity-this this-class))))]
            (-> (cfg/with-class-version cb)
                (.withFlags (ir/acc* public final))
                (.withSuperclass super-class)
                (class-elements-virtual method-specs mhds this-class
                                        factory-mtd fields env-to-load))))
         (ir/mk-nmsp-class this-class super-class)
         (segment/add-class-file acc))
    (FnVirtual. (.entity-id fn-p) method-specs mhds
                this-class (.aorigin construction-ops))))

;;; ------------------------------------------------------------------------

(deftype FnPromise [^int entity-id ^MethodSpec/1 method-specs
                    ^String unique-nm ^ArrayList !nested-parts
                    ^:unsynchronized-mutable ^Entity __emit
                    ^:volatile-mutable ^boolean __materialized?]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (.emit-insn* __emit xb consumed-type then-leave?))
  
  Entity
  (value-type [_]
    tinyclj.lang.AFnMh)
  (value-type-exact [_]
    (.value-type-exact __emit))
  (entity-id [_]
    entity-id)
  (invoke-methods [_]
    method-specs)
  (invoke* [this fctx form opt-f m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb consumed-type then-leave?]
           (-> (.get-emit-entity this) ;trampoline to get current entity
               (.invoke* fctx form opt-f m-idx xs)
               (insn/emitter)
               (.emit-insn* xb consumed-type then-leave?)))
          (insn/mk-insn (.return-type at)))))
  
  tcljx.classgen.envgraph.IFnPromise
  (get-emit-entity [_] __emit)
  (materialized-as-value? [_] __materialized?)
  (mark-as-materialized! [_] (set! __materialized? true))
  
  CodePromise
  (expr-of [this]
    (insn/mk-insn this (.value-type this)))
  (child-methods [_]
    method-specs)
  (!nested-parts [_]
    !nested-parts)
  (generate-and-deliver [this acc]
    (set! __emit (if (envgraph/fn-closes-over-env? (.method-specs this))
                   (as-fn-virtual acc this unique-nm)
                   (as-fn-static acc this unique-nm)))
    acc))

;;; ------------------------------------------------------------------------

(deftype ItfFn [^MethodSpec/1 method-specs ^String unique-nm ^Class itf-class
                ^Method method ^ArrayList !nested-parts
                ^:unsynchronized-mutable ^Consumer __emit]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (util/with-void-empty-if-requested consumed-type
      (.accept __emit xb)
      itf-class))
  CodePromise
  (expr-of [this]
    (insn/mk-insn this itf-class))
  (child-methods [_]
    method-specs)
  (!nested-parts [_]
    !nested-parts)
  (generate-and-deliver [_ acc]
    (let [mspec (aget method-specs 0)
          constr-ops (envgraph/sorted-eds (.env-to-display mspec))
          aenv (doto (new EnvDisplayPairs/1 1) (aset 0 constr-ops))
          mhd-itf (reflect/mhd-of-method itf-class method)
          mhds (new DirectMethodHandleDesc/1 1)
          aorigin (.aorigin constr-ops)]
      (set-static-mhd! mhds (.segment-class acc) unique-nm aenv
                       method-specs)
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (let [inv-type (MethodTypeDesc/of (reflect/describe-class itf-class)
                                              (util/entity-type-exact* aorigin))
                  mtd-lookup (-> (.invocationType mhd-itf) 
                                 (.dropParameterTypes 0 1))
                  d-mtd (util/mtd-of-arity-type (.at mspec))
                  dcd (DynamicCallSiteDesc/of
                       rt/bsm-metafactory (.methodName mhd-itf) inv-type
                       mtd-lookup (aget mhds 0) d-mtd)]
              (-> xb (util/load-origin-values aorigin) (.invokedynamic dcd))))
           (set! __emit))
      (->> (^Consumer fn ^void [^ClassBuilder cb]
            (class-elements-static cb method-specs mhds nil aenv))
           (segment/add-elements acc)))))
(def promise-itf-fn ItfFn/new)
