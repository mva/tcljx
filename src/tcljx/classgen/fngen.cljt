(ns tcljx.classgen.fngen
  (:require
   (tcljx.data [config :as cfg] [context :as context] [type :as type]
               [reflect :as reflect] [resolve :as resolve] [model :as model])
   (tcljx.classgen [classfile :as classfile] [runtime :as runtime]
                   [emit :as emit] [runtime :as rt] [entity :as entity]
                   [insn :as insn] [condgen :as condgen] [envgraph :as envgraph])
   (tinyclj [string :as str]))
  (:import
   (tcljx.data.model CodeEmitter Entity Constant ArityType AritySpec MethodSpec
                     FieldSpec NmspClass)
   (tcljx.data.resolve Match)
   (tcljx.classgen.envgraph EnvMethod EnvProxy IEmitProxy SegmentAcc)
   (tcljx.classgen.entity LocalVariable)
   (tcljx.classgen.insn Insn Insns PlainInvokeTest)
   (tcljx.classgen.envgraph EnvClass OriginProxyPairs PreparationTask)
   (clojure.lang IPersistentMap Keyword)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind Opcode
                        BootstrapMethodEntry)
   (java.lang.classfile.instruction SwitchCase)
   (java.lang.constant ClassDesc MethodTypeDesc MethodHandleDesc
                       ConstantDesc DirectMethodHandleDesc ConstantDescs
                       DirectMethodHandleDesc$Kind
                       DynamicConstantDesc DynamicCallSiteDesc)
   (java.lang.invoke MethodHandle)
   (java.lang.reflect Executable)
   (java.util List HashMap)
   (java.util.function Consumer)))

(defn- env-type-descs ^seq [^OriginProxyPairs env]
  (map Entity/.value-type-exact (.aorigin env)))
(defn- mtd-of-arity-type
  (^MethodTypeDesc [^ArityType at]
   (MethodTypeDesc/of (reflect/describe-class (.return-type at))
                      (reflect/describe-class* (.parameter-types at))))
  (^MethodTypeDesc [^seq prefix ^ArityType at]
   (let [ptps (concat prefix (map reflect/describe-class (.parameter-types at)))]
     (MethodTypeDesc/of (reflect/describe-class (.return-type at)) ^List ptps))))

(defn- emit-body ^void [^CodeBuilder xb ^MethodSpec spec ^int first-param-no]
  (let [return-type (-> spec .at .return-type)
        parameters (.parameters spec)]
    (dotimes [i (alength parameters)]
      (let [param-no (+ first-param-no i)]
        (.emit-setup-code? ^LocalVariable (aget parameters i) xb param-no)))
    (emit/then-leave? xb cfg/no-line-number return-type (.code spec) true)))

;;; ------------------------------------------------------------------------

(deftype FnStatic [^int entity-id ^MethodSpec/1 method-specs
                   ^DirectMethodHandleDesc/1 mhds]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (-> (.computational-value this)
        (entity/constant (.value-type this))
        (.emit-insn* xb consumed-type then-leave?)))
  
  Entity
  (value-type [_]
    tinyclj.lang.StaticFn)
  (value-type-exact [_]
    runtime/StaticFn)
  (entity-id [_]
    entity-id)
  (method-specs [_]
    method-specs)
  (invoke* [this fctx form _ m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (insn/emit-invoke-arity (aget mhds m-idx) at xs fctx xb))
          (insn/mk-insn (.return-type at)))))
  
  Constant
  (computational-value [_] ;never nil, but may require owner to be known
    (DynamicConstantDesc/ofNamed rt/bsm-static-fn ConstantDescs/DEFAULT_NAME
                                 rt/StaticFn mhds)))

(letfn [(arity-parameter-types ^Class/1 [^Match m]
          (let [ptypes (.parameter-types m)]
            (if (reflect/takes-receiver? (.member m))
              (let [a (new Class/1 (inc (alength ptypes)))]
                (aset a 0 (.owner m))
                (System/arraycopy ptypes 0 a 1 (alength ptypes))
                a)
              ptypes)))
        (method-spec-of-match ^MethodSpec [^Match m]
          (let [varargs? (when (instance? Executable (.member m))
                           (.isVarArgs ^Executable (.member m)))
                ptypes (arity-parameter-types m)]
            (-> (ArityType. (.return-type m) ptypes nil varargs?)
                (MethodSpec. nil nil nil 0 nil))))]
  
  (defn class-member-fn ^FnStatic [^Match m]
    (FnStatic. model/entity-id-constant
               (doto (new MethodSpec/1 1)
                 (aset 0 (method-spec-of-match m)))
               (doto (new DirectMethodHandleDesc/1 1)
                 (aset 0 (reflect/mhd-of-member (.owner m) (.member m)))))))

;;; ------------------------------------------------------------------------

(defn- factory-mtd-for ^MethodTypeDesc [^ClassDesc this-class ^Entity/1 ents]
  (let [tps (new Class/1 (alength ents))]
    (dotimes [i (alength tps)]
      (aset tps i (.value-type (aget ents i))))
    (MethodTypeDesc/of this-class (reflect/describe-class* tps))))

(defn- load-origin-values ^CodeBuilder [^CodeBuilder xb ^Entity/1 aorigin]
  ;; FIXME... origin does not work when not provided by the parent method
  (dotimes [i (alength aorigin)]
    (let [ent (aget aorigin i)]
      (.emit-insn* ent xb (.value-type ent) false)))
  xb)

(deftype FnVirtual [^int entity-id ^MethodSpec/1 method-specs
                    ^DirectMethodHandleDesc/1 mhds
                    ^ClassDesc this-class ^Entity/1 aorigin]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (-> (load-origin-values xb aorigin)
        (.invokestatic this-class runtime/name-factory-method
                       (factory-mtd-for this-class aorigin)))
    tinyclj.lang.AFnMh)
  
  Entity
  (value-type [_]
    tinyclj.lang.AFnMh)
  (value-type-exact [_]
    this-class)
  (entity-id [_]
    entity-id)
  (method-specs [_]
    method-specs)
  (invoke* [this fctx form f m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insn? xb fctx tinyclj.lang.AFnMh f)
             (insn/emit-invoke-arity (aget mhds m-idx) at xs fctx xb)))
          (insn/mk-insn (.return-type at))))))

;;; -----------------------------------------------------------------------

(defn- source-order-idxs ^int/1 [^MethodSpec/1 mspecs]
  (let [source-order (new int/1 (alength mspecs))]
    (dotimes [i (alength mspecs)]
      (aset source-order (.source-idx (aget mspecs i)) i))
    source-order))

(defn- set-static-mhd!
  (^void [^DirectMethodHandleDesc/1 mhds ^ClassDesc owner ^String name-prefix
          ^MethodSpec/1 specs]
   (dotimes [i (alength mhds)]
     (let [spec (aget specs i), at (.at spec)
           nm (str name-prefix "~" (.parameter-count at))
           mhd (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                                          owner nm (mtd-of-arity-type at))
           body (-> spec .x-body .emitter)
           redir (when (instance? PlainInvokeTest body)
                   (.redirecting-to ^PlainInvokeTest body (.return-type at)
                                    (model/translates-to-varargs? at)
                                    (.parameters spec)))]
       (aset mhds i (or redir mhd)))))
  (^void [^DirectMethodHandleDesc/1 mhds ^ClassDesc owner ^String name-prefix
          ^OriginProxyPairs/1 aenv ^MethodSpec/1 specs]
   (dotimes [i (alength mhds)]
     (let [at (.at (aget specs i))
           nm (str name-prefix "~" (.parameter-count at))
           mtd (mtd-of-arity-type (env-type-descs (aget aenv i)) at)
           mhd (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                                          owner nm mtd)]
       (aset mhds i mhd)))))

(letfn [(provide-env-as-parameters ^CodeBuilder [^CodeBuilder xb
                                                 ^OriginProxyPairs env]
          (dotimes [i (alength (.aorigin env))]
            (let [origin (aget (.aorigin env) i)
                  proxy (aget (.aproxy env) i)
                  ent (LocalVariable. (.local-name proxy) (.value-type origin)
                                      0 nil -1)]
              (.emit-setup-code? ent xb i)
              (.set-emit-entity! proxy ent)))
          xb)]
  (defn- class-elements-static ^void [^ClassBuilder cb ^MethodSpec/1 specs
                                      ^DirectMethodHandleDesc/1 mhds
                                      ^ClassDesc segment-class
                                      ^OriginProxyPairs/1 aenv]
    (let [source-order (source-order-idxs specs)]
      (dotimes [j (alength specs)]
        (let [i (aget source-order j)
              spec (aget specs i)
              mhd (aget mhds i)
              mtd (MethodTypeDesc/ofDescriptor (.lookupDescriptor mhd))
              first-param-no (if (some? aenv)
                               (alength (.aorigin (aget aenv i)))
                               0)]
          (when (or (some? aenv) (identical? segment-class (.owner mhd)))
            (classfile/with-method-body-> cb
              [(.methodName mhd) mtd classfile/acc-method-static]
              (cond-> #_xb
                (some? aenv) (provide-env-as-parameters (aget aenv i))
                true (emit-body spec first-param-no)))))))))

(defn- as-fn-static ^SegmentAcc [^SegmentAcc acc ^ClassDesc owner
                                 ^String name-prefix ^IEmitProxy fn-proxy]
  (let [method-specs (.method-specs fn-proxy)
        mhds (new DirectMethodHandleDesc/1 (alength method-specs))
        fn-static (FnStatic. (.entity-id fn-proxy) method-specs mhds)]
    (set-static-mhd! mhds owner name-prefix method-specs)
    (.set-emit-entity! fn-proxy fn-static)
       
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (class-elements-static cb method-specs mhds owner nil))
         (envgraph/add-segment-elements acc))))

;;; ------------------------------------------------------------------------

(def ^:private fn-virtual-class-flags (model/acc* public final))

(defn- entity-getfield ^Entity [^ClassDesc owner ^String nm ^Class type]
  (let [type-desc (reflect/describe-class type)]
    (reify Entity
      (emit-insn* [_ xb _ _]
        (-> (.aload xb (.receiverSlot xb))
            (.getfield owner nm type-desc))
        type)
      (value-type [_]
        type)
      (value-type-exact [_]
        type-desc)
      (entity-id [_]
        -1))))
(defn- entity-this ^Entity [^ClassDesc owner]
  (reify Entity
    (emit-insn* [_ xb _ _]
      (.aload xb (.receiverSlot xb))
      tinyclj.lang.AFnMh)
    (value-type [_]
      tinyclj.lang.AFnMh)
    (value-type-exact [_]
      owner)
    (entity-id [_]
      -1)))

(defn- field-type ^Class [^OriginProxyPairs construction-ops ^int i]
  (.value-type (aget (.aorigin construction-ops) i)))
(defn- field-type-desc ^ClassDesc [^OriginProxyPairs construction-ops ^int i]
  (reflect/describe-class (field-type construction-ops i)))
(defn- munged-field-names ^String/1 [^OriginProxyPairs construction-ops]
  (let [aproxy (.aproxy construction-ops)
        a (new String/1 (alength aproxy))]
    (dotimes [i (alength a)]
      (aset a i (cfg/munge-name (.local-name (aget aproxy i)))))
    a))
(defn- field-getters ^HashMap [^ClassDesc owner
                               ^OriginProxyPairs construction-ops]
  (let [aorigin (.aorigin construction-ops)
        aproxy (.aproxy construction-ops)
        acc (HashMap.)]
    (dotimes [i (alength aorigin)]
      (let [origin (aget aorigin i)]
        (.put acc origin (entity-getfield owner (.local-name (aget aproxy i))
                                          (.value-type origin)))))
    acc))

(defn- set-virtual-mhd! ^void [^DirectMethodHandleDesc/1 mhds
                               ^ClassDesc owner ^MethodSpec/1 specs]
  (dotimes [i (alength mhds)]
    (let [at (.at (aget specs i))
          mnm (str "fn" (.parameter-count at))]
      (->> (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/VIRTUAL
                                      owner mnm (mtd-of-arity-type at))
           (aset mhds i)))))

(letfn [(virtual-method ^void [^ClassBuilder cb ^HashMap origin-to-load
                               ^MethodSpec spec ^ClassDesc this-class
                               ^String this-name ^DirectMethodHandleDesc mhd
                               ^HashMap origin-to-proxy]
          (doseq [[origin ^EnvProxy proxy] (.entrySet origin-to-proxy)]
            (.set-emit-entity! proxy (.get origin-to-load origin)))
          (->> (^Consumer fn ^void [^CodeBuilder xb]
                (-> (.localVariable xb (.receiverSlot xb) this-name
                                    this-class (.startLabel xb) (.endLabel xb))
                    (emit-body spec 0)))
               (.withMethodBody cb (.methodName mhd)
                                (mtd-of-arity-type (.at spec))
                                (model/acc* public final))))

        (arity-parameter-count ^int [^DirectMethodHandleDesc mhd]
          (dec (.parameterCount (.invocationType mhd))))
        (arity-fixed-1 ^void [^CodeBuilder xb ^DirectMethodHandleDesc mhd]
          (let [n (arity-parameter-count mhd)
                test-args (doto (new CodeEmitter/1 2)
                            (aset 0 (LocalVariable. "n" Integer/TYPE -1 nil
                                                    (.parameterSlot xb 0)))
                            (aset 1 (entity/constant n Integer/TYPE)))]
            (-> (condgen/mk-cmp-pred Opcode/IF_ICMPEQ condgen/cmp-eq
                                     Integer/TYPE test-args context/fctx-none)
                (condgen/mk-if MethodHandle
                               (entity/constant mhd MethodHandle)
                               entity/emitter-empty context/fctx-none)
                (.emit-insn* xb MethodHandle true))))
        (arity-fixed-n ^void [^CodeBuilder xb ^DirectMethodHandleDesc/1 mhds]
          (let [scs (new SwitchCase/1 (alength mhds))
                target-default (.newLabel xb)]
            (dotimes [i (alength scs)]
              (aset scs i (SwitchCase/of (arity-parameter-count (aget mhds i))
                                         (.newLabel xb))))
            (-> (.iload xb (.parameterSlot xb 0))
                (.lookupswitch target-default (java.util.Arrays/asList scs)))
            (dotimes [i (alength scs)]
              (-> (.labelBinding xb (.target (aget scs i)))
                  (.ldc (aget mhds i))
                  (.areturn)))
            (-> (.labelBinding xb target-default)
                (.aconst_null)
                (.areturn))))]
  
  (defn- class-elements-virtual ^void [^ClassBuilder cb ^MethodSpec/1 specs
                                       ^DirectMethodHandleDesc/1 mhds
                                       ^ClassDesc this-class ^String this-name
                                       ^MethodTypeDesc factory-mtd
                                       ^String/1 afield-mnm
                                       ^HashMap origin-to-load
                                       ^EnvMethod/1 ems]
    (let [constr-mtd (-> factory-mtd
                         (.insertParameterTypes 0 runtime/map)
                         (.changeReturnType ConstantDescs/CD_void))]
      ;; virtual fields holding the closed over environment
      (dotimes [i (alength afield-mnm)]
        (.withField cb (aget afield-mnm i) (.parameterType factory-mtd i)
                    (model/acc* private final)))
      ;; virtual methods implementing the function arities
      (let [source-order (source-order-idxs specs)]
        (dotimes [j (alength specs)]
          (let [i (aget source-order j)
                em (aget ems i)]
            (virtual-method cb origin-to-load (aget specs i) this-class
                            (.this-name em) (aget mhds i)
                            (.origin-to-proxy em)))))
      ;; virtual method __arityOrNull
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (let [at-last (.at (aget specs (dec (alength specs))))]
              (assert (not (model/translates-to-varargs? at-last)))
              (if (= (alength mhds) 1)
                (arity-fixed-1 xb (aget mhds 0))
                (arity-fixed-n xb mhds))))
           (.withMethodBody cb runtime/name-arity-method
                            runtime/mtd-arity-method
                            (model/acc* public final synthetic)))
      ;; virtual method __directMethodHandles
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.loadConstant xb (alength mhds))
                (.anewarray runtime/MethodHandle))
            (dotimes [i (alength mhds)]
              (-> (.dup xb)
                  (.loadConstant i)
                  (.ldc (aget mhds i))
                  (.aastore)))
            (.areturn xb))
           (.withMethodBody cb runtime/name-dmh-method
                            runtime/mtd-dmh-method
                            (model/acc* public final synthetic)))
      ;; private constructor <init>
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (dotimes [i (dec (.parameterCount constr-mtd))]
              (-> (.aload xb (.receiverSlot xb))
                  (.loadLocal (TypeKind/from (.parameterType constr-mtd (inc i)))
                              (.parameterSlot xb (inc i)))
                  (.putfield this-class (aget afield-mnm i)
                             (.parameterType constr-mtd (inc i)))))
            (-> (.aload xb (.receiverSlot xb))
                (.aload (.parameterSlot xb 0))
                (.invokespecial runtime/AFn ConstantDescs/INIT_NAME
                                runtime/mtd-void-map)
                (.return_)))
           (.withMethodBody cb ConstantDescs/INIT_NAME constr-mtd
                            (model/acc* private synthetic)))
      ;; public static factory method __create
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> xb
                (.new_ this-class)
                (.dup)
                (.aconst_null))
            (dotimes [i (.parameterCount factory-mtd)]
              (.loadLocal xb (TypeKind/from (.parameterType factory-mtd i))
                          (.parameterSlot xb i)))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb runtime/name-factory-method factory-mtd
                            (model/acc* public static final synthetic)))
      ;; protected virtual method __withMetaImpl
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.new_ xb this-class)
                (.dup)
                (.aload (.parameterSlot xb 0)))
            ;; FIXME... use field entities' emit method
            (dotimes [i (alength afield-mnm)]
              (-> (.aload xb (.receiverSlot xb))
                  (.getfield this-class (aget afield-mnm i)
                             (.parameterType constr-mtd (inc i)))))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb runtime/name-with-meta-impl
                            (MethodTypeDesc/of this-class runtime/map)
                            (model/acc* protected final synthetic))))))

(defn- as-fn-virtual ^SegmentAcc [^SegmentAcc acc ^EnvClass class]
  (let [this-class (envgraph/namespace-class class)
        super-class runtime/AFn
        fn-proxy ^IEmitProxy (.class-task class)
        method-specs (.method-specs fn-proxy)
        construction-ops (-> (doto (envgraph/class-origin-to-proxy class)
                               (.remove fn-proxy))
                             (envgraph/sorted-ops))
        mhds (new DirectMethodHandleDesc/1 (alength method-specs))
        fn-virtual (FnVirtual. (.entity-id fn-proxy) method-specs mhds
                               this-class (.aorigin construction-ops))]
    (.set-emit-entity! fn-proxy fn-virtual)
    (set-virtual-mhd! mhds this-class method-specs)
    
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (let [factory-mtd (-> this-class
                                (factory-mtd-for (.aorigin construction-ops)))
                constr-mtd (-> factory-mtd
                               (.insertParameterTypes 0 runtime/map)
                               (.changeReturnType ConstantDescs/CD_void))
                origin-to-load (doto (field-getters this-class construction-ops)
                                 (.put fn-proxy (entity-this this-class)))
                afield-mnm (munged-field-names construction-ops)]
            (-> (cfg/with-class-version cb)
                (.withFlags fn-virtual-class-flags)
                (.withSuperclass super-class)
                (class-elements-virtual method-specs mhds
                                        this-class (.class-name class)
                                        factory-mtd afield-mnm
                                        origin-to-load (.methods class)))))
         (model/mk-nmsp-class this-class super-class)
         (envgraph/add-class-file acc))))

;;; ------------------------------------------------------------------------

(deftype FnProxy [^AritySpec/1 arity-specs ^MethodSpec/1 method-specs
                  ^int entity-id ^:unsynchronized-mutable ^Entity __emit]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (.emit-insn* __emit xb consumed-type then-leave?))
  
  Entity
  (value-type [_]
    tinyclj.lang.AFnMh)
  (value-type-exact [_]
    (.value-type-exact __emit))
  (entity-id [_]
    entity-id)
  (method-specs [_]
    method-specs)
  (invoke* [this fctx form opt-f m-idx xs]
    (let [at (.at (aget method-specs m-idx))]
      (-> (^CodeEmitter fn [xb consumed-type then-leave?]
           (-> (.get-emit-entity this)  ;trampoline to get current entity
               (.invoke* fctx form opt-f m-idx xs)
               (insn/emitter)
               (.emit-insn* xb consumed-type then-leave?)))
          (insn/mk-insn (.return-type at)))))
  
  IEmitProxy
  (set-emit-entity! [_ ent]
    (set! __emit ent))
  (get-emit-entity [_]
    __emit)

  PreparationTask
  (extend-segment [_ acc class]
    (if (envgraph/fn-closes-over-env? class)
      (as-fn-virtual acc class)
      (as-fn-static acc (-> class .segment .segment-class)
                    (.class-name class) ^IEmitProxy (.class-task class)))))

(defn partial-fn-literal ^FnProxy [^int entity-id ^AritySpec/1 arity-specs]
  (let [method-specs (new MethodSpec/1 (alength arity-specs))]
    (dotimes [i (alength method-specs)]
      (aset method-specs i (-> (.at (aget arity-specs i))
                               (MethodSpec. nil nil nil i nil))))
    (->> (^java.util.Comparator fn ^int [^MethodSpec o1 ^MethodSpec o2]
          (Integer/compare (-> o1 .at .parameter-count)
                           (-> o2 .at .parameter-count)))
         (java.util.Arrays/sort method-specs))
    (FnProxy. arity-specs method-specs entity-id nil)))

(defn update-arities ^FnProxy [^FnProxy fn-proxy ^MethodSpec/1 arity-methods]
  ;; update overwrite any auto-return-marker return types
  (let [arity-specs (.arity-specs fn-proxy)]
    (dotimes [i (alength arity-specs)]
      (let [aspec (aget arity-specs i)
            mspec (aget arity-methods i)
            at (if (type/auto-return-marker? (-> aspec .at .return-type))
                 (let [expr-tp (insn/expr-type (.x-body mspec))
                       logical-tp (type/expr-to-logical expr-tp)]
                   (model/with-return-type (.at aspec) logical-tp))
                 (.at aspec))]
        (->> (AritySpec. at (.body aspec) (.error-context aspec))
             (aset arity-specs i))))
    (let [method-specs (.method-specs fn-proxy)]
      (dotimes [i (alength method-specs)]
        (let [j (.source-idx (aget method-specs i))
              mspec (aget arity-methods j)
              at* (.at (aget arity-specs j))]
          (aset method-specs i (MethodSpec. at* (.code mspec) (.x-body mspec)
                                            (.parameters mspec) j nil))))
      fn-proxy)))

;;; ------------------------------------------------------------------------

(defn- set-construction-ops! ^void [^OriginProxyPairs/1 aops ^EnvMethod/1 ems]
  (dotimes [i (alength aops)]
    (aset aops i (envgraph/sorted-ops (.origin-to-proxy (aget ems i))))))

(deftype FnItf [^MethodSpec/1 method-specs ^DirectMethodHandleDesc/1 mhds
                ^Class itf-class ^String method-name
                ^MethodTypeDesc lookup-type
                ^OriginProxyPairs/1 aconstruction-ops]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (entity/with-void-empty-if-requested consumed-type
      (let [spec (aget method-specs 0)
            at (.at spec)
            d-mtd (mtd-of-arity-type at)
            env (aget aconstruction-ops 0)
            inv-type (MethodTypeDesc/of (reflect/describe-class itf-class)
                                        ^List (env-type-descs env))
            dcd (DynamicCallSiteDesc/of rt/bsm-metafactory method-name inv-type
                                        lookup-type (aget mhds 0) d-mtd)]
        (-> (load-origin-values xb (.aorigin env)) (.invokedynamic dcd))
        itf-class)))
  PreparationTask
  (extend-segment [_ acc class]
    (set-construction-ops! aconstruction-ops (.methods class))
    (set-static-mhd! mhds (-> class .segment .segment-class)
                     (.class-name class) aconstruction-ops method-specs)
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (class-elements-static cb method-specs mhds nil aconstruction-ops))
         (envgraph/add-segment-elements acc))))

(defn itf-fn ^FnItf [^MethodSpec/1 method-specs ^Class itf-class
                     ^DirectMethodHandleDesc itf-method]
  (let [mhds (new DirectMethodHandleDesc/1 1)]
    (FnItf. method-specs mhds itf-class (.methodName itf-method)
            (-> itf-method .invocationType (.dropParameterTypes 0 1))
            (new OriginProxyPairs/1 1))))

;;; ------------------------------------------------------------------------

(deftype DefInterface [^NmspClass eph-ncl]
  PreparationTask
  (extend-segment [_ acc _]
    (envgraph/add-class-file acc eph-ncl)))

(def task-definterface* DefInterface/new)

;;; ------------------------------------------------------------------------

(def ^:private m-valAt (resolve/virtual-method IPersistentMap
                                               "valAt" Object Object))
(def ^:pricate mtd-seqOrElse (MethodTypeDesc/of ConstantDescs/CD_Object
                                                ConstantDescs/CD_Object))
(def ^:private mtd-without (MethodTypeDesc/of runtime/map
                                              ConstantDescs/CD_Object))
(defn- dt-create-record ^void [^ClassBuilder cb ^ClassDesc this-class
                               ^FieldSpec/1 fields]
  (->> (^Consumer fn ^void [^CodeBuilder xb]
        (let [arg-0 (-> (LocalVariable. "m" IPersistentMap -1 nil
                                        (.parameterSlot xb 0))
                        (insn/mk-insn IPersistentMap))
              kws (new Insn/1 (- (alength fields) 4))]
          (dotimes [i (alength kws)]
            (let [kw (keyword nil (.field-name (aget fields i)))]
              (aset kws i (-> (entity/collection kw Keyword false)
                              (insn/mk-insn Keyword)))))
          
          (-> xb (.new_ this-class) (.dup))
          (dotimes [i (alength kws)]
            (let [xs (insn/insns-of (aget kws i) insn/insn-null)
                  x (insn/invoke-member m-valAt arg-0 xs context/fctx-none)]
              (emit/insn? xb context/fctx-none (.type (aget fields i))
                          (.emitter x))))
          (-> xb (.aconst_null) (insn/emit-logical? arg-0))
          (dotimes [i (alength kws)]
            (insn/emit-logical? xb (aget kws i))
            (.invokeinterface xb runtime/map "without" mtd-without))
          (-> (.invokestatic xb runtime/RT "seqOrElse" mtd-seqOrElse)
              (.iconst_0) (.iconst_0 )
              (.invokespecial this-class ConstantDescs/INIT_NAME
                              (model/mtd-of-fields fields))
              (.areturn))))
       (.withMethodBody cb "create" (MethodTypeDesc/of this-class runtime/map)
                        (model/acc* public static synthetic))))

(defn- dt-virtual-methods ^void [^ClassBuilder cb ^MethodSpec/1 method-specs]
  (dotimes [i (alength method-specs)]
    (let [spec (aget method-specs i)]
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (emit-body xb spec -1))
           (.withMethodBody cb (.method-name spec)
                            (-> (mtd-of-arity-type (.at spec))
                                (.dropParameterTypes 0 1))
                            (model/acc* public))))))

(defn- missing-record-methods ^map [^FieldSpec/1 field-specs
                                    ^MethodSpec/1 method-specs]
  (reduce (fn ^map [^map acc ^MethodSpec spec]
            (if-some [mtd (get acc (.method-name spec))]
              (cond-> acc
                (= mtd (-> (mtd-of-arity-type (.at spec))
                           (.dropParameterTypes 0 1)))
                (dissoc (.method-name spec)))
              acc))
          (into {"toString" runtime/mtd-String-void
                 "hashCode" runtime/mtd-int-void
                 "equals" runtime/mtd-boolean-Object}
                (map (fn ^vector [^FieldSpec spec]
                       [(.field-name spec)
                        (MethodTypeDesc/of (.type-desc spec))]))
                field-specs)
          method-specs))

(defn- object-method ^void [^ClassBuilder cb ^BootstrapMethodEntry bsm-entry
                            ^ClassDesc this-class ^String nm
                            ^MethodTypeDesc mtd]
  (->> (^Consumer fn ^void [^CodeBuilder xb]
        (let [cp (.constantPool xb)
              t (.insertParameterTypes mtd 0 this-class)
              n+t (.nameAndTypeEntry cp nm t)]
          (.aload xb (.receiverSlot xb))
          (dotimes [i (.parameterCount mtd)]
            (.loadLocal xb (TypeKind/from (.parameterType mtd i))
                        (.parameterSlot xb i)))
          (-> (.invokedynamic xb (.invokeDynamicEntry cp bsm-entry n+t))
              (.return_ (TypeKind/from (.returnType mtd))))))
       (.withMethodBody cb nm mtd (model/acc* public synthetic))))

(defn- record-methods ^void [^ClassBuilder cb ^ClassDesc this-class
                             ^FieldSpec/1 field-specs
                             ^MethodSpec/1 method-specs]
  (let [missing (missing-record-methods field-specs method-specs)
        cp (.constantPool cb)
        fnames (->> (map FieldSpec/.field-name field-specs)
                    (str/join ";"))
        field-getter-mhd (fn ^DirectMethodHandleDesc [^FieldSpec spec]
                           (MethodHandleDesc/ofField
                            DirectMethodHandleDesc$Kind/GETTER
                            this-class (.field-name spec)
                            (.type-desc spec)))
        bsm-entry (.bsmEntry cp runtime/bsm-object-method
                             ^List (->> (map field-getter-mhd field-specs)
                                        (list* this-class fnames)))]
    (doseq [nm ["toString" "hashCode" "equals"]]
      (when-some [mtd (get missing nm)]
        (object-method cb bsm-entry this-class nm mtd)))
    
    (dotimes [i (alength field-specs)]
      (let [spec (aget field-specs i), nm (.field-name spec)]
        (when-some [mtd (get missing nm)]
          (->> (^Consumer fn ^void [^CodeBuilder xb]
                (-> (.aload xb (.receiverSlot xb))
                    (.getfield this-class nm (.type-desc spec))
                    (.return_ (TypeKind/from (.type-desc spec)))))
               (.withMethodBody cb nm mtd (model/acc* public synthetic))))))))

(deftype DefType [^NmspClass eph-ncl ^FieldSpec/1 field-specs
                  ^MethodSpec/1 method-specs
                  ^boolean java-record? ^boolean defrecord?]
  PreparationTask
  (extend-segment [_ acc class]
    (->> (.andThen (.class-handler eph-ncl)
                   (^Consumer fn ^void [^ClassBuilder cb]
                    (when defrecord?
                      (dt-create-record cb (.this-class eph-ncl) field-specs))
                    (dt-virtual-methods cb method-specs)
                    (when java-record?
                      (record-methods cb (.this-class eph-ncl)
                                      field-specs method-specs))))
         (model/with-class-handler eph-ncl)
         (envgraph/add-class-file acc))))

(def task-deftype* DefType/new)
