(ns tcljx.classgen.fngen
  (:require
   (tcljx.data [config :as cfg] [type :as type] [reflect :as reflect] resolve
               [model :as model])
   (tcljx.classgen [classfile :as classfile] [runtime :as runtime]
                   [emit :as emit] [runtime :as rt] [entity :as entity]
                   [insn :as insn] [envgraph :as envgraph]))
  (:import
   (tcljx.data.model Constant ArityType AritySpec CodeEmitter Entity)
   (tcljx.data.resolve Match)
   (tcljx.classgen.envgraph EnvMethod EnvProxy IEmitProxy SegmentAcc)
   (tcljx.classgen.entity LocalVariable)
   (tcljx.classgen.insn Insn Insns)
   (tcljx.classgen.envgraph EnvClass OriginProxyPairs PreparationTask)
   (java.lang.classfile ClassFile ClassBuilder CodeBuilder TypeKind)
   (java.lang.classfile.instruction SwitchCase)
   (java.lang.constant ClassDesc MethodTypeDesc MethodHandleDesc
                       ConstantDesc DirectMethodHandleDesc ConstantDescs
                       DirectMethodHandleDesc$Kind
                       DynamicConstantDesc DynamicCallSiteDesc)
   (java.lang.reflect Executable)
   (java.util List HashMap)
   (java.util.function Consumer)))

(definterface RecurrableBlock
  :extends [CodeEmitter]
  (recur-variables ^Entity/1 [])
  (body ^Insn []))

(defn- env-type-descs ^seq [^OriginProxyPairs env]
  (map Entity/.value-type-exact (.aorigin env)))
(defn- mtd-of-arity-type
  (^MethodTypeDesc [^ArityType at]
   (MethodTypeDesc/of (reflect/describe-class (.return-type at))
                      (reflect/describe-class* (.parameter-types at))))
  (^MethodTypeDesc [^seq prefix ^ArityType at]
   (let [ptps (concat prefix (map reflect/describe-class (.parameter-types at)))]
     (MethodTypeDesc/of (reflect/describe-class (.return-type at)) ^List ptps))))

(defn- emit-body ^void [^CodeBuilder xb ^AritySpec spec ^int first-param-no]
  (let [return-type (-> spec .at .return-type)
        body ^RecurrableBlock (-> spec .code .emitter)
        parameters (.recur-variables body)]
    (dotimes [i (alength parameters)]
      (let [param-no (+ first-param-no i)]
        (.emit-setup-code? ^LocalVariable (aget parameters i) xb param-no)))
    (emit/then-leave? xb cfg/no-line-number return-type body true)))

;;; ------------------------------------------------------------------------

(deftype FnStatic [^int entity-id ^AritySpec/1 arity-specs
                   ^DirectMethodHandleDesc/1 mhds]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (-> (.computational-value this)
        (entity/mk-constant (.value-type this))
        (.emit-insn* xb consumed-type then-leave?)))
  
  Entity
  (value-type [_]
    tinyclj.lang.StaticFn)
  (value-type-exact [_]
    runtime/StaticFn)
  (entity-id [_]
    entity-id)
  (arity-specs [_]
    arity-specs)
  (invoke* [this fctx form _ at-idx xs]
    (let [at (.at (aget arity-specs at-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (insn/emit-invoke-arity (aget mhds at-idx) at xs fctx xb))
          (insn/mk-insn (.return-type at)))))
  
  Constant
  (computational-value [_] ;never nil, but may require owner to be known
    (DynamicConstantDesc/ofNamed rt/bsm-static-fn ConstantDescs/DEFAULT_NAME
                                 rt/StaticFn mhds)))

(letfn [(arity-parameter-types ^Class/1 [^Match m]
          (let [ptypes (.parameter-types m)]
            (if (reflect/takes-receiver? (.member m))
              (let [a (new Class/1 (inc (alength ptypes)))]
                (aset a 0 (.owner m))
                (System/arraycopy ptypes 0 a 1 (alength ptypes))
                a)
              ptypes)))
        (arity-spec-of-match ^AritySpec [^Match m]
          (let [varargs? (when (instance? Executable (.member m))
                           (.isVarArgs ^Executable (.member m)))
                ptypes (arity-parameter-types m)
                at (ArityType. (.return-type m) ptypes nil varargs?)
                mhd (reflect/mhd-of-member (.owner m) (.member m))]
            (AritySpec. at nil mhd nil nil 0)))]

  (defn class-member-fn ^FnStatic [^Match m]
    (let [spec (arity-spec-of-match m)]
      (FnStatic. model/entity-id-constant
                 (doto (new AritySpec/1 1)
                   (aset 0 spec))
                 (doto (new DirectMethodHandleDesc/1 1)
                   (aset 0 (.redirection spec)))))))

;;; ------------------------------------------------------------------------

(defn- factory-mtd-for ^MethodTypeDesc [^ClassDesc this-class ^Entity/1 ents]
  (let [tps (new Class/1 (alength ents))]
    (dotimes [i (alength tps)]
      (aset tps i (.value-type (aget ents i))))
    (MethodTypeDesc/of this-class (reflect/describe-class* tps))))

(defn- load-origin-values ^CodeBuilder [^CodeBuilder xb ^Entity/1 aorigin]
  ;; FIXME... origin does not work when not provided by the parent method
  (dotimes [i (alength aorigin)]
    (let [ent (aget aorigin i)]
      (.emit-insn* ent xb (.value-type ent) false)))
  xb)

(deftype FnVirtual [^int entity-id ^AritySpec/1 arity-specs
                    ^DirectMethodHandleDesc/1 mhds
                    ^ClassDesc this-class ^Entity/1 aorigin]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (-> (load-origin-values xb aorigin)
        (.invokestatic this-class runtime/name-factory-method
                       (factory-mtd-for this-class aorigin)))
    tinyclj.lang.AFnMh)
  
  Entity
  (value-type [_]
    tinyclj.lang.AFnMh)
  (value-type-exact [_]
    this-class)
  (entity-id [_]
    entity-id)
  (arity-specs [_]
    arity-specs)
  (invoke* [this fctx form f at-idx xs]
    (let [at (.at (aget arity-specs at-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insn? xb fctx tinyclj.lang.AFnMh f)
             (insn/emit-invoke-arity (aget mhds at-idx) at xs fctx xb)))
          (insn/mk-insn (.return-type at))))))

;;; -----------------------------------------------------------------------

(defn- set-static-mhd!
  (^void [^DirectMethodHandleDesc/1 mhds ^ClassDesc owner ^String name-prefix
          ^AritySpec/1 specs]
   (dotimes [i (alength mhds)]
     (let [spec (aget specs i)]
       (->> (or (.redirection spec)
                (let [at (.at spec)
                      nm (str name-prefix "~" (.parameter-count at))]
                  (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                                             owner nm (mtd-of-arity-type at))))
            (aset mhds i)))))
  (^void [^DirectMethodHandleDesc/1 mhds ^ClassDesc owner ^String name-prefix
          ^OriginProxyPairs/1 aenv ^AritySpec/1 specs]
   (dotimes [i (alength mhds)]
     (let [spec (aget specs i), env (aget aenv i)]
       (->> (let [at (.at spec)
                  nm (str name-prefix "~" (.parameter-count at))
                  mtd (mtd-of-arity-type (env-type-descs env) at)]
              (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                                         owner nm mtd))
            (aset mhds i))))))

(letfn [(provide-env-as-parameters ^CodeBuilder [^CodeBuilder xb
                                                 ^OriginProxyPairs env]
          (dotimes [i (alength (.aorigin env))]
            (let [origin (aget (.aorigin env) i)
                  proxy (aget (.aproxy env) i)
                  ent (LocalVariable. (.local-name proxy) (.value-type origin)
                                      0 nil -1)]
              (.emit-setup-code? ent xb i)
              (.set-emit-entity! proxy ent)))
          xb)]
  (defn- class-elements-static ^void [^ClassBuilder cb ^AritySpec/1 specs
                                      ^DirectMethodHandleDesc/1 mhds
                                      ^OriginProxyPairs/1 aenv]
    (let [source-order (model/source-order-idxs specs)]
      (dotimes [j (alength specs)]
        (let [i (aget source-order j)
              spec (aget specs i)
              mhd (aget mhds i)
              mtd (MethodTypeDesc/ofDescriptor (.lookupDescriptor mhd))
              first-param-no (if (some? aenv)
                               (alength (.aorigin (aget aenv i)))
                               0)]
          (when (or (some? aenv) (nil? (.redirection spec)))
            (classfile/with-method-body-> cb
              [(.methodName mhd) mtd classfile/acc-method-static]
              (cond-> #_xb
                (some? aenv) (provide-env-as-parameters (aget aenv i))
                true (emit-body spec first-param-no)))))))))

(defn- as-fn-static ^SegmentAcc [^SegmentAcc acc ^ClassDesc owner
                                 ^String name-prefix ^IEmitProxy fn-proxy]
  (let [arity-specs (.arity-specs fn-proxy)
        mhds (new DirectMethodHandleDesc/1 (alength arity-specs))
        fn-static (FnStatic. (.entity-id fn-proxy) arity-specs mhds)]
    (set-static-mhd! mhds owner name-prefix arity-specs)
    (.set-emit-entity! fn-proxy fn-static)
       
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (class-elements-static cb arity-specs mhds nil))
         (envgraph/add-segment-elements acc))))

;;; ------------------------------------------------------------------------

(def ^:private public-static-final (bit-or ClassFile/ACC_PUBLIC
                                           ClassFile/ACC_STATIC
                                           ClassFile/ACC_FINAL))
(def ^:private private-final (bit-or ClassFile/ACC_PRIVATE
                                     ClassFile/ACC_FINAL))
(def ^:private public-final (bit-or ClassFile/ACC_PUBLIC
                                    ClassFile/ACC_FINAL))
(def ^:private protected-final (bit-or ClassFile/ACC_PROTECTED
                                       ClassFile/ACC_FINAL))
(def ^:private fn-virtual-class-flags (bit-or ClassFile/ACC_PUBLIC
                                              ClassFile/ACC_FINAL))

(defn- virtual-field ^Entity [^ClassDesc owner ^String nm ^Class type]
  (let [type-desc (reflect/describe-class type)]
    (reify Entity
      (emit-insn* [_ xb _ _]
        (-> (.aload xb (.receiverSlot xb))
            (.getfield owner nm type-desc))
        type)
      (value-type [_]
        type)
      (entity-id [_]
        -1))))

(defn- field-type ^Class [^OriginProxyPairs construction-ops ^int i]
  (.value-type (aget (.aorigin construction-ops) i)))
(defn- field-type-desc ^ClassDesc [^OriginProxyPairs construction-ops ^int i]
  (reflect/describe-class (field-type construction-ops i)))
(defn- field-names ^String/1 [^OriginProxyPairs construction-ops]
  (let [aproxy (.aproxy construction-ops)
        a (new String/1 (alength aproxy))]
    (dotimes [i (alength a)]
      (aset a i (.local-name (aget aproxy i))))
    a))
(defn- field-getters ^HashMap [^ClassDesc owner
                               ^OriginProxyPairs construction-ops]
  (let [aorigin (.aorigin construction-ops)
        aproxy (.aproxy construction-ops)
        acc (HashMap.)]
    (dotimes [i (alength aorigin)]
      (let [origin (aget aorigin i)]
        (.put acc origin (virtual-field owner (.local-name (aget aproxy i))
                                        (.value-type origin)))))
    acc))

(defn- set-virtual-mhd! ^void [^DirectMethodHandleDesc/1 mhds
                               ^ClassDesc owner ^AritySpec/1 specs]
  (dotimes [i (alength mhds)]
    (let [at (.at (aget specs i))
          mnm (str "fn" (.parameter-count at))]
      (->> (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/VIRTUAL
                                      owner mnm (mtd-of-arity-type at))
           (aset mhds i)))))

(letfn [(virtual-method ^void [^ClassBuilder cb ^HashMap origin-to-load
                               ^AritySpec spec ^ClassDesc this-class
                               ^String this-name ^DirectMethodHandleDesc mhd
                               ^HashMap origin-to-proxy]
          (doseq [[origin ^EnvProxy proxy] (.entrySet origin-to-proxy)]
            (.set-emit-entity! proxy (.get origin-to-load origin)))
          (->> (^Consumer fn ^void [^CodeBuilder xb]
                (-> (.localVariable xb (.receiverSlot xb) this-name
                                    this-class (.startLabel xb) (.endLabel xb))
                    (emit-body spec 0)))
               (.withMethodBody cb (.methodName mhd)
                                (mtd-of-arity-type (.at spec)) public-final)))

        (arity-parameter-count ^int [^DirectMethodHandleDesc mhd]
          (dec (.parameterCount (.invocationType mhd))))
        (arity-fixed-1 ^void [^CodeBuilder xb ^DirectMethodHandleDesc mhd]
          (let [target-default (.newLabel xb)]
            (-> (.iload xb (.parameterSlot xb 0))
                (.loadConstant (arity-parameter-count mhd))
                (.if_icmpne target-default) (.ldc mhd) (.areturn)
                (.labelBinding target-default) (.aconst_null) (.areturn))))
        (arity-fixed-n ^void [^CodeBuilder xb ^DirectMethodHandleDesc/1 mhds]
          (let [scs (new SwitchCase/1 (alength mhds))
                target-default (.newLabel xb)]
            (dotimes [i (alength scs)]
              (aset scs i (SwitchCase/of (arity-parameter-count (aget mhds i))
                                         (.newLabel xb))))
            (-> (.iload xb (.parameterSlot xb 0))
                (.lookupswitch target-default (java.util.Arrays/asList scs)))
            (dotimes [i (alength scs)]
              (-> (.labelBinding xb (.target (aget scs i)))
                  (.ldc (aget mhds i))
                  (.areturn)))
            (-> (.labelBinding xb target-default)
                (.aconst_null)
                (.areturn))))]
  
  (defn- class-elements-virtual ^void [^ClassBuilder cb ^AritySpec/1 specs
                                       ^DirectMethodHandleDesc/1 mhds
                                       ^ClassDesc this-class ^String this-name
                                       ^MethodTypeDesc factory-mtd
                                       ^String/1 field-names
                                       ^HashMap origin-to-load
                                       ^EnvMethod/1 ems]
    (let [constr-mtd (-> factory-mtd
                         (.insertParameterTypes 0 runtime/map)
                         (.changeReturnType ConstantDescs/CD_void))]
      ;; virtual fields holding the closed over environment
      (dotimes [i (alength field-names)]
        (.withField cb (aget field-names i) (.parameterType factory-mtd i)
                    private-final))
      ;; virtual methods implementing the function arities
      (let [source-order (model/source-order-idxs specs)]
        (dotimes [j (alength specs)]
          (let [i (aget source-order j)
                em (aget ems i)]
            (virtual-method cb origin-to-load (aget specs i) this-class
                            (.this-name em) (aget mhds i)
                            (.origin-to-proxy em)))))
      ;; virtual method __arityOrNull
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (let [at-last (.at (aget specs (dec (alength specs))))]
              (assert (not (model/translates-to-varargs? at-last)))
              (if (= (alength mhds) 1)
                (arity-fixed-1 xb (aget mhds 0))
                (arity-fixed-n xb mhds))))
           (.withMethodBody cb runtime/name-arity-method
                            runtime/mtd-arity-method public-final))
      ;; virtual method __directMethodHandles
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.loadConstant xb (alength mhds))
                (.anewarray runtime/MethodHandle))
            (dotimes [i (alength mhds)]
              (-> (.dup xb)
                  (.loadConstant i)
                  (.ldc (aget mhds i))
                  (.aastore)))
            (.areturn xb))
           (.withMethodBody cb runtime/name-dmh-method
                            runtime/mtd-dmh-method public-final))
      ;; private constructor <init>
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (dotimes [i (dec (.parameterCount constr-mtd))]
              (-> (.aload xb (.receiverSlot xb))
                  (.loadLocal (TypeKind/from (.parameterType constr-mtd (inc i)))
                              (.parameterSlot xb (inc i)))
                  (.putfield this-class (aget field-names i)
                             (.parameterType constr-mtd (inc i)))))
            (-> (.aload xb (.receiverSlot xb))
                (.aload 1)
                (.invokespecial runtime/AFn ConstantDescs/INIT_NAME
                                runtime/mtd-void-map)
                (.return_)))
           (.withMethodBody cb ConstantDescs/INIT_NAME constr-mtd
                            ClassFile/ACC_PRIVATE))
      ;; public static factory method __create
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> xb
                (.new_ this-class)
                (.dup)
                (.aconst_null))
            (dotimes [i (.parameterCount factory-mtd)]
              (.loadLocal xb (TypeKind/from (.parameterType factory-mtd i))
                          (.parameterSlot xb i)))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb runtime/name-factory-method factory-mtd
                            public-static-final))
      ;; protected virtual method __withMetaImpl
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.new_ xb this-class)
                (.dup)
                (.aload (.parameterSlot xb 0)))
            ;; FIXME... use field entities' emit method
            (dotimes [i (alength field-names)]
              (-> (.aload xb (.receiverSlot xb))
                  (.getfield this-class (aget field-names i)
                             (.parameterType constr-mtd (inc i)))))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb runtime/name-with-meta-impl
                            (MethodTypeDesc/of this-class runtime/map)
                            protected-final)))))

(defn- as-fn-virtual ^SegmentAcc [^SegmentAcc acc ^EnvClass class]
  (let [this-class (envgraph/namespace-class class)
        super-class runtime/AFn
        fn-proxy ^IEmitProxy (.class-task class)
        arity-specs (.arity-specs fn-proxy)
        construction-ops (-> (envgraph/class-origin-to-proxy class)
                             (envgraph/sorted-ops))
        mhds (new DirectMethodHandleDesc/1 (alength arity-specs))
        fn-virtual (FnVirtual. (.entity-id fn-proxy) arity-specs mhds
                               this-class (.aorigin construction-ops))]
    (.set-emit-entity! fn-proxy fn-virtual)
    (set-virtual-mhd! mhds this-class arity-specs)
    
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (let [factory-mtd (-> this-class
                                (factory-mtd-for (.aorigin construction-ops)))
                constr-mtd (-> factory-mtd
                               (.insertParameterTypes 0 runtime/map)
                               (.changeReturnType ConstantDescs/CD_void))
                origin-to-load (field-getters this-class construction-ops)
                field-names (field-names construction-ops)]
            (-> (cfg/with-class-version cb)
                (.withFlags fn-virtual-class-flags)
                (.withSuperclass super-class)
                (class-elements-virtual arity-specs mhds
                                        this-class (.class-name class)
                                        factory-mtd field-names
                                        origin-to-load (.methods class)))))
         (model/mk-nmsp-class this-class super-class)
         (envgraph/add-class-file acc))))

;;; ------------------------------------------------------------------------

(deftype FnProxy [^AritySpec/1 arity-specs ^int entity-id
                  ^:unsynchronized-mutable ^Entity __emit-entity]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (.emit-insn* __emit-entity xb consumed-type then-leave?))
  
  Entity
  (value-type [_]
    tinyclj.lang.AFnMh)
  (value-type-exact [_]
    (.value-type-exact __emit-entity))
  (entity-id [_]
    entity-id)
  (arity-specs [_]
    arity-specs)
  (invoke* [this fctx form opt-f at-idx xs]
    (let [at (.at (aget arity-specs at-idx))]
      (-> (^CodeEmitter fn [xb consumed-type then-leave?]
           (-> (.get-emit-entity this)  ;trampoline to get current entity
               (.invoke* fctx form opt-f at-idx xs)
               (insn/emitter)
               (.emit-insn* xb consumed-type then-leave?)))
          (insn/mk-insn (.return-type at)))))
  
  IEmitProxy
  (set-emit-entity! [_ ent]
    (set! __emit-entity ent))
  (get-emit-entity [_]
    __emit-entity)

  PreparationTask
  (extend-segment [_ acc class]
    (if (envgraph/closes-over-env? class)
      (as-fn-virtual acc class)
      (as-fn-static acc (-> class .segment .segment-class)
                    (.class-name class) ^IEmitProxy (.class-task class)))))

(defn partial-fn-literal ^FnProxy [^int entity-id
                                   ^AritySpec/1 partial-arity-specs]
  (FnProxy. partial-arity-specs entity-id nil))

(defn update-arities ^FnProxy [^FnProxy fn-proxy ^Insns arity-codes]
  ;; update overwrite any auto-return-marker return types
  (let [arity-specs (.arity-specs fn-proxy)]
    (dotimes [i (alength arity-specs)]
      (let [spec (aget arity-specs i)
            rt (-> spec .at .return-type)
            va? (model/translates-to-varargs? (.at spec))
            code (.get arity-codes i)
            method-block ^RecurrableBlock (.emitter code)
            redir (insn/redirecting-to (-> method-block .body) rt va?
                                       (.recur-variables method-block))]
        (->> (AritySpec. (if (type/auto-return-marker? rt)
                           (let [expr-tp (insn/expr-type code)
                                 logical-tp (type/expr-to-logical expr-tp)]
                             (model/with-return-type (.at spec) logical-tp))
                           (.at spec))
                         (.body spec) redir (.error-context spec) code
                         (.source-idx spec))
             (aset arity-specs i)))))
  fn-proxy)

;;; ------------------------------------------------------------------------

(defn- set-construction-ops! ^void [^OriginProxyPairs/1 aops ^EnvMethod/1 ems]
  (dotimes [i (alength aops)]
    (aset aops i (envgraph/sorted-ops (.origin-to-proxy (aget ems i))))))

(deftype FnItf [^AritySpec/1 arity-specs ^DirectMethodHandleDesc/1 mhds
                ^Class itf-class ^String method-name
                ^MethodTypeDesc lookup-type
                ^OriginProxyPairs/1 aconstruction-ops]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (entity/with-void-empty-if-requested consumed-type
      (let [spec (aget arity-specs 0)
            at (.at spec)
            d-mtd (mtd-of-arity-type at)
            env (aget aconstruction-ops 0)
            inv-type (MethodTypeDesc/of (reflect/describe-class itf-class)
                                        ^List (env-type-descs env))
            dcd (DynamicCallSiteDesc/of rt/bsm-metafactory method-name inv-type
                                        lookup-type (aget mhds 0) d-mtd)]
        (-> (load-origin-values xb (.aorigin env)) (.invokedynamic dcd))
        itf-class)))
  PreparationTask
  (extend-segment [_ acc class]
    (set-construction-ops! aconstruction-ops (.methods class))
    (set-static-mhd! mhds (-> class .segment .segment-class)
                     (.class-name class) aconstruction-ops arity-specs)
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (class-elements-static cb arity-specs mhds aconstruction-ops))
         (envgraph/add-segment-elements acc))))

(defn itf-fn ^FnItf [^AritySpec/1 arity-specs ^Class itf-class
                     ^DirectMethodHandleDesc itf-method]
  (let [mhds (new DirectMethodHandleDesc/1 1)]
    (FnItf. arity-specs mhds itf-class (.methodName itf-method)
            (-> itf-method .invocationType (.dropParameterTypes 0 1))
            (new OriginProxyPairs/1 1))))

