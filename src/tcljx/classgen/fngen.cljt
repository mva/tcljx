(ns tcljx.classgen.fngen
  (:require
   (tcljx.data [type :as type] [model :as model] [reflect :as reflect] resolve)
   (tcljx.classgen [runtime :as runtime] [classfile :as classfile]
                   [emit :as emit] [runtime :as rt] [entity :as entity]
                   [insn :as insn] [envgraph :as envgraph]))
  (:import
   (tcljx.data.model Constant ArityType AritySpec CodeEmitter Entity)
   (tcljx.data.resolve Match)
   (tcljx.classgen.emit ClosureBlueprint EnvProxy SegmentAcc IEmitProxy)
   (tcljx.classgen.insn Insn Insns)
   (tcljx.classgen.envgraph EnvClass OriginProxyPairs PreparationTask)
   (java.lang.classfile ClassFile ClassBuilder CodeBuilder TypeKind)
   (java.lang.classfile.instruction SwitchCase)
   (java.lang.constant ClassDesc MethodTypeDesc MethodHandleDesc
                       ConstantDesc DirectMethodHandleDesc DynamicConstantDesc
                       ConstantDescs DirectMethodHandleDesc$Kind)
   (java.lang.reflect Executable)
   (java.util HashMap)
   (java.util.function Consumer)))

(defn- mtd-of-arity-type ^MethodTypeDesc [^ArityType at]
  (MethodTypeDesc/of (reflect/describe-class (.return-type at))
                     (reflect/describe-class* (.parameter-types at))))

;;; ------------------------------------------------------------------------

(deftype FnStatic [^int entity-id ^AritySpec/1 arity-specs
                   ^DirectMethodHandleDesc/1 mhds]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (-> (.computational-value this)
        (entity/mk-constant (.value-type this))
        (.emit-insn* xb consumed-type then-leave?)))
  
  Entity
  (value-type [_]
    tinyclj.lang.StaticFn)
  (value-type-exact [_]
    runtime/StaticFn)
  (entity-id [_]
    entity-id)
  (arity-specs [_]
    arity-specs)
  (invoke* [this fctx form _ at-idx xs]
    (let [at (.at (aget arity-specs at-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (insn/emit-invoke-arity (aget mhds at-idx) at xs fctx xb))
          (insn/mk-insn (.return-type at)))))
  
  Constant
  (computational-value [_] ;never nil, but may require owner to be known
    (DynamicConstantDesc/ofNamed rt/bsm-static-fn ConstantDescs/DEFAULT_NAME
                                 rt/StaticFn mhds)))

(letfn [(arity-parameter-types ^Class/1 [^Match m]
          (let [ptypes (.parameter-types m)]
            (if (reflect/takes-receiver? (.member m))
              (let [a (new Class/1 (inc (alength ptypes)))]
                (aset a 0 (.owner m))
                (System/arraycopy ptypes 0 a 1 (alength ptypes))
                a)
              ptypes)))
        (arity-spec-of-match ^AritySpec [^Match m]
          (let [varargs? (when (instance? Executable (.member m))
                           (.isVarArgs ^Executable (.member m)))
                ptypes (arity-parameter-types m)
                at (ArityType. (.return-type m) ptypes nil varargs?)
                mhd (reflect/mhd-of-member (.owner m) (.member m))]
            (AritySpec. at nil mhd nil nil 0)))]

  (defn class-member-fn ^FnStatic [^Match m]
    (let [spec (arity-spec-of-match m)]
      (FnStatic. model/entity-id-constant
                 (doto (new AritySpec/1 1)
                   (aset 0 spec))
                 (doto (new DirectMethodHandleDesc/1 1)
                   (aset 0 (.redirection spec)))))))

;;; ------------------------------------------------------------------------

(defn- factory-mtd-for ^MethodTypeDesc [^ClassDesc this-class ^Entity/1 ents]
  (let [tps (new Class/1 (alength ents))]
    (dotimes [i (alength tps)]
      (aset tps i (.value-type (aget ents i))))
    (MethodTypeDesc/of this-class (reflect/describe-class* tps))))

(deftype FnVirtual [^int entity-id ^AritySpec/1 arity-specs
                    ^DirectMethodHandleDesc/1 mhds
                    ^ClassDesc this-class
                    ^OriginProxyPairs construction-ops]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (when (emit/entities? xb (.aorigin construction-ops))
      (.invokestatic xb this-class runtime/name-factory-method
                     (factory-mtd-for this-class (.aorigin construction-ops)))
      tinyclj.lang.AFnMh))
  
  Entity
  (value-type [_]
    tinyclj.lang.AFnMh)
  (value-type-exact [_]
    this-class)
  (entity-id [_]
    entity-id)
  (arity-specs [_]
    arity-specs)
  (invoke* [this fctx form f at-idx xs]
    (let [at (.at (aget arity-specs at-idx))]
      (-> (^CodeEmitter fn [xb _ _]
           (when (emit/insn? xb fctx tinyclj.lang.AFnMh f)
             (insn/emit-invoke-arity (aget mhds at-idx) at xs fctx xb)))
          (insn/mk-insn (.return-type at))))))

;;; -----------------------------------------------------------------------

(defn- set-static-mhd! ^void [^DirectMethodHandleDesc/1 mhds
                              ^ClassDesc owner ^String method-name-prefix
                              ^AritySpec/1 specs]
  (dotimes [i (alength mhds)]
    (let [spec (aget specs i)]
      (->> (or (.redirection spec)
               (let [at (.at spec)
                     nm (str method-name-prefix "~" (.parameter-count at))]
                 (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/STATIC
                                            owner nm (mtd-of-arity-type at))))
           (aset mhds i)))))

(defn- class-elements-static ^void [^ClassBuilder cb ^AritySpec/1 specs
                                   ^DirectMethodHandleDesc/1 mhds]
  (let [source-order (model/source-order-idxs specs)]
    (dotimes [j (alength specs)]
      (let [i (aget source-order j)
            spec (aget specs i)
            mhd (aget mhds i)
            mtd (MethodTypeDesc/ofDescriptor (.lookupDescriptor mhd))]
        (when (nil? (.redirection spec))
          (classfile/with-method-body-> cb
            [(.methodName mhd) mtd classfile/acc-method-static]
            (insn/emit-return (-> spec .at .return-type)
                              (.code spec))))))))

(defn- as-fn-static ^SegmentAcc [^SegmentAcc acc ^ClassDesc owner
                                 ^String name-prefix ^IEmitProxy fn-proxy]
  (let [arity-specs (.arity-specs fn-proxy)
        mhds (new DirectMethodHandleDesc/1 (alength arity-specs))
        fn-static (FnStatic. (.entity-id fn-proxy) arity-specs mhds)]
    (set-static-mhd! mhds owner name-prefix arity-specs)
    (.set-emit-entity! fn-proxy fn-static)
       
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (class-elements-static cb arity-specs mhds))
         (emit/add-segment-elements acc))))

;;; ------------------------------------------------------------------------

(def ^:private public-static-final (bit-or ClassFile/ACC_PUBLIC
                                           ClassFile/ACC_STATIC
                                           ClassFile/ACC_FINAL))
(def ^:private private-final (bit-or ClassFile/ACC_PRIVATE
                                     ClassFile/ACC_FINAL))
(def ^:private public-final (bit-or ClassFile/ACC_PUBLIC
                                    ClassFile/ACC_FINAL))
(def ^:private protected-final (bit-or ClassFile/ACC_PROTECTED
                                       ClassFile/ACC_FINAL))
(def ^:private fn-virtual-class-flags (bit-or ClassFile/ACC_PUBLIC
                                              ClassFile/ACC_FINAL))

(defn- virtual-field ^Entity [^ClassDesc owner ^String nm ^Class type]
  (let [type-desc (reflect/describe-class type)]
    (reify Entity
      (emit-insn* [_ xb _ _]
        (-> (.aload xb (.receiverSlot xb))
            (.getfield owner nm type-desc))
        type)
      (value-type [_]
        type)
      (entity-id [_]
        -1))))

(defn- field-type ^Class [^OriginProxyPairs construction-ops ^int i]
  (.value-type (aget (.aorigin construction-ops) i)))
(defn- field-type-desc ^ClassDesc [^OriginProxyPairs construction-ops ^int i]
  (reflect/describe-class (field-type construction-ops i)))
(defn- field-names ^String/1 [^OriginProxyPairs construction-ops]
  (let [aproxy (.aproxy construction-ops)
        a (new String/1 (alength aproxy))]
    (dotimes [i (alength a)]
      (aset a i (.local-name (aget aproxy i))))
    a))
(defn- field-getters ^HashMap [^ClassDesc owner
                               ^OriginProxyPairs construction-ops]
  (let [aorigin (.aorigin construction-ops)
        aproxy (.aproxy construction-ops)
        acc (HashMap.)]
    (dotimes [i (alength aorigin)]
      (let [origin (aget aorigin i)]
        (.put acc origin (virtual-field owner (.local-name (aget aproxy i))
                                        (.value-type origin)))))
    acc))

(defn- set-virtual-mhd! ^void [^DirectMethodHandleDesc/1 mhds
                               ^ClassDesc owner ^AritySpec/1 specs]
  (dotimes [i (alength mhds)]
    (let [at (.at (aget specs i))
          mnm (str "fn" (.parameter-count at))]
      (->> (MethodHandleDesc/ofMethod DirectMethodHandleDesc$Kind/VIRTUAL
                                      owner mnm (mtd-of-arity-type at))
           (aset mhds i)))))

(letfn [(virtual-method ^void [^ClassBuilder cb ^HashMap origin-to-load
                               ^AritySpec spec ^ClassDesc this-class
                               ^String this-name ^DirectMethodHandleDesc mhd
                               ^HashMap origin-to-proxy]
          (doseq [[origin ^EnvProxy proxy] (.entrySet origin-to-proxy)]
            (.set-emit-entity! proxy (.get origin-to-load origin)))
          (->> (^Consumer fn ^void [^CodeBuilder xb]
                (-> (.localVariable xb (.receiverSlot xb) this-name
                                    this-class (.startLabel xb) (.endLabel xb)))
                (insn/emit-return xb (-> spec .at .return-type) (.code spec)))
               (.withMethodBody cb (.methodName mhd)
                                (mtd-of-arity-type (.at spec)) public-final)))

        (arity-fixed ^void [^CodeBuilder xb ^ClassDesc this-class
                            ^DirectMethodHandleDesc/1 mhds]
          (let [scs (new SwitchCase/1 (alength mhds))
                target-default (.newLabel xb)]
            (dotimes [i (alength scs)]
              (let [inv-tp (.invocationType (aget mhds i))]
                (aset scs i (SwitchCase/of (dec (.parameterCount inv-tp))
                                           (.newLabel xb)))))
            (-> (.iload xb (.parameterSlot xb 0))
                (.lookupswitch target-default (java.util.Arrays/asList scs)))
            (dotimes [i (alength scs)]
              (-> (.labelBinding xb (.target (aget scs i)))
                  (.ldc (aget mhds i))
                  (.areturn)))
            (-> (.labelBinding xb target-default)
                (.aconst_null)
                (.areturn))))]
  
  (defn- class-elements-virtual ^void [^ClassBuilder cb ^AritySpec/1 specs
                                       ^DirectMethodHandleDesc/1 mhds
                                       ^ClassDesc this-class ^String this-name
                                       ^MethodTypeDesc factory-mtd
                                       ^String/1 field-names
                                       ^HashMap origin-to-load
                                       ^ClosureBlueprint/1 cbps]
    (let [constr-mtd (-> factory-mtd
                         (.insertParameterTypes 0 runtime/map)
                         (.changeReturnType ConstantDescs/CD_void))]
      ;; virtual fields holding the closed over environment
      (dotimes [i (alength field-names)]
        (.withField cb (aget field-names i) (.parameterType factory-mtd i)
                    private-final))
      ;; virtual methods implementing the function arities
      (let [source-order (model/source-order-idxs specs)]
        (dotimes [j (alength specs)]
          (let [i (aget source-order j)]
            (virtual-method cb origin-to-load (aget specs i) this-class
                            this-name (aget mhds i)
                            (.origin-to-proxy (aget cbps i))))))
      ;; virtual method __arityOrNull
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (let [at-last (.at (aget specs (dec (alength specs))))]
              (assert (not (model/translates-to-varargs? at-last)))
              (arity-fixed xb this-class mhds)))
           (.withMethodBody cb runtime/name-arity-method
                            runtime/mtd-arity-method public-final))
      ;; virtual method __directMethodHandles
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.loadConstant xb (alength mhds))
                (.anewarray runtime/MethodHandle))
            (dotimes [i (alength mhds)]
              (-> (.dup xb)
                  (.loadConstant i)
                  (.ldc (aget mhds i))
                  (.aastore)))
            (.areturn xb))
           (.withMethodBody cb runtime/name-dmh-method
                            runtime/mtd-dmh-method public-final))
      ;; private constructor <init>
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (dotimes [i (dec (.parameterCount constr-mtd))]
              (-> (.aload xb (.receiverSlot xb))
                  (.loadLocal (TypeKind/from (.parameterType constr-mtd (inc i)))
                              (.parameterSlot xb (inc i)))
                  (.putfield this-class (aget field-names i)
                             (.parameterType constr-mtd (inc i)))))
            (-> (.aload xb (.receiverSlot xb))
                (.aload 1)
                (.invokespecial runtime/AFn ConstantDescs/INIT_NAME
                                runtime/mtd-void-map)
                (.return_)))
           (.withMethodBody cb ConstantDescs/INIT_NAME constr-mtd
                            ClassFile/ACC_PRIVATE))
      ;; public static factory method __create
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> xb
                (.new_ this-class)
                (.dup)
                (.aconst_null))
            (dotimes [i (.parameterCount factory-mtd)]
              (.loadLocal xb (TypeKind/from (.parameterType factory-mtd i))
                          (.parameterSlot xb i)))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb runtime/name-factory-method factory-mtd
                            public-static-final))
      ;; protected virtual method __withMetaImpl
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> (.new_ xb this-class)
                (.dup)
                (.aload (.parameterSlot xb 0)))
            ;; FIXME... use field entities' emit method
            (dotimes [i (alength field-names)]
              (-> (.aload xb (.receiverSlot xb))
                  (.getfield this-class (aget field-names i)
                             (.parameterType constr-mtd (inc i)))))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb runtime/name-with-meta-impl
                            (MethodTypeDesc/of this-class runtime/map)
                            protected-final)))))

(defn- as-fn-virtual ^SegmentAcc [^SegmentAcc acc ^EnvClass class]
  (let [cbf (.cbf class)
        this-class (ClassDesc/of (.packageName (.owner cbf))
                                 (.class-name cbf))
        fn-proxy ^IEmitProxy (.fn-proxy cbf)
        arity-specs (.arity-specs fn-proxy)
        construction-ops (-> (envgraph/class-origin-to-proxy class)
                             (envgraph/sorted-ops))
        mhds (new DirectMethodHandleDesc/1 (alength arity-specs))
        fn-virtual (FnVirtual. (.entity-id fn-proxy) arity-specs mhds
                               this-class construction-ops)]
    (.set-emit-entity! fn-proxy fn-virtual)
    (set-virtual-mhd! mhds this-class arity-specs)
    
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (let [factory-mtd (-> this-class
                                (factory-mtd-for (.aorigin construction-ops)))
                constr-mtd (-> factory-mtd
                               (.insertParameterTypes 0 runtime/map)
                               (.changeReturnType ConstantDescs/CD_void))
                origin-to-load (field-getters this-class construction-ops)
                field-names (field-names construction-ops)]
            (class-elements-virtual cb arity-specs mhds
                                    this-class (.this-name cbf)
                                    factory-mtd field-names
                                    origin-to-load (.closures cbf))))
         (emit/add-class-file acc this-class fn-virtual-class-flags
                              runtime/AFn))))

;;; ------------------------------------------------------------------------

(deftype FnProxy [^AritySpec/1 arity-specs ^int entity-id
                  ^:unsynchronized-mutable ^Entity __emit-entity]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (.emit-insn* __emit-entity xb consumed-type then-leave?))
  
  Entity
  (value-type [_]
    tinyclj.lang.AFnMh)
  (value-type-exact [_]
    (.value-type-exact __emit-entity))
  (entity-id [_]
    entity-id)
  (arity-specs [_]
    arity-specs)
  (invoke* [this fctx form opt-f at-idx xs]
    (let [at (.at (aget arity-specs at-idx))]
      (-> (^CodeEmitter fn [xb consumed-type then-leave?]
           (-> (.get-emit-entity this)  ;trampoline to get current entity
               (.invoke* fctx form opt-f at-idx xs)
               (insn/emitter)
               (.emit-insn* xb consumed-type then-leave?)))
          (insn/mk-insn (.return-type at)))))
  
  IEmitProxy
  (set-emit-entity! [_ ent]
    (set! __emit-entity ent))
  (get-emit-entity [_]
    __emit-entity)

  PreparationTask
  (extend-segment [_ acc class]
    (if (some? class) ;ignore unless called with environment information
      (let [cbf (.cbf class)]
        #_(prn :prepare-fn-proxy (.class-name cbf))
        (if (envgraph/closes-over-env? class)
          (as-fn-virtual acc class)
          (as-fn-static acc (.owner cbf) (.class-name cbf) (.fn-proxy cbf))))
      acc)))

(defn partial-fn-literal ^FnProxy [^int entity-id
                                   ^AritySpec/1 partial-arity-specs]
  (FnProxy. partial-arity-specs entity-id nil))

(defn update-arities ^FnProxy [^FnProxy fn-proxy ^Insns arity-codes]
  ;; update overwrite any auto-return-marker return types
  (let [arity-specs (.arity-specs fn-proxy)]
    (dotimes [i (alength arity-specs)]
      (let [spec (aget arity-specs i)
            rt (-> spec .at .return-type)
            va? (model/translates-to-varargs? (.at spec))
            code (.get arity-codes i)
            redir (insn/redirecting-to code rt va? nil)]
        (->> (AritySpec. (if (type/auto-return-marker? rt)
                           (let [expr-tp (insn/expr-type code)
                                 logical-tp (type/expr-to-logical expr-tp)]
                             (model/with-return-type (.at spec) logical-tp))
                           (.at spec))
                         (.body spec) redir (.error-context spec) code
                         (.source-idx spec))
             (aset arity-specs i)))))
  fn-proxy)
