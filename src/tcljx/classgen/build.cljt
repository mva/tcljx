(ns tcljx.classgen.build
  (:require
   (tcljx.data [config :as cfg] [files :as files] [type :as type]
               [context :as context] [ir :as ir] [resolve :as resolve])
   (tcljx.classgen [classfile :as classfile] [runtime :as rt]
                   [envgraph :as envgraph] [emit :as emit] [insn :as insn]
                   [segment :as segment] [fngen :as fngen])
   [tinyclj.string :as str])
  (:import
   (tcljx.data.ir CodeEmitter Resolver NmspClass)
   (tcljx.classgen.classfile PackageBuilder)
   (tcljx.classgen.segment Segment CodePromise SegmentAcc)
   (tcljx.classgen.insn Insn)
   (java.lang.classfile ClassBuilder CodeBuilder)
   (java.lang.constant ClassDesc ConstantDescs MethodTypeDesc)
   (java.util ArrayList)
   (java.util.function Consumer)))

(def ^:private segment-class-flags (ir/acc* public abstract))

(defn- with-requires ^ClassBuilder [^ClassBuilder cb ^String req-str]
  (classfile/with-method-body->
    cb [rt/name-requires (MethodTypeDesc/of ConstantDescs/CD_String)
        (bit-or classfile/acc-method-static (ir/acc* synthetic))]
    (-> (.ldc req-str) (.areturn))))

(def ^:private mtd-void-String
  (MethodTypeDesc/of ConstantDescs/CD_void ConstantDescs/CD_String))
(defn segment ^NmspClass [^PackageBuilder pkg-build ^String source-file
                          ^Segment segm ^SegmentAcc segm-acc ^Resolver rsv]
  (doseq [ncl (.other-classes segm-acc)]
    (classfile/declare-class pkg-build ncl))
  (doseq [^NmspClass ncl (.other-classes segm-acc)]
    (classfile/bwdi pkg-build ncl))

  (letfn [(invoke-create-nmsp ^void [^CodeBuilder xb]
            (-> xb
                (.ldc (.pkg-name segm))
                (.invokestatic rt/RT "createNamespace" mtd-void-String)))
          (invoke-mark-core-init ^void [^CodeBuilder xb]
            (-> xb
                (.ldc (str (.pkg-name segm) "."
                           (-> segm .segment-class .displayName)))
                (.invokestatic rt/RT "markCoreInitialization"
                               mtd-void-String)))]
    (->> (^Consumer fn ^void [^ClassBuilder cb]
          (-> (cfg/with-class-version cb)
              (classfile/with-source-file source-file)
              (.withFlags segment-class-flags))
          (let [al (.class-elements segm-acc)]
            (dotimes [i (.size al)]
              (.accept ^Consumer (.get al i) cb)))
      
          (.withMethodBody
           cb ConstantDescs/CLASS_INIT_NAME ConstantDescs/MTD_void
           (ir/acc* public static)
           (^Consumer fn ^void [^CodeBuilder xb]
            (when (identical? ConstantDescs/CD_Object (.super-class segm))
              (invoke-create-nmsp xb))
            (let [al (.clinit-statms segm-acc)]
              (loop [i 0]
                (if (< i (.size al))
                  (when (emit/statm? xb (insn/emitter (.get al i)))
                    (recur (inc i)))
                  (do (when (cfg/core-lib? (.pkg-name segm))
                        (invoke-mark-core-init xb))
                      (.return_ xb))))))))
         (ir/mk-nmsp-class (.segment-class segm) (.super-class segm))
         (classfile/bwdi pkg-build))))

;;; ------------------------------------------------------------------------

(defn capstone ^NmspClass [^PackageBuilder pkg-build ^Segment segm]
  (let [req-str (if (cfg/core-lib? (.pkg-name segm))
                  ""            ;suppress internal details of core lib
                  ;; FIXME... use real requires
                  (str/join "," (sort (list "tinyclj.core"))))]
    (->> (^Consumer fn ^void [^ClassBuilder cb]
                     (-> (cfg/with-class-version cb)
                         (.withFlags segment-class-flags)
                         (.withSuperclass (.super-class segm))
                         (with-requires req-str)))
         (ir/mk-nmsp-class (segment/capstone-class segm) (.super-class segm))
         (classfile/bwdi pkg-build))))

;;; ------------------------------------------------------------------------

(defn prepare-segment ^SegmentAcc [^Segment segm ^int tasks-end]
  (let [tasks (.tasks segm)
        sps (segment/flatten (.tasks segm) tasks-end)]
    (letfn [(index-of-promise ^int [^CodePromise promise ^int start]
              (loop [i start]
                (if (identical? promise (aget sps i))
                  i
                  (recur (inc i)))))
            (deliver-promises ^SegmentAcc [^SegmentAcc acc ^int start ^int end]
              (loop [acc acc, i start]
                (if (< i end)
                  (recur (.generate-and-deliver (aget sps i) acc) (inc i))
                  acc)))
            (mk-segment-acc ^SegmentAcc []
              (SegmentAcc. (ArrayList.) (ArrayList.) (ArrayList.)
                           (.segment-class segm)))]
      
      (loop [acc (mk-segment-acc), i-clinit 0, i-eg 0]
        (if (< i-clinit tasks-end)
          (let [task (.get tasks i-clinit)]
            (if (instance? CodePromise task)
              (let [end-eg (inc (index-of-promise task i-eg))]
                (recur (deliver-promises acc i-eg end-eg) (inc i-clinit) end-eg))
              (recur (segment/add-clinit-statm acc task) (inc i-clinit) i-eg)))
          acc)))))
