(ns tcljx.classgen.build
  (:require
   (tcljx.data [config :as cfg] [files :as files] [type :as type]
               [context :as context] [ir :as ir] [resolve :as resolve])
   (tcljx.classgen [classfile :as classfile] [runtime :as rt] [util :as util]
                   segment [emit :as emit] [insn :as insn] [fngen :as fngen])
   [tinyclj.string :as str])
  (:import
   (tcljx.data.ir CodeEmitter Entity MethodSpec NmspClass)
   (tcljx.classgen.classfile PackageBuilder)
   (tcljx.classgen.segment Segment CodePromise SegmentBuilder)
   (tcljx.classgen.fngen FnPromiseImpl)
   (java.lang.classfile ClassBuilder CodeBuilder)
   (java.lang.constant ClassDesc ConstantDescs MethodTypeDesc)
   (java.util List ArrayList HashSet)
   (java.util.function Consumer Predicate)))

(def ^:private segment-class-flags (ir/acc* public abstract))

(defn- with-requires ^ClassBuilder [^ClassBuilder cb ^String req-str]
  (classfile/with-method-body->
    cb [rt/name-requires (MethodTypeDesc/of ConstantDescs/CD_String)
        (bit-or classfile/acc-method-static (ir/acc* synthetic))]
    (-> (.ldc req-str) (.areturn))))

(def ^:private mtd-void-String
  (MethodTypeDesc/of ConstantDescs/CD_void ConstantDescs/CD_String))
(defn- clinit-body ^void [^CodeBuilder xb ^Segment segm
                          ^CodeEmitter/1 clinit-statms]
  (letfn [(invoke-create-nmsp ^void [^CodeBuilder xb]
            (-> xb
                (.ldc (.pkg-name segm))
                (.invokestatic rt/RT "createNamespace" mtd-void-String)))
          (invoke-mark-core-init ^void [^CodeBuilder xb]
            (-> xb
                (.ldc (str (.pkg-name segm) "."
                           (-> segm .segment-class .displayName)))
                (.invokestatic rt/RT "markCoreInitialization"
                               mtd-void-String)))]
    (when (identical? ConstantDescs/CD_Object (.super-class segm))
      (invoke-create-nmsp xb))
    (emit/statms? xb clinit-statms)
    (when (cfg/core-lib? (.pkg-name segm))
      (invoke-mark-core-init xb))
    (.return_ xb)))

(defn segment ^Consumer [^String source-file ^Segment segm
                         ^ArrayList class-elements ^CodeEmitter/1 clinit-statms]
  (^Consumer fn ^void [^ClassBuilder cb]
   (-> (cfg/with-class-version cb)
       (.withSuperclass (.super-class segm))
       (classfile/with-source-file source-file)
       (.withFlags segment-class-flags))
   (let [al class-elements]
     (dotimes [i (.size al)]
       (.accept ^Consumer (.get al i) cb)))
   (.withMethodBody
    cb ConstantDescs/CLASS_INIT_NAME ConstantDescs/MTD_void
    (ir/acc* public static)
    (^Consumer fn ^void [^CodeBuilder xb]
     (clinit-body xb segm clinit-statms)))))

(defn- invoke-main? ^boolean [^Entity entry-main]
  (when-some [mspecs (.invoke-methods entry-main)]
    (let [at (-> mspecs (aget 0) .at)]
      (and (= (alength mspecs) 1) (= (.parameter-count at) 1)
           (ir/translates-to-varargs? at)
           (or (.variadic? at)    ;String/1 converted to seq of String
               (.isAssignableFrom (.parameter-type at 0) String/1))))))

(def ^:private acc-main (ir/acc* public static final synthetic))
(def ^:private mtd-main
  (MethodTypeDesc/of ConstantDescs/CD_void rt/StringArray))
(defn- with-main-invoke ^ClassBuilder [^ClassBuilder cb ^Entity entry-main]
  (->> (^Consumer fn ^void [^CodeBuilder xb]
        (let [x (.invoke* entry-main context/fctx-none nil entry-main 0
                          insn/insns-main-args)] ;magical arguments instance
          (emit/then-leave? xb context/fctx-none Void/TYPE (.emitter x) true)))
       (.withMethodBody cb "main" mtd-main acc-main)))
(defn- with-main-apply ^ClassBuilder [^ClassBuilder cb ^Entity entry-main]
  (->> (^Consumer fn ^void [^CodeBuilder xb]
        (emit/insn? xb context/fctx-none clojure.lang.IFn entry-main)
        (-> (.aload xb (.parameterSlot xb 0))
            (.invokestatic rt/RT "apply" rt/mtd-apply)
            (.pop)
            (.return_)))
       (.withMethodBody cb "main" mtd-main acc-main)))

(defn capstone ^Consumer [^PackageBuilder pkg-build ^Segment segm
                          ^Entity entry-main]
  (let [req-str (if (cfg/core-lib? (.pkg-name segm))
                  ""            ;suppress internal details of core lib
                  ;; FIXME... use real requires
                  (str/join "," (sort (list "tinyclj.core"))))]
    (^Consumer fn ^void [^ClassBuilder cb]
     (-> (cfg/with-class-version cb)
         (.withFlags segment-class-flags)
         (.withSuperclass (.super-class segm))
         (with-requires req-str))
     (when entry-main
       (if (invoke-main? entry-main)
         (with-main-invoke cb entry-main)
         (with-main-apply cb entry-main))))))

(def ^:private not-function (byte -2))  ;deftype, reify, itf fn
(def ^:private fn-without-runtime-value (byte -1)) ;to FnFlyweight
(def ^:private fn-optimistically-empty (byte 0)) ;undecided, then to FnStatic
(def ^:private fn-with-empty-env (byte 1)) ;to FnStatic
(def ^:private fn-carrying-env (byte 2)) ;to FnVirtual
(defn env-carrying-fns ^HashSet [^CodePromise/1 acp]
  (let [marks (new byte/1 (alength acp))
        carries-env-set (HashSet.)] ;set of `fn-carrying-env` functions
    (dotimes [i (alength marks)]
      (aset marks i (let [cp (aget acp i)]
                      (if (instance? FnPromiseImpl cp)
                        (let [fn-p ^FnPromiseImpl cp]
                          (if (.value-use? fn-p)
                            (if (.isEmpty (.env-to-display fn-p))
                              fn-with-empty-env
                              fn-optimistically-empty)
                            fn-without-runtime-value))
                        not-function))))

    (letfn [(non-empty-env? ^boolean [^FnPromiseImpl fn-p]
              (let [it (-> fn-p .env-to-display .keySet .iterator)]
                (loop []
                  (when (.hasNext it)
                    (let [origin (.next it)]
                      (cond
                        (identical? origin fn-p) ;fn refers to itself?
                        (recur)
                        (instance? FnPromiseImpl origin)
                        (or (and (FnPromiseImpl/.value-use? origin)
                                 (.contains carries-env-set origin))
                            (recur))
                        :else true))))))
            (pass-grows-set? ^boolean []
              (loop [added? false, i (dec (alength marks))]
                (if (neg? i)
                  added?
                  (recur (if (= (aget marks i) fn-optimistically-empty)
                           (let [fn-p ^FnPromiseImpl (aget acp i)]
                             (if (non-empty-env? fn-p)
                               (do #_(prn :set-marks i fn-carrying-env)
                                   (.add carries-env-set fn-p)
                                   (aset marks i fn-carrying-env)
                                   true)
                               added?))
                           added?)
                         (dec i)))))]
      ;; (prn :acp (map (comp Class/.getSimpleName class) acp))
      ;; (prn :marks-0 (seq marks))
      (loop [] (when (pass-grows-set?) (recur)))
      carries-env-set)))
