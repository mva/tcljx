(ns tcljx.classgen.typegen
  (:require
   (tcljx.data [config :as cfg] [context :as context] [resolve :as resolve]
               [ir :as ir] [code :as code])
   (tcljx.classgen [util :as util] [runtime :as rt] [emit :as emit]
                   [constgen :as constgen] [insn :as insn] [segment :as segment]
                   [envgraph :as envgraph])
   (tinyclj [string :as str]))
  (:import
   (tcljx.data.ir CodeEmitter Entity MethodSpec FieldSpec NmspClass)
   (tcljx.classgen.envgraph Display EnvDisplayPairs)
   (tcljx.classgen.insn Insn)
   (tcljx.classgen.segment CodePromise)
   (clojure.lang IPersistentMap Keyword)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind BootstrapMethodEntry)
   (java.lang.constant ClassDesc MethodTypeDesc ConstantDescs)
   (java.util ArrayList List HashMap)
   (java.util.function Consumer)))

(defn promise-definterface* ^CodePromise [^NmspClass eph-ncl]
  (reify CodePromise
    (expr-of [_]
      (insn/mk-insn (constgen/constant (.defined-class eph-ncl) Class) Class))
    (child-methods [_]
      nil)
    (!nested-parts [_]
      nil)
    (generate-and-deliver [_ acc]
      (segment/add-class-file acc eph-ncl))))

;;; ------------------------------------------------------------------------

(def ^:private m-valAt (resolve/virtual-method IPersistentMap
                                               "valAt" Object Object))
(def ^:pricate mtd-seqOrElse (MethodTypeDesc/of ConstantDescs/CD_Object
                                                ConstantDescs/CD_Object))
(def ^:private mtd-without (MethodTypeDesc/of rt/map
                                              ConstantDescs/CD_Object))
(defn- dt-create-record ^void [^ClassBuilder cb ^ClassDesc this-class
                               ^FieldSpec/1 fields]
  (->> (^Consumer fn ^void [^CodeBuilder xb]
        (let [arg-0 (-> (util/parameter* xb nil IPersistentMap 0)
                        (insn/mk-insn IPersistentMap))
              kws (new Insn/1 (- (alength fields) 4))]
          (dotimes [i (alength kws)]
            (let [kw (keyword nil (.field-name (aget fields i)))]
              (aset kws i (-> (constgen/collection kw Keyword false)
                              (insn/mk-insn Keyword)))))
          
          (-> xb (.new_ this-class) (.dup))
          (dotimes [i (alength kws)]
            (let [xs (insn/insns-of (aget kws i) insn/insn-null)
                  x (insn/invoke-member m-valAt arg-0 xs context/fctx-none)]
              (emit/insn? xb context/fctx-none (.type (aget fields i))
                          (.emitter x))))
          (-> xb (.aconst_null) (insn/emit-logical? arg-0))
          (dotimes [i (alength kws)]
            (insn/emit-logical? xb (aget kws i))
            (.invokeinterface xb rt/map "without" mtd-without))
          (-> (.invokestatic xb rt/RT "seqOrElse" mtd-seqOrElse)
              (.iconst_0) (.iconst_0 )
              (.invokespecial this-class ConstantDescs/INIT_NAME
                              (code/mtd-of-fields fields))
              (.areturn))))
       (.withMethodBody cb "create" (MethodTypeDesc/of this-class rt/map)
                        (ir/acc* public static synthetic))))

(defn- dt-virtual-methods ^void [^ClassBuilder cb ^MethodSpec/1 method-specs]
  (dotimes [i (alength method-specs)]
    (let [spec (aget method-specs i)]
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (emit/body xb spec -1))
           (.withMethodBody cb (.name spec)
                            (-> (util/mtd-of-arity-type (.at spec))
                                (.dropParameterTypes 0 1))
                            (ir/acc* public))))))

(defn- missing-record-methods ^map [^FieldSpec/1 field-specs
                                    ^MethodSpec/1 method-specs]
  (reduce (fn ^map [^map acc ^MethodSpec spec]
            (if-some [mtd (get acc (.name spec))]
              (cond-> acc
                (= mtd (-> (util/mtd-of-arity-type (.at spec))
                           (.dropParameterTypes 0 1)))
                (dissoc (.name spec)))
              acc))
          (into {"toString" rt/mtd-String-void
                 "hashCode" rt/mtd-int-void
                 "equals" rt/mtd-boolean-Object}
                (map (fn ^vector [^FieldSpec fs]
                       [(.field-name fs) (MethodTypeDesc/of (.type-desc fs))]))
                field-specs)
          method-specs))

(defn- object-method ^void [^ClassBuilder cb ^BootstrapMethodEntry bsm-entry
                            ^ClassDesc this-class ^String nm
                            ^MethodTypeDesc mtd]
  (->> (^Consumer fn ^void [^CodeBuilder xb]
        (.aload xb (.receiverSlot xb))
        (dotimes [i (.parameterCount mtd)]
          (.loadLocal xb (TypeKind/from (.parameterType mtd i))
                      (.parameterSlot xb i)))
        (-> (.invokedynamic xb (let [cp (.constantPool xb)]
                                 (->> (.insertParameterTypes mtd 0 this-class)
                                      (.nameAndTypeEntry cp nm)
                                      (.invokeDynamicEntry cp bsm-entry))))
            (.return_ (TypeKind/from (.returnType mtd)))))
       (.withMethodBody cb nm mtd (ir/acc* public synthetic))))

(defn- dt-record-methods ^void [^ClassBuilder cb ^ClassDesc this-class
                                ^FieldSpec/1 field-specs
                                ^MethodSpec/1 method-specs]
  (let [missing (missing-record-methods field-specs method-specs)
        cp (.constantPool cb)
        fnames (->> (map FieldSpec/.field-name field-specs)
                    (str/join ";"))
        bsm-entry (.bsmEntry cp rt/bsm-object-method
                             ^List (->> (map code/getter-mhd field-specs)
                                        (list* this-class fnames)))]
    (doseq [nm ["toString" "hashCode" "equals"]]
      (when-some [mtd (get missing nm)]
        (object-method cb bsm-entry this-class nm mtd)))
    
    (doseq [^FieldSpec spec field-specs
            :when (contains? missing (.field-name spec))]
      (code/with-getter cb spec))))

(defn promise-deftype ^CodePromise [^NmspClass eph-ncl ^FieldSpec/1 field-specs
                                    ^MethodSpec/1 method-specs
                                    ^boolean java-record? ^boolean defrecord?
                                    ^ArrayList !nested-parts]
  (reify CodePromise
    (expr-of [_]
      (insn/mk-insn (constgen/constant (.defined-class eph-ncl) Class) Class))
    (child-methods [_]
      method-specs)
    (!nested-parts [_]
      !nested-parts)
    (generate-and-deliver [_ acc]
      (->> (.andThen (.class-handler eph-ncl)
                     (^Consumer fn ^void [^ClassBuilder cb]
                      (when defrecord?
                        (dt-create-record cb (.this-class eph-ncl) field-specs))
                      (dt-virtual-methods cb method-specs)
                      (when java-record?
                        (dt-record-methods cb (.this-class eph-ncl)
                                           field-specs method-specs))))
           (ir/with-class-handler eph-ncl)
           (segment/add-class-file acc)))))

;;; ------------------------------------------------------------------------

(letfn [(reify-method ^void [^ClassBuilder cb ^HashMap env-to-load
                             ^MethodSpec spec]
          (doseq [[origin ^Display display]
                  (-> spec .env-to-display (.entrySet))]
            (.set-emit-entity! display (.get env-to-load origin)))
          (->> (^Consumer fn ^void [^CodeBuilder xb]
                (emit/body xb spec -1))
               (.withMethodBody cb (.name spec)
                                (-> (util/mtd-of-arity-type (.at spec))
                                    (.dropParameterTypes 0 1))
                                (ir/acc* public final))))]
  
  (defn- class-elements-reify ^void [^ClassBuilder cb ^MethodSpec/1 specs
                                     ^ClassDesc this-class ^ClassDesc super-class
                                     ^CodeEmitter meta ^FieldSpec/1 fields
                                     ^HashMap env-to-load]
    (let [constr-mtd (code/mtd-of-fields fields)]
      ;; virtual fields holding the closed over environment
      (code/with-field* cb fields)
      ;; virtual methods provided by the reify* form
      (dotimes [i (alength specs)]
        (reify-method cb env-to-load (aget specs i)))
      ;; private constructor <init>
      (code/constructor cb fields super-class
                        (ir/acc* private synthetic))
      ;; public static factory method __create
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> xb (.new_ this-class) (.dup))
            (dotimes [i (alength fields)]
              (code/load-parameter xb (aget fields i) i))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb rt/name-factory-method
                            (-> constr-mtd (.changeReturnType this-class))
                            (ir/acc* public static final synthetic)))
      ;; protected method __withMetaImpl
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> xb (.new_ this-class) (.dup)
                (.aload (.parameterSlot xb 0)))
            (dotimes [i (dec (alength fields))]
              (code/get-field xb (aget fields (inc i))))
            (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                                constr-mtd)
                (.areturn)))
           (.withMethodBody cb rt/name-with-meta-impl
                            (MethodTypeDesc/of this-class rt/map)
                            (ir/acc* protected final synthetic)))
      ;; public method meta
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (-> xb (code/get-field (aget fields 0)) (.areturn)))
           (.withMethodBody cb rt/name-meta-method
                            (MethodTypeDesc/of rt/map)
                            (ir/acc* public final synthetic))))))

(deftype Reify [^NmspClass eph-ncl ^ClassDesc/1 interfaces ^CodeEmitter meta
                ^MethodSpec/1 method-specs ^ArrayList !nested-parts
                ^:unsynchronized-mutable ^Consumer __emit]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (.accept __emit xb)     ;assume that `meta` is not safe to discard
    (.defined-class eph-ncl))
  CodePromise
  (expr-of [this]
    (insn/mk-insn this (.defined-class eph-ncl)))
  (child-methods [_]
    method-specs)
  (!nested-parts [_]
    !nested-parts)
  (generate-and-deliver [_ acc]
    (let [constr-ops (-> (envgraph/merged-env-to-display method-specs)
                         (envgraph/sorted-eds))
          aorigin (.aorigin constr-ops)]
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (when (emit/insn? xb context/fctx-none clojure.lang.IPersistentMap meta)
              (let [mtd (util/mtd-factory (.this-class eph-ncl) aorigin)]
                (-> (util/load-origin-values xb aorigin)
                    (.invokestatic (.this-class eph-ncl) rt/name-factory-method
                                   (.insertParameterTypes mtd 0 rt/map))))))
           (set! __emit))
      (->> (^Consumer fn ^void [^ClassBuilder cb]
            (let [this-class (.this-class eph-ncl)
                  field-meta (FieldSpec. this-class "__meta" nil
                                         (ir/acc* private final)
                                         rt/map clojure.lang.IPersistentMap)
                  fields (doto (envgraph/fields-exact 1 this-class constr-ops)
                           (aset 0 field-meta))
                  env-to-load (-> (.aorigin constr-ops)
                                  (envgraph/field-entity-map fields 1))]
              (-> (cfg/with-class-version cb)
                  (.withFlags (ir/acc* public final))
                  (.withSuperclass (.super-if-class eph-ncl))
                  (.withInterfaceSymbols interfaces)
                  (class-elements-reify method-specs this-class
                                        (.super-if-class eph-ncl) meta fields
                                        env-to-load))))
           (ir/mk-nmsp-class (.this-class eph-ncl) (.super-if-class eph-ncl))
           (segment/add-class-file acc)))))
(def promise-reify Reify/new)
