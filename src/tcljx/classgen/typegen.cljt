(ns tcljx.classgen.typegen
  (:require
   (tcljx.data [config :as cfg] [context :as context] [resolve :as resolve]
               [ir :as ir] [code :as code])
   (tcljx.classgen segment [util :as util] [runtime :as rt] [emit :as emit]
                   [constgen :as constgen] [insn :as insn] [fnenv :as fnenv])
   (tinyclj [string :as str]))
  (:import
   (tcljx.data.ir CodeEmitter Entity MethodSpec FieldSpec NmspClass)
   (tcljx.classgen.insn Insn)
   (tcljx.classgen.segment CodePromise Display StoredEnv)
   (clojure.lang IPersistentMap Keyword)
   (java.lang.classfile ClassBuilder CodeBuilder TypeKind BootstrapMethodEntry)
   (java.lang.constant ClassDesc MethodTypeDesc ConstantDescs)
   (java.util ArrayList List HashMap)
   (java.util.function Consumer)))

(defn promise-definterface* ^CodePromise [^NmspClass eph-ncl]
  (reify CodePromise
    (expr-of [_]
      (insn/mk-insn (constgen/constant (.defined-class eph-ncl) Class) Class))
    (child-methods [_]
      nil)
    (!nested-parts [_]
      nil)
    (generate-and-deliver [_ sb _]
      (.add-class-file sb eph-ncl))))

;;; ------------------------------------------------------------------------

(def ^:private m-valAt (resolve/virtual-method IPersistentMap
                                               "valAt" Object Object))
(def ^:pricate mtd-seqOrElse (MethodTypeDesc/of ConstantDescs/CD_Object
                                                ConstantDescs/CD_Object))
(def ^:private mtd-without (MethodTypeDesc/of rt/map
                                              ConstantDescs/CD_Object))
(defn- dt-create-record ^void [^ClassBuilder cb ^ClassDesc this-class
                               ^FieldSpec/1 fields]
  (->> (^Consumer fn ^void [^CodeBuilder xb]
        (let [arg-0 (-> (util/parameter* xb nil IPersistentMap rt/map 0)
                        (insn/mk-insn IPersistentMap))
              kws (new Insn/1 (- (alength fields) 4))]
          (dotimes [i (alength kws)]
            (let [kw (keyword nil (.field-name (aget fields i)))]
              (aset kws i (-> (constgen/collection kw Keyword false)
                              (insn/mk-insn Keyword)))))
          
          (-> xb (.new_ this-class) (.dup))
          (dotimes [i (alength kws)]
            (let [xs (insn/insns-of (aget kws i) insn/insn-null)
                  x (insn/invoke-member m-valAt arg-0 xs context/fctx-none)]
              (emit/insn? xb context/fctx-none (.type (aget fields i))
                          (.emitter x))))
          (-> xb (.aconst_null) (insn/emit-logical? arg-0))
          (dotimes [i (alength kws)]
            (insn/emit-logical? xb (aget kws i))
            (.invokeinterface xb rt/map "without" mtd-without))
          (-> (.invokestatic xb rt/RT "seqOrElse" mtd-seqOrElse)
              (.iconst_0) (.iconst_0 )
              (.invokespecial this-class ConstantDescs/INIT_NAME
                              (code/mtd-of-fields fields))
              (.areturn))))
       (.withMethodBody cb "create" (MethodTypeDesc/of this-class rt/map)
                        (ir/acc* public static synthetic))))

(defn- dt-virtual-methods ^void [^ClassBuilder cb ^MethodSpec/1 method-specs]
  (dotimes [i (alength method-specs)]
    (let [spec (aget method-specs i)]
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (emit/body xb spec -1))
           (.withMethodBody cb (.name spec)
                            (-> (util/mtd-of-arity-type (.at spec))
                                (.dropParameterTypes 0 1))
                            (ir/acc* public final))))))

(defn- missing-record-methods ^map [^FieldSpec/1 field-specs
                                    ^MethodSpec/1 method-specs]
  (reduce (fn ^map [^map acc ^MethodSpec spec]
            (if-some [mtd (get acc (.name spec))]
              (cond-> acc
                (= mtd (-> (util/mtd-of-arity-type (.at spec))
                           (.dropParameterTypes 0 1)))
                (dissoc (.name spec)))
              acc))
          (into {"toString" rt/mtd-String-void
                 "hashCode" rt/mtd-int-void
                 "equals" rt/mtd-boolean-Object}
                (map (fn ^vector [^FieldSpec fs]
                       [(.field-name fs) (MethodTypeDesc/of (.type-desc fs))]))
                field-specs)
          method-specs))

(defn- object-method ^void [^ClassBuilder cb ^BootstrapMethodEntry bsm-entry
                            ^ClassDesc this-class ^String nm
                            ^MethodTypeDesc mtd]
  (->> (^Consumer fn ^void [^CodeBuilder xb]
        (.aload xb (.receiverSlot xb))
        (dotimes [i (.parameterCount mtd)]
          (.loadLocal xb (TypeKind/from (.parameterType mtd i))
                      (.parameterSlot xb i)))
        (-> (.invokedynamic xb (let [cp (.constantPool xb)]
                                 (->> (.insertParameterTypes mtd 0 this-class)
                                      (.nameAndTypeEntry cp nm)
                                      (.invokeDynamicEntry cp bsm-entry))))
            (.return_ (TypeKind/from (.returnType mtd)))))
       (.withMethodBody cb nm mtd (ir/acc* public final synthetic))))

(defn- dt-record-methods ^void [^ClassBuilder cb ^ClassDesc this-class
                                ^FieldSpec/1 field-specs
                                ^MethodSpec/1 method-specs]
  (let [missing (missing-record-methods field-specs method-specs)
        cp (.constantPool cb)
        fnames (->> (map FieldSpec/.field-name field-specs)
                    (str/join ";"))
        bsm-entry (.bsmEntry cp rt/bsm-object-method
                             ^List (->> (map code/getter-mhd field-specs)
                                        (list* this-class fnames)))]
    (doseq [nm ["toString" "hashCode" "equals"]]
      (when-some [mtd (get missing nm)]
        (object-method cb bsm-entry this-class nm mtd)))
    
    (doseq [^FieldSpec spec field-specs
            :when (contains? missing (.field-name spec))]
      (code/with-getter cb spec))))

(def ^:private empty-env-to-display (HashMap/newHashMap 0))
(defn promise-deftype ^CodePromise [^NmspClass eph-ncl ^FieldSpec/1 field-specs
                                    ^MethodSpec/1 method-specs
                                    ^boolean java-record? ^boolean defrecord?
                                    ^ArrayList !nested-parts]
  (reify CodePromise
    (expr-of [_]
      (insn/mk-insn (constgen/constant (.defined-class eph-ncl) Class) Class))
    (child-methods [_]
      method-specs)
    (env-to-display [_]
      empty-env-to-display)
    (!nested-parts [_]
      !nested-parts)
    (generate-and-deliver [_ sb _]
      (->> (.andThen (.class-handler eph-ncl)
                     (^Consumer fn ^void [^ClassBuilder cb]
                      (when defrecord?
                        (dt-create-record cb (.this-class eph-ncl) field-specs))
                      (dt-virtual-methods cb method-specs)
                      (when java-record?
                        (dt-record-methods cb (.this-class eph-ncl)
                                           field-specs method-specs))))
           (ir/with-class-handler eph-ncl)
           (.add-class-file sb)))))

;;; ------------------------------------------------------------------------

(defn- class-elements-reify ^void [^ClassBuilder cb ^CodePromise reify-p
                                   ^ClassDesc this-class ^ClassDesc super-class
                                   ^CodeEmitter meta ^FieldSpec/1 fields]
  (let [specs (.child-methods reify-p)
        constr-mtd (code/mtd-of-fields fields)]
    ;; virtual fields holding the closed over environment
    (code/with-fields cb fields)
    ;; virtual methods provided by the reify* form
    (dotimes [i (alength specs)]
      (let [spec (aget specs i)]
        (->> (^Consumer fn ^void [^CodeBuilder xb]
              (emit/body xb spec -1))
             (.withMethodBody cb (.name spec)
                              (-> (util/mtd-of-arity-type (.at spec))
                                  (.dropParameterTypes 0 1))
                              (ir/acc* public final)))))
    ;; private constructor <init>
    (code/constructor cb fields super-class
                      (ir/acc* private synthetic))
    ;; public static factory method __create
    (->> (^Consumer fn ^void [^CodeBuilder xb]
          (-> xb (.new_ this-class) (.dup))
          (dotimes [i (alength fields)]
            (code/load-parameter xb (aget fields i) i))
          (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                              constr-mtd)
              (.areturn)))
         (.withMethodBody cb rt/name-factory-method
                          (-> constr-mtd (.changeReturnType this-class))
                          (ir/acc* public static final synthetic)))
    ;; protected method __withMetaImpl
    (->> (^Consumer fn ^void [^CodeBuilder xb]
          (-> xb (.new_ this-class) (.dup)
              (.aload (.parameterSlot xb 0)))
          (dotimes [i (dec (alength fields))]
            (code/get-field xb (aget fields (inc i))))
          (-> (.invokespecial xb this-class ConstantDescs/INIT_NAME
                              constr-mtd)
              (.areturn)))
         (.withMethodBody cb rt/name-with-meta-impl
                          (MethodTypeDesc/of this-class rt/map)
                          (ir/acc* protected final synthetic)))
    ;; public method meta
    (->> (^Consumer fn ^void [^CodeBuilder xb]
          (-> xb (code/get-field (aget fields 0)) (.areturn)))
         (.withMethodBody cb rt/name-meta-method
                          (MethodTypeDesc/of rt/map)
                          (ir/acc* public final synthetic)))))

(deftype Reify [^int entity-id ^NmspClass eph-ncl ^ClassDesc/1 interfaces
                ^CodeEmitter meta ^MethodSpec/1 method-specs
                ^HashMap env-to-display ^HashMap parent-e2d
                ^ArrayList !nested-parts
                ^:unsynchronized-mutable ^Consumer __emit]
  CodeEmitter
  (emit-insn* [this xb consumed-type then-leave?]
    (.accept __emit xb)     ;assume that `meta` is not safe to discard
    (.defined-class eph-ncl))
  Entity
  (value-type [_]
    (.defined-class eph-ncl))
  (value-type-exact [_]
    (.this-class eph-ncl))
  (invoke-methods [_]
    ir/invoke-methods-dynamic)
  (entity-id [_]
    entity-id)
  CodePromise
  (expr-of [this]
    (insn/mk-insn this (.defined-class eph-ncl)))
  (child-methods [_]
    method-specs)
  (env-to-display [_]
    env-to-display)
  (!nested-parts [_]
    !nested-parts)
  (generate-and-deliver [this sb env-factory]
    (let [env (.stored-environment! env-factory this nil)
          aorigin (.aorigin env)]
      (->> (^Consumer fn ^void [^CodeBuilder xb]
            (when (emit/insn? xb context/fctx-none clojure.lang.IPersistentMap meta)
              (let [mtd (util/mtd-factory (.this-class eph-ncl) aorigin)]
                (-> (fnenv/load-env xb parent-e2d aorigin)
                    (.invokestatic (.this-class eph-ncl) rt/name-factory-method
                                   (.insertParameterTypes mtd 0 rt/map))))))
           (set! __emit))
      (->> (^Consumer fn ^void [^ClassBuilder cb]
            (let [this-class (.this-class eph-ncl)
                  field-meta (FieldSpec. this-class "__meta" nil
                                         (ir/acc* private final)
                                         rt/map clojure.lang.IPersistentMap)
                  fields (doto (fnenv/fields-exact 1 this-class env (.aorigin env))
                           (aset 0 field-meta))]
              (fnenv/as-fields 1 fields env) ;picked up by all virtual methods below
              (-> (cfg/with-class-version cb)
                  (.withFlags (ir/acc* public final))
                  (.withSuperclass (.super-if-class eph-ncl))
                  (.withInterfaceSymbols interfaces)
                  (class-elements-reify this this-class
                                        (.super-if-class eph-ncl) meta fields))))
           (ir/mk-nmsp-class (.this-class eph-ncl) (.super-if-class eph-ncl))
           (.add-class-file sb)))))
(def promise-reify Reify/new)
