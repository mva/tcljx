(ns tcljx.classgen.entity
  (:require
   (tcljx.data [wrong :as wrong] [type :as type] [model :as model]
               [reflect :as reflect])
   (tcljx.classgen [emit :as emit] [insn :as insn] [constgen :as constgen]))
  (:import
   (tcljx.data.model Expr CodeEmitter Binding Entity Constant)
   (tcljx.classgen.insn Insn Insns)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant ClassDesc MethodTypeDesc ConstantDescs)))

(deftype ConstantImpl [^Object const-value ^Class type]
  java.lang.Record
  Constant
  (emit-insn* [_ xb line consumed-type _]
    (insn/with-void-empty-if-requested consumed-type
      (constgen/load xb const-value)
      type))
  (emit-setup-code [this xb line consumed-type _]
    (.emit-insn* this xb line consumed-type false)))

(defn mk-constant ^ConstantImpl [^Object const-value ^Class type]
  (ConstantImpl/new const-value type))

(def insn-null (insn/mk-insn (mk-constant ConstantDescs/NULL Object)
                              type/poly-reference))

(def emitter-false (mk-constant 0 Boolean/TYPE))
(def emitter-true (mk-constant 1 Boolean/TYPE))
(def insn-false (insn/mk-insn emitter-false Boolean/TYPE))
(def insn-true (insn/mk-insn emitter-true Boolean/TYPE))
(defn insn-boolean ^Insn [^boolean value] (if value insn-true insn-false))

(def emitter-int-zero (mk-constant 0 Integer/TYPE))
(def insn-int-zero (insn/mk-insn emitter-int-zero Integer/TYPE))
(def insn-int-one (insn/mk-insn (mk-constant 1 Integer/TYPE) Integer/TYPE))
(def insn-int-m1 (insn/mk-insn (mk-constant -1 Integer/TYPE) Integer/TYPE))
(def insn-float-one (insn/mk-insn (mk-constant 1.0f Float/TYPE) Float/TYPE))

(defn new-constant ^Insn [^Object value ^Class expr-type]
  #_(prn :new-constant expr-type value)
  (java.util.Objects/requireNonNull expr-type)
  (java.util.Objects/requireNonNull value)
  (cond
    (identical? ConstantDescs/NULL value)
    insn-null                          ;enforce singleton
    
    (type/same? Boolean/TYPE expr-type)
    (insn-boolean (not (zero? ^int value))) ;enforce singletons
    
    :else (insn/mk-insn (mk-constant value expr-type) expr-type)))

(defn constants? ^boolean [^Insns insns]
  (loop [i (dec (.length insns))]
    (cond (neg? i) true
          (model/const? insns i) (recur (dec i))
          :else false)))

(defn as-typed-constant-descriptions ^Object/1 [^Insns insns]
  (let [a (new Object/1 (.length insns))]
    (dotimes [i (.length insns)]
      (aset a i (constgen/typed-constant-description-of insns i)))
    a))

;;; ------------------------------------------------------------------------

(defn- dup ^CodeBuilder [^CodeBuilder xb ^Class type]
  (case (.slotSize (TypeKind/from type))
    1 (.dup xb)
    2 (.dup2 xb)))

(defn static-field ^Entity [^ClassDesc owner ^String fnm ^Class type]
  (let [type-cld (reflect/describe-class type)]
    (reify Entity
      (emit-insn* [_ xb _ _ _]
        (.getstatic xb owner fnm type-cld)
        type)
      (emit-setup-code [_ xb line consumed-type init]
        (when (emit/insn? xb line type init false)
          (if (identical? Void/TYPE consumed-type)
            (do (.putstatic xb owner fnm type-cld) Void/TYPE)
            (do (-> xb (dup type) (.putstatic owner fnm type-cld)) type)))))))

(defn static-method ^Entity [^ClassDesc owner ^String mnm ^Class type]
  (let [mtd (MethodTypeDesc/of (reflect/describe-class type))]
    (reify Entity
      (emit-insn* [_ xb _ _ _]
        (.invokestatic xb owner mnm mtd)
        type)
      (emit-setup-code [_ xb line consumed-type init]
        Void/TYPE))))

(deftype LocalVariable [^String name ^Class type
                        ^:unsynchronized-mutable ^int slot]
  Entity
  (emit-insn* [_ xb line consumed-type _]
    (insn/with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  (emit-setup-code [_ xb line consumed-type init]
    (let [tk (TypeKind/from type), label (.newLabel xb)]
      (when (emit/insn? xb line type init false)
        (set! slot (.allocateLocal xb tk))
        (-> (.storeLocal xb tk slot)
            (.labelBinding label)
            (.localVariable slot name (reflect/describe-class type)
                            label (.endLabel xb)))
        Void/TYPE))))

(defn local-variable ^Entity [^String name ^Class type]
  (LocalVariable. name type -1))

(deftype Parameter [^String name ^Class type ^int param-no
                    ^:unsynchronized-mutable ^int slot]
  Entity
  (emit-insn* [_ xb line consumed-type _]
    (insn/with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  (emit-setup-code [_ xb line consumed-type _]
    (set! slot (.parameterSlot xb param-no))
    (.localVariable xb slot name (reflect/describe-class type)
                    (.startLabel xb) (.endLabel xb))
    Void/TYPE))

(defn parameter ^Entity [^String name ^Class type ^int param-no]
  (Parameter. name type param-no -1))

;;; ------------------------------------------------------------------------

(deftype BindingImpl [^Entity bound-to ^Expr bound-value
                      ^String namespace ^String name
                      ^CodeEmitter initialize-with]
  java.lang.Record
  Binding
  (emit-insn* [this xb line consumed-type _]
    (if initialize-with
      ;; skip setup if this binding is an alias, the bound entity is a
      ;; constant, or the entity's value is provided by other means
      (.emit-setup-code bound-to xb line consumed-type initialize-with)
      Void/TYPE)))

(defn- mk-binding ^Binding [^Entity bound-to ^Insn bound-value
                            ^String namespace ^String name
                            ^CodeEmitter initialize-with]
  (BindingImpl. bound-to bound-value namespace name initialize-with))

(defn parameter-binding ^Binding [^int param-no ^String name ^Class type]
  (let [ent (parameter name type param-no)]
    (mk-binding ent (insn/mk-insn ent type) nil name insn/emitter-empty)))

(defn local-binding ^Binding [^Class opt-type ^String name init-or-bnd]
  (letfn [(non-alias-local ^Binding [^Insn init]
            (let [ce (insn/emitter init)
                  tp (or opt-type (insn/logical-type init))]
              (if (and (model/ce-const? ce) (nil? opt-type))
                (mk-binding ce init nil name nil)
                (let [ent (local-variable name tp)]
                  (mk-binding ent (insn/mk-insn ent tp) nil name
                              (.emitter init))))))]
    (if (instance? Insn init-or-bnd)
      (non-alias-local init-or-bnd)
      (let [bnd ^Binding init-or-bnd]
        (mk-binding (.bound-to bnd) (.bound-value bnd) nil name nil)))))

(defn global-binding
  (^Binding [^Entity bound-to ^String namespace ^String name]
   (mk-binding bound-to nil namespace name nil)) ;for predefined entities
  (^Binding [^Entity bound-to ^Insn bound-value ^String namespace ^String name
             ^CodeEmitter initialize-with]
   (mk-binding bound-to bound-value namespace name initialize-with)))
