(ns tcljx.classgen.entity
  (:require
   (tcljx.data [wrong :as wrong] [type :as type] [context :as context]
               [model :as model] [reflect :as reflect])
   (tcljx.classgen envgraph [constgen :as constgen]))
  (:import
   (tcljx.data.model Expr CodeEmitter Binding Entity LoadFromCopyWhenBound
                     Constant)
   (tcljx.classgen.envgraph EnvMethod)
   (java.lang.classfile CodeBuilder ClassBuilder TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc ConstantDescs)))

(defmacro with-void-empty-if-requested [consumed-type & body]
  (assert (symbol? consumed-type))
  `(if (identical? Void/TYPE ~consumed-type)
     Void/TYPE
     (do ~@body)))

;;; ------------------------------------------------------------------------

(deftype CollectionConstant [^Object loadable-value ^Class opnd-type
                             ^boolean associate-meta?]
  CodeEmitter
  (emit-insn* [this xb consumed-type _]
    (with-void-empty-if-requested consumed-type
      (.ldc xb (.loadable-entry this (.constantPool xb) false))
      opnd-type))

  Entity
  (value-type [_]
    opnd-type)
  (value-type-exact [this]
    (reflect/describe-class (.value-type this)))
  (entity-id [_]
    model/entity-id-constant)

  Constant
  (computational-value [_]
    loadable-value)
  (loadable-entry [_ cpb logical-type?]
    (if (instance? CodeEmitter/1 loadable-value)
      (if associate-meta?
        (constgen/with-meta-entry cpb opnd-type loadable-value)
        (constgen/collection-entry cpb opnd-type loadable-value))
      (constgen/loadable-entry cpb loadable-value)))
  (datafy [_]
    (letfn [(value-seq ^seq [^CodeEmitter/1 a]
              (list* (map Constant/.datafy a)))] ;wrap LazySeq
      (cond
        (seq? loadable-value) (list* loadable-value) ;wrap LazySeq
        
        (instance? CodeEmitter/1 loadable-value)
        (let [a ^CodeEmitter/1 loadable-value]
          (if associate-meta?
            (with-meta (Constant/.datafy (aget a 0))
              (Constant/.datafy (aget a 1)))
            (condp identical? opnd-type
              type/vector (vec (value-seq a))
              type/map (apply array-map (value-seq a))
              type/set (set (value-seq a))
              type/list (value-seq a))))
        
        :else loadable-value))))

(def mk-collection CollectionConstant/new)

;;; ------------------------------------------------------------------------

(defn null? ^boolean [^Object value]
  (identical? ConstantDescs/NULL value))
(defn zero? ^boolean [^Object value]
  (and (instance? Number value) (= (.doubleValue ^Number value) 0.0)))

(deftype JvmConstant [^Object computational-value ^Class opnd-type]
  CodeEmitter
  (emit-insn* [this xb consumed-type _]
    (with-void-empty-if-requested consumed-type
      (cond
        (null? computational-value)
        (do (.aconst_null xb)            ;elide any additional checkcast
            (if (.isPrimitive consumed-type)
              (.class-reference (type/of consumed-type))
              consumed-type))
        
        (type/same? opnd-type consumed-type)
        (do (if (instance? ConstantDesc computational-value)
              (.loadConstant xb ^ConstantDesc computational-value)
              (.ldc xb (.loadable-entry this (.constantPool xb) false)))
            consumed-type)
        
        (instance? Number computational-value)
        (if (.isPrimitive consumed-type)  ;cannot be void
          (do (->> (type/convert-from-constant consumed-type computational-value)
                   (.loadConstant xb))
              consumed-type)
          (do (.loadConstant xb ^ConstantDesc computational-value)
              opnd-type))
        
        :else
        (do (.ldc xb (.loadable-entry this (.constantPool xb) false))
            opnd-type))))
  
  Entity
  (value-type [_]
    opnd-type)
  (value-type-exact [this]
    (reflect/describe-class (.value-type this)))
  (entity-id [_]
    model/entity-id-constant)

  Constant
  (computational-value [_]
    computational-value)
  (loadable-entry [this cpb logical-type?]
    (->> (if logical-type? (.datafy this) computational-value)
         (constgen/loadable-entry cpb)))
  (datafy [_]
    (when-not (null? computational-value)
      (if (instance? Integer computational-value)
        (let [x ^int computational-value]
          (condp identical? opnd-type
            Integer/TYPE computational-value
            Boolean/TYPE (object (not= x 0))
            Character/TYPE (object (char x))
            Byte/TYPE (object (byte x))
            Short/TYPE (object (short x))))
        computational-value))))

(def emitter-empty (^CodeEmitter fn [xb _ _] Void/TYPE))
(defn emitter-empty? ^boolean [^CodeEmitter ce]
  (identical? emitter-empty ce))
(def entity-null (JvmConstant. ConstantDescs/NULL type/poly-reference))
(defn entity-null? ^boolean [^CodeEmitter ce]
  (identical? entity-null ce))

(def entity-false (JvmConstant. 0 Boolean/TYPE))
(def entity-true (JvmConstant. 1 Boolean/TYPE))

(defn mk-constant ^JvmConstant [^Object computational-value ^Class type]
  (cond                   ;enforce singleton for null, false, and true
    (identical? ConstantDescs/NULL computational-value)
    entity-null
    
    (type/same? Boolean/TYPE type)
    (if (tinyclj.core/zero? ^int computational-value) entity-false entity-true)
    
    :else (JvmConstant. computational-value type)))

(defn jvm-const? ^boolean [^CodeEmitter ce]
  (instance? JvmConstant ce))
(defn const? ^boolean [^CodeEmitter ce]
  (instance? Constant ce))
(defn const-value ^Object [^CodeEmitter ce]
  (when (const? ce)
    (Constant/.computational-value ce)))

(def entity-int-zero (mk-constant 0 Integer/TYPE))
(defn entity-zero? ^boolean [^CodeEmitter ce]
  (and (const? ce) (zero? (const-value ce))))

;;; ------------------------------------------------------------------------

(defn- dup ^CodeBuilder [^CodeBuilder xb ^Class type]
  (case (.slotSize (TypeKind/from type))
    1 (.dup xb)
    2 (.dup2 xb)))

(deftype LocalVariable [^String name ^Class type ^int entity-id
                        ^CodeEmitter init ^:unsynchronized-mutable ^int slot]
  CodeEmitter
  (emit-insn* [_ xb consumed-type _]
    (with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  
  Entity
  (value-type [_]
    type)
  (value-type-exact [this]
    (reflect/describe-class (.value-type this)))
  (entity-id [_]
    entity-id)
  (arity-specs [_]
    model/arity-specs-invoke-dynamic)
  (invoke* [this fctx form _ at-idx xs]
    (throw (IllegalStateException.)))
  (emit-store [_ xb]
    (.storeLocal xb (TypeKind/from type) slot))
  (emit-iinc [_ xb const]
    (.iinc xb slot const))
  
  LoadFromCopyWhenBound
  (emit-setup-code? [_ xb param-no]
    (if (neg? param-no)             ;let binding or parameter binding?
      (let [tk (TypeKind/from type), label (.newLabel xb)]
        (when-some [on-stack-type (.emit-insn* init xb type false)]
          (assert (identical? type on-stack-type))
          (set! slot (.allocateLocal xb tk))
          (-> (.storeLocal xb tk slot)
              (.labelBinding label)
              (.localVariable slot name (reflect/describe-class type)
                              label (.endLabel xb)))
          true))
      (do (set! slot (.parameterSlot xb param-no))
          (.localVariable xb slot name (reflect/describe-class type)
                          (.startLabel xb) (.endLabel xb))
          true))))

(defn local-variable ^Entity [^EnvMethod owner ^String name ^Class type
                              ^CodeEmitter init]
  (LocalVariable. name type (.next-entity-id owner) init -1))
(defn parameter ^Entity [^EnvMethod owner ^String name ^Class type]
  (local-variable owner name type emitter-empty)) ;`param-no` provided late

;;; ------------------------------------------------------------------------

(deftype BindingImpl [^Entity bound-to ^String name ^boolean alias?]
  Binding
  (emit-insn* [this xb consumed-type then-leave?]
    (when (or alias? (.emit-setup-code? ^LoadFromCopyWhenBound bound-to xb -1))
      (with-void-empty-if-requested consumed-type
        (.emit-insn* bound-to xb consumed-type then-leave?))))
  (bound-to [_]
    bound-to)
  (name [_]
    name))

(def mk-binding BindingImpl/new)

(defn parameter-binding ^Binding [^EnvMethod owner ^String name ^Class type]
  (mk-binding (parameter owner name type) name false))
