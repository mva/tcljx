(ns tcljx.classgen.entity
  (:require
   (tcljx.data
    [config :as cfg] [wrong :as wrong] [type :as type] [ir :as ir]
    [resolve :as resolve] [reflect :as reflect])
   (tcljx.classgen
    [util :as util] [constgen :as constgen] segment [envgraph :as envgraph]
    [insn :as insn] [fngen :as fngen] [typegen :as typegen]))
  (:import
   (tcljx.data.ir CodeEmitter Entity MethodSpec EntityFactory CopyOnRead)
   (tcljx.classgen.envgraph Display)
   (tcljx.classgen.insn Insn Insns)
   (tcljx.classgen.fngen FnPromise)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant ClassDesc)
   (java.util ArrayList HashMap)
   (java.util.concurrent ConcurrentHashMap)
   (java.util.function Function BiFunction)))

(def ^:private ZERO (object 0))
(deftype EntityFactoryImpl [^:unsynchronized-mutable ^int curr-entity-id
                            ^HashMap env-to-display
                            ^ConcurrentHashMap private-name-map
                            ^String pkg-name
                            ^String scope-name
                            ^ArrayList !nested-parts]
  EntityFactory
  (scope-name [_]
    scope-name)
  (closure-level [_]
    (unsigned-bit-shift-right curr-entity-id 16))
  (closes-over? [this ent]
    (let [origin (ir/closure-level ent)]
      (and (>= origin ir/closure-level-clinit)
           (not= origin (.closure-level this)))))
  (display-of! [_ origin local-name]
    (->> (^Function fn [origin] (Display. origin 0 local-name nil))
         (.computeIfAbsent env-to-display origin)))
  (value-of [this ent form]
    (assert (some? form))
    (if-some [tp (.value-type ent)]
      (insn/mk-insn (envgraph/value-of this ent form) tp)
      (throw (wrong/wr-info (str "entity " (wrong/q form)
                                 " has no runtime value")))))
  (invocation-of [this inv form]
    (envgraph/invocation-of this inv form))
  
  (expr-constant [_ value type]
    (insn/constant-insn value type))
  (entity-class-member [this m]
    (fngen/class-member-fn m))
  (entity-getstatic [this m]
    (reify
      CodeEmitter
      (emit-insn* [_ xb consumed-type _]
        (util/with-void-empty-if-requested consumed-type
          (.getstatic xb (reflect/describe-class (.owner m))
                      (.getName (.member m))
                      (reflect/describe-class (.return-type m)))
          (.return-type m)))
      Entity
      (value-type [_]
        (.return-type m))
      (entity-id [_]
        ir/entity-id-def)
      (invoke-methods [_]
        ir/invoke-methods-dynamic)
      CopyOnRead
      (alias-when-let-value? [_]
        false)))
  (new-loadable [_ value expr-type]
    (-> value (constgen/collection expr-type false) (insn/mk-insn expr-type)))
  (new-collection [this coll-type args]
    (let [args ^Insns args]
      (if (insn/loadables? args)
        (.new-loadable this (.emitters args) coll-type)
        (-> (condp identical? coll-type
              type/vector resolve/literal-vector
              type/map resolve/literal-map
              type/set resolve/literal-set
              type/list resolve/literal-list)
            (insn/invoke-runtime args)))))
  
  (next-entity-id [_]
    (set! curr-entity-id (inc curr-entity-id)))
  (local-variable [this type init]
    (util/entity-local type (.next-entity-id this) init))
  (parameter [this type]                ;`param-no` provided late
    (util/entity-local type (.next-entity-id this) constgen/emitter-empty))
  (entity-fn [this arity-specs unique-nm !fn-parts]
    (let [method-specs (new MethodSpec/1 (alength arity-specs))]
      (dotimes [i (alength method-specs)]
        (aset method-specs i (-> (.at (aget arity-specs i))
                                 (MethodSpec. nil nil nil i nil nil))))
      (->> (^java.util.Comparator fn ^int [^MethodSpec o1 ^MethodSpec o2]
            (Integer/compare (-> o1 .at .parameter-count)
                             (-> o2 .at .parameter-count)))
           (java.util.Arrays/sort method-specs))
      (FnPromise. (.next-entity-id this) method-specs unique-nm !fn-parts
                  nil false)))
  (expr-fn [this fn-entity arity-methods]
    (let [fn-p ^FnPromise fn-entity
          method-specs (.method-specs fn-p)]
      (dotimes [i (alength method-specs)]
        (let [j (.source-idx (aget method-specs i))]
          (aset method-specs i (aget arity-methods j))))
      (.stage-part! this fn-p)))
  (expr-itf-fn [_ method-specs unique-nm itf-class method !itf-parts]
    (let [p (fngen/promise-itf-fn method-specs unique-nm itf-class method
                                  !itf-parts nil)]
      (.add !nested-parts p)
      (.expr-of p)))
  (deftype-field [_ entity-id spec]
    (reify Entity
      (emit-insn* [_ xb _ _]
        (-> (.aload xb (.receiverSlot xb))
            (.getfield (.owner spec) (.field-name spec) (.type-desc spec)))
        (.type spec))
      (value-type [_]
        (.type spec))
      (value-type-exact [_]
        (.type-desc spec))
      (entity-id [_]
        entity-id)))
  (expr-deftype [this eph-ncl field-specs java-record? defrecord?
                 !dt-parts method-specs]
    (when (not= (.closure-level this) ir/closure-level-clinit)
      (throw (wrong/wr-info "cannot define class in this position")))
    (->> (typegen/promise-deftype eph-ncl field-specs method-specs
                                  java-record? defrecord? !dt-parts)
         (.stage-part! this)))
  (expr-reify [this eph-ncl interfaces meta !reify-parts method-specs]
    (->> (typegen/promise-reify eph-ncl interfaces meta method-specs
                                !reify-parts nil)
         (.stage-part! this)))
  (expr-definterface [this eph-ncl]
    (when (not= (.closure-level this) ir/closure-level-clinit)
      (throw (wrong/wr-info "cannot define class in this position")))
    (let [p (typegen/promise-definterface* eph-ncl)]
      (.add !nested-parts p)
      (.expr-of p)))
  (class-name-for-reify [this]
    (ClassDesc/of pkg-name (.unique-name! this "reify")))
  
  (binding-alias [_ fctx name ent]
    (ir/mk-binding ent name true))
  (binding-fresh [this fctx opt-type name init]
    (when opt-type
      (insn/ensure-assignable opt-type init))
    (let [tp (or opt-type (insn/logical-type init))
          ce (-> init (insn/cast-to tp fctx) .emitter)]
      (ir/mk-binding (.local-variable this tp ce) name false)))
  (binding-catching-local [this fctx type name]
    (let [ex-provider (insn/mk-insn (^CodeEmitter fn [_ _ _] type) type)]
      (.binding-fresh this fctx type name ex-provider)))

  (unique-name! [_ name-suffix]
    (let [nm (cond->> (cfg/munge-name name-suffix)
               (some? scope-name) (str scope-name "$"))
          n ^int (.compute private-name-map nm
                           (^BiFunction fn ^Integer [_ ^Integer v]
                            (if (nil? v) ZERO (object (inc ^int v)))))]
      (cond-> nm (pos? n) (str "^" n))))
  (mk-nested [this unique-nm used-entity-ids env-to-display nested-parts]
    (-> (ir/entity-id-of (inc (.closure-level this)) used-entity-ids)
        (EntityFactoryImpl. env-to-display private-name-map pkg-name unique-nm
                            nested-parts)))
  (stage-part! [_ part]
    (.add !nested-parts part)
    (.expr-of ^tcljx.classgen.segment.CodePromise part)))

(defn mk-clinit-etf ^EntityFactory [^String pkg-name ^ArrayList segment-tasks]
  (EntityFactoryImpl. (ir/entity-id-of ir/closure-level-clinit) nil
                      (ConcurrentHashMap.) pkg-name nil segment-tasks))
