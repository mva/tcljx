(ns tcljx.classgen.entity
  (:require
   (tcljx.data [wrong :as wrong] [type :as type] [context :as context]
               [model :as model] [reflect :as reflect])
   (tcljx.classgen [emit :as emit] [insn :as insn] [constgen :as constgen]))
  (:import
   (tcljx.data.model Expr CodeEmitter Binding Entity MutableEntity
                     Loadable Constant Invocable)
   (tcljx.classgen.insn Insn Insns)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc ConstantDescs)))

(deftype LoadableImpl [^Object loadable-value ^Class opnd-type
                       ^boolean associate-meta?]
  java.lang.Record
  Loadable
  (emit-insn* [this xb consumed-type _]
    (if (type/same? Void/TYPE consumed-type)
      Void/TYPE
      (do (.ldc xb (.loadable-entry this (.constantPool xb) false))
          opnd-type)))
  (value-type [_]
    opnd-type)
  (loadable-entry [_ cpb logical-type?]
    (if (instance? CodeEmitter/1 loadable-value)
      (if associate-meta?
        (constgen/with-meta-entry cpb opnd-type loadable-value)
        (constgen/collection-entry cpb opnd-type loadable-value))
      (constgen/loadable-entry cpb loadable-value)))
  (datafy [_]
    (letfn [(value-seq ^seq [^CodeEmitter/1 a]
              (list* (map Loadable/.datafy a)))] ;wrap LazySeq
      (cond
        (seq? loadable-value) (list* loadable-value) ;wrap LazySeq
        
        (instance? CodeEmitter/1 loadable-value)
        (let [a ^CodeEmitter/1 loadable-value]
          (if associate-meta?
            (with-meta (Loadable/.datafy (aget a 0))
              (Loadable/.datafy (aget a 1)))
            (condp identical? opnd-type
              type/vector (vec (value-seq a))
              type/map (apply array-map (value-seq a))
              type/set (set (value-seq a))
              type/list (value-seq a))))
        
        :else loadable-value))))

(def mk-loadable LoadableImpl/new)

(defn loadables? ^boolean [^Insns insns]
  (loop [i (dec (.length insns))]
    (cond (neg? i) true
          (model/loadable? insns i) (recur (dec i))
          :else false)))

;;; ------------------------------------------------------------------------

(deftype ConstantImpl [^Object computational-value ^Class opnd-type]
  java.lang.Record
  Constant
  (emit-insn* [this xb consumed-type _]
    (cond
      (type/same? Void/TYPE consumed-type)
      Void/TYPE
      
      (model/null? computational-value)
      (do (.aconst_null xb)          ;elide any additional checkcast
          (if (.isPrimitive consumed-type)
            (.class-reference (type/of consumed-type))
            consumed-type))
      
      (type/same? opnd-type consumed-type)
      (do (if (instance? ConstantDesc computational-value)
            (.loadConstant xb ^ConstantDesc computational-value)
            (.ldc xb (.loadable-entry this (.constantPool xb) false)))
          consumed-type)
      
      (instance? Number computational-value)
      (if (.isPrimitive consumed-type) ;cannot be void
        (do (->> (type/convert-from-constant consumed-type computational-value)
                 (.loadConstant xb))
            consumed-type)
        (do (.loadConstant xb ^ConstantDesc computational-value)
            opnd-type))
      
      :else
      (do (.ldc xb (.loadable-entry this (.constantPool xb) false))
          opnd-type)))
  (value-type [_]
    opnd-type)
  (loadable-entry [this cpb logical-type?]
    (->> (if logical-type? (.datafy this) computational-value)
         (constgen/loadable-entry cpb)))
  (datafy [_]
    (when-not (model/null? computational-value)
      (if (instance? Integer computational-value)
        (let [x ^int computational-value]
          (condp identical? opnd-type
            Integer/TYPE computational-value
            Boolean/TYPE (object (not= x 0))
            Character/TYPE (object (char x))
            Byte/TYPE (object (byte x))
            Short/TYPE (object (short x))))
        computational-value))))

(def entity-null (ConstantImpl. ConstantDescs/NULL Object))
(def insn-null (insn/mk-insn entity-null type/poly-reference))

(def entity-false (ConstantImpl. 0 Boolean/TYPE))
(def entity-true (ConstantImpl. 1 Boolean/TYPE))
(def insn-false (insn/mk-insn entity-false Boolean/TYPE))
(def insn-true (insn/mk-insn entity-true Boolean/TYPE))
(defn insn-boolean ^Insn [^boolean value] (if value insn-true insn-false))

(defn mk-constant ^ConstantImpl [^Object computational-value ^Class type]
  (cond                   ;enforce singleton for null, false, and true
    (identical? ConstantDescs/NULL computational-value)
    entity-null
    
    (type/same? Boolean/TYPE type)
    (if (zero? ^int computational-value) entity-false entity-true)
    
    :else (ConstantImpl. computational-value type)))

(def entity-int-zero (mk-constant 0 Integer/TYPE))
(def insn-int-zero (insn/mk-insn entity-int-zero Integer/TYPE))
(def insn-int-one (insn/mk-insn (mk-constant 1 Integer/TYPE) Integer/TYPE))
(def insn-int-m1 (insn/mk-insn (mk-constant -1 Integer/TYPE) Integer/TYPE))
(def insn-float-one (insn/mk-insn (mk-constant 1.0f Float/TYPE) Float/TYPE))

(letfn [(ensure-loadable-type ^Class [^Entity ent form]
          (let [tp (.value-type ent)]
            (when (nil? tp)
              (throw (wrong/wr-info (str "entity " (wrong/q form)
                                         " has no runtime value"))))
            tp))]
  (defn value-of ^Insn [^Entity ent ^symbol form]
    (if (identical? entity-null ent)
      insn-null ;an entity of type `poly-reference` loading as Object NULL
      (insn/mk-insn ent (ensure-loadable-type ent form)))))

(defn constant-insn ^Insn [^Object value ^Class type]
  (value-of (mk-constant value type) nil))

;;; ------------------------------------------------------------------------

(defn- dup ^CodeBuilder [^CodeBuilder xb ^Class type]
  (case (.slotSize (TypeKind/from type))
    1 (.dup xb)
    2 (.dup2 xb)))

(defn static-field ^Entity [^ClassDesc owner ^String fnm ^Class type]
  (let [type-cld (reflect/describe-class type)]
    (reify MutableEntity
      (emit-insn* [_ xb _ _]
        (.getstatic xb owner fnm type-cld)
        type)
      (value-type [_]
        type)
      (alias-when-let-value? [_]
        false)
      (emit-store [_ xb]
        (throw (UnsupportedOperationException.)))
      (emit-iinc [_ xb const]
        (throw (UnsupportedOperationException.)))
      (emit-setup-code? [_ xb init]
        (when (emit/insn? xb context/fctx-none type init)
          (.putstatic xb owner fnm type-cld)
          true)))))

(defn static-method ^Entity [^ClassDesc owner ^String mnm ^Class type]
  (let [mtd (MethodTypeDesc/of (reflect/describe-class type))]
    (reify Entity
      (emit-insn* [_ xb _ _]
        (.invokestatic xb owner mnm mtd)
        type)
      (value-type [_]
        type))))

(deftype LocalVariable [^String name ^Class type
                        ^:unsynchronized-mutable ^int slot]
  MutableEntity
  (emit-insn* [_ xb consumed-type _]
    (insn/with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  (value-type [_]
    type)
  (alias-when-let-value? [_]
    true)
  (emit-store [_ xb]
    (.storeLocal xb (TypeKind/from type) slot))
  (emit-iinc [_ xb const]
    (.iinc xb slot const))
  (emit-setup-code? [_ xb init]
    (let [tk (TypeKind/from type), label (.newLabel xb)]
      (when-some [on-stack-type (.emit-insn* init xb type false)]
        (assert (identical? type on-stack-type))
        (set! slot (.allocateLocal xb tk))
        (-> (.storeLocal xb tk slot)
            (.labelBinding label)
            (.localVariable slot name (reflect/describe-class type)
                            label (.endLabel xb)))
        true))))

(defn local-variable ^Entity [^String name ^Class type]
  (LocalVariable. name type -1))

(deftype Parameter [^String name ^Class type ^int param-no
                    ^:unsynchronized-mutable ^int slot]
  MutableEntity
  (emit-insn* [_ xb consumed-type _]
    (insn/with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  (value-type [_]
    type)
  (alias-when-let-value? [_]
    true)
  (emit-store [_ xb]
    (.storeLocal xb (TypeKind/from type) slot))
  (emit-iinc [_ xb const]
    (.iinc xb slot const))
  (emit-setup-code? [_ xb _]
    (set! slot (.parameterSlot xb param-no))
    (.localVariable xb slot name (reflect/describe-class type)
                    (.startLabel xb) (.endLabel xb))
    true))

(defn- parameter ^Entity [^String name ^Class type ^int param-no]
  (Parameter. name type param-no -1))

;;; ------------------------------------------------------------------------

(deftype BindingImpl [^Entity bound-to ^CodeEmitter initialize-with
                      ^String name]
  java.lang.Record
  Binding
  (emit-insn* [this xb consumed-type _]
    ;; skip setup if this binding is an alias, the bound entity is
    ;; immutable, or the entity's value is provided by other means
    (when (or (nil? initialize-with)
              (.emit-setup-code? ^MutableEntity bound-to xb initialize-with))
      Void/TYPE)))

(defn mk-binding ^Binding [^Entity bound-to ^String namespace ^String name
                           ^CodeEmitter initialize-with]
  (BindingImpl. bound-to initialize-with name))

(defn parameter-binding ^Binding [^int param-no ^String name ^Class type]
  (let [ent (parameter name type param-no)]
    (mk-binding ent nil name insn/emitter-empty)))


;; FIXME... get rid of complete-non-value-invocable eventually
(defn complete-non-value-invocable ^Invocable [^Invocable inv]
  (reify Invocable
    (emit-insn* [_ _ _ _]
      (throw (IllegalStateException.)))
    (value-type [_]
      nil)
    (invoke* [_ fctx form xs]
      (.invoke* inv fctx form xs))))

(defn global-binding ^Binding [^Entity bound-to ^String namespace ^String name
                               ^CodeEmitter initialize-with]
  ;; drop `initialize-with` if `bound-to` is static-method
  (mk-binding bound-to namespace name
              (when (instance? MutableEntity bound-to) initialize-with)))
