(ns tcljx.classgen.entity
  (:require
   (tcljx.data [wrong :as wrong] [type :as type] [model :as model]
               [reflect :as reflect])
   (tcljx.classgen [emit :as emit] [insn :as insn] [constgen :as constgen]))
  (:import
   (tcljx.data.model Expr CodeEmitter Binding Entity Loadable Constant)
   (tcljx.classgen.insn Insn Insns)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc ConstantDescs)))

(deftype LoadableImpl [^Object loadable-value ^Class opnd-type
                       ^boolean associate-meta?]
  java.lang.Record
  Loadable
  (emit-insn* [this xb line consumed-type _]
    (when-not (type/same? Void/TYPE consumed-type)
      (.ldc xb (.loadable-entry this (.constantPool xb) false))
      (emit/cast-from-reference xb line consumed-type opnd-type))
    consumed-type)
  (emit-setup-code [this xb line consumed-type _]
    Void/TYPE)
  (loadable-entry [_ cpb logical-type?]
    (if (instance? CodeEmitter/1 loadable-value)
      (if associate-meta?
        (constgen/with-meta-entry cpb opnd-type loadable-value)
        (constgen/collection-entry cpb opnd-type loadable-value))
      (constgen/loadable-entry cpb loadable-value)))
  (datafy [_]
    (letfn [(value-seq ^seq [^CodeEmitter/1 a]
              (list* (map Loadable/.datafy a)))] ;wrap LazySeq
      (cond
        (seq? loadable-value) (list* loadable-value) ;wrap LazySeq
        
        (instance? CodeEmitter/1 loadable-value)
        (let [a ^CodeEmitter/1 loadable-value]
          (if associate-meta?
            (with-meta (Loadable/.datafy (aget a 0))
              (Loadable/.datafy (aget a 1)))
            (condp identical? opnd-type
              type/vector (vec (value-seq a))
              type/map (apply array-map (value-seq a))
              type/set (set (value-seq a))
              type/list (value-seq a))))
        
        :else loadable-value))))

(def mk-loadable LoadableImpl/new)

(defn loadables? ^boolean [^Insns insns]
  (loop [i (dec (.length insns))]
    (cond (neg? i) true
          (model/loadable? insns i) (recur (dec i))
          :else false)))

;;; ------------------------------------------------------------------------

(deftype ConstantImpl [^Object computational-value ^Class type]
  java.lang.Record
  Constant
  (emit-insn* [this xb line consumed-type _]
    (when-not (type/same? Void/TYPE consumed-type)
      (cond
        (model/null? computational-value)
        (.aconst_null xb)              ;elide any additional checkcast
        
        (type/same? type consumed-type)
        (if (instance? ConstantDesc computational-value)
          (.loadConstant xb ^ConstantDesc computational-value)
          (.ldc xb (.loadable-entry this (.constantPool xb) false)))
        
        (instance? Number computational-value)
        (if (.isPrimitive consumed-type) ;cannot be void
          (->> (type/convert-from-constant consumed-type computational-value)
               (.loadConstant xb))
          (-> (.loadConstant xb ^ConstantDesc computational-value)
              (emit/convert-from-primitive consumed-type type)))
        
        :else
        (do (.ldc xb (.loadable-entry this (.constantPool xb) false))
            (emit/cast-from-reference xb line consumed-type type))))
    consumed-type)
  (emit-setup-code [this xb line consumed-type _]
    Void/TYPE)
  (loadable-entry [this cpb logical-type?]
    (->> (if logical-type? (.datafy this) computational-value)
         (constgen/loadable-entry cpb)))
  (datafy [_]
    (when-not (model/null? computational-value)
      (if (instance? Integer computational-value)
        (let [x ^int computational-value]
          (condp identical? type
            Integer/TYPE computational-value
            Boolean/TYPE (object (not= x 0))
            Character/TYPE (object (char x))
            Byte/TYPE (object (byte x))
            Short/TYPE (object (short x))))
        computational-value))))

(defn mk-constant ^ConstantImpl [^Object computational-value ^Class type]
  (assert (or (instance? java.lang.constant.ConstantDesc computational-value)
              (instance? Class computational-value)))
  (ConstantImpl/new computational-value type))

(def insn-null (insn/mk-insn (mk-constant ConstantDescs/NULL Object)
                              type/poly-reference))

(def emitter-false (mk-constant 0 Boolean/TYPE))
(def emitter-true (mk-constant 1 Boolean/TYPE))
(def insn-false (insn/mk-insn emitter-false Boolean/TYPE))
(def insn-true (insn/mk-insn emitter-true Boolean/TYPE))
(defn insn-boolean ^Insn [^boolean value] (if value insn-true insn-false))

(def emitter-int-zero (mk-constant 0 Integer/TYPE))
(def insn-int-zero (insn/mk-insn emitter-int-zero Integer/TYPE))
(def insn-int-one (insn/mk-insn (mk-constant 1 Integer/TYPE) Integer/TYPE))
(def insn-int-m1 (insn/mk-insn (mk-constant -1 Integer/TYPE) Integer/TYPE))
(def insn-float-one (insn/mk-insn (mk-constant 1.0f Float/TYPE) Float/TYPE))

(defn new-constant ^Insn [^Object value ^Class expr-type]
  #_(prn :new-constant expr-type value)
  (java.util.Objects/requireNonNull expr-type)
  (java.util.Objects/requireNonNull value)
  (cond
    (identical? ConstantDescs/NULL value)
    insn-null                          ;enforce singleton
    
    (type/same? Boolean/TYPE expr-type)
    (insn-boolean (not (zero? ^int value))) ;enforce singletons
    
    :else (insn/mk-insn (mk-constant value expr-type) expr-type)))

;;; ------------------------------------------------------------------------

(defn- dup ^CodeBuilder [^CodeBuilder xb ^Class type]
  (case (.slotSize (TypeKind/from type))
    1 (.dup xb)
    2 (.dup2 xb)))

(defn static-field ^Entity [^ClassDesc owner ^String fnm ^Class type]
  (let [type-cld (reflect/describe-class type)]
    (reify Entity
      (emit-insn* [_ xb _ _ _]
        (.getstatic xb owner fnm type-cld)
        type)
      (emit-setup-code [_ xb line consumed-type init]
        (when (emit/insn? xb line type init)
          (if (identical? Void/TYPE consumed-type)
            (do (.putstatic xb owner fnm type-cld) Void/TYPE)
            (do (-> xb (dup type) (.putstatic owner fnm type-cld)) type)))))))

(defn static-method ^Entity [^ClassDesc owner ^String mnm ^Class type]
  (let [mtd (MethodTypeDesc/of (reflect/describe-class type))]
    (reify Entity
      (emit-insn* [_ xb _ _ _]
        (.invokestatic xb owner mnm mtd)
        type)
      (emit-setup-code [_ xb line consumed-type init]
        Void/TYPE))))

(deftype LocalVariable [^String name ^Class type
                        ^:unsynchronized-mutable ^int slot]
  Entity
  (emit-insn* [_ xb line consumed-type _]
    (insn/with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  (emit-setup-code [_ xb line consumed-type init]
    (let [tk (TypeKind/from type), label (.newLabel xb)]
      (when (emit/insn? xb line type init)
        (set! slot (.allocateLocal xb tk))
        (-> (.storeLocal xb tk slot)
            (.labelBinding label)
            (.localVariable slot name (reflect/describe-class type)
                            label (.endLabel xb)))
        Void/TYPE))))

(defn local-variable ^Entity [^String name ^Class type]
  (LocalVariable. name type -1))

(deftype Parameter [^String name ^Class type ^int param-no
                    ^:unsynchronized-mutable ^int slot]
  Entity
  (emit-insn* [_ xb line consumed-type _]
    (insn/with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  (emit-setup-code [_ xb line consumed-type _]
    (set! slot (.parameterSlot xb param-no))
    (.localVariable xb slot name (reflect/describe-class type)
                    (.startLabel xb) (.endLabel xb))
    Void/TYPE))

(defn parameter ^Entity [^String name ^Class type ^int param-no]
  (Parameter. name type param-no -1))

;;; ------------------------------------------------------------------------

(deftype BindingImpl [^Entity bound-to ^Expr bound-value
                      ^String namespace ^String name
                      ^CodeEmitter initialize-with]
  java.lang.Record
  Binding
  (emit-insn* [this xb line consumed-type _]
    (if initialize-with
      ;; skip setup if this binding is an alias, the bound entity is a
      ;; constant, or the entity's value is provided by other means
      (.emit-setup-code bound-to xb line consumed-type initialize-with)
      Void/TYPE)))

(defn- mk-binding ^Binding [^Entity bound-to ^Insn bound-value
                            ^String namespace ^String name
                            ^CodeEmitter initialize-with]
  (BindingImpl. bound-to bound-value namespace name initialize-with))

(defn parameter-binding ^Binding [^int param-no ^String name ^Class type]
  (let [ent (parameter name type param-no)]
    (mk-binding ent (insn/mk-insn ent type) nil name insn/emitter-empty)))

(defn local-binding ^Binding [^Class opt-type ^String name init-or-bnd]
  (letfn [(non-alias-local ^Binding [^Insn init]
            (let [ce (insn/emitter init)
                  tp (or opt-type (insn/logical-type init))]
              (if (and (model/ce-const? ce) (nil? opt-type))
                (mk-binding ce init nil name nil)
                (let [ent (local-variable name tp)]
                  (mk-binding ent (insn/mk-insn ent tp) nil name
                              (.emitter init))))))]
    (if (instance? Insn init-or-bnd)
      (non-alias-local init-or-bnd)
      (let [bnd ^Binding init-or-bnd]
        (mk-binding (.bound-to bnd) (.bound-value bnd) nil name nil)))))

(defn global-binding
  (^Binding [^Entity bound-to ^String namespace ^String name]
   (mk-binding bound-to nil namespace name nil)) ;for predefined entities
  (^Binding [^Entity bound-to ^Insn bound-value ^String namespace ^String name
             ^CodeEmitter initialize-with]
   (mk-binding bound-to bound-value namespace name initialize-with)))
