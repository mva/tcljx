(ns tcljx.classgen.entity
  (:require
   (tcljx.data [wrong :as wrong] [type :as type] [context :as context]
               [model :as model] [reflect :as reflect])
   (tcljx.classgen [emit :as emit] [constgen :as constgen]))
  (:import
   (tcljx.data.model Expr CodeEmitter Binding Entity MutableEntity
                     Loadable Constant Invocable)
   (java.lang.classfile CodeBuilder TypeKind)
   (java.lang.constant ConstantDesc ClassDesc MethodTypeDesc ConstantDescs)))

;;; FIXME... drop this after all old unit tests have been ported over;
;;; interesting experiment to see if it works, but probably of little
;;; or even no practical value.
(defmacro with-void-empty-if-requested [consumed-type & body]
  (assert (symbol? consumed-type))
  `(if (identical? Void/TYPE ~consumed-type)
     Void/TYPE
     (do ~@body)))

(deftype LoadableImpl [^Object loadable-value ^Class opnd-type
                       ^boolean associate-meta?]
  java.lang.Record
  Loadable
  (emit-insn* [this xb consumed-type _]
    (if (type/same? Void/TYPE consumed-type)
      Void/TYPE
      (do (.ldc xb (.loadable-entry this (.constantPool xb) false))
          opnd-type)))
  (value-type [_]
    opnd-type)
  (loadable-entry [_ cpb logical-type?]
    (if (instance? CodeEmitter/1 loadable-value)
      (if associate-meta?
        (constgen/with-meta-entry cpb opnd-type loadable-value)
        (constgen/collection-entry cpb opnd-type loadable-value))
      (constgen/loadable-entry cpb loadable-value)))
  (datafy [_]
    (letfn [(value-seq ^seq [^CodeEmitter/1 a]
              (list* (map Loadable/.datafy a)))] ;wrap LazySeq
      (cond
        (seq? loadable-value) (list* loadable-value) ;wrap LazySeq
        
        (instance? CodeEmitter/1 loadable-value)
        (let [a ^CodeEmitter/1 loadable-value]
          (if associate-meta?
            (with-meta (Loadable/.datafy (aget a 0))
              (Loadable/.datafy (aget a 1)))
            (condp identical? opnd-type
              type/vector (vec (value-seq a))
              type/map (apply array-map (value-seq a))
              type/set (set (value-seq a))
              type/list (value-seq a))))
        
        :else loadable-value))))

(def mk-loadable LoadableImpl/new)

;;; ------------------------------------------------------------------------

(defn null? ^boolean [^Object value]
  (identical? ConstantDescs/NULL value))
(defn zero? ^boolean [^Object value]
  (and (instance? Number value) (= (.doubleValue ^Number value) 0.0)))

(deftype ConstantImpl [^Object computational-value ^Class opnd-type]
  java.lang.Record
  Constant
  (emit-insn* [this xb consumed-type _]
    (cond
      (type/same? Void/TYPE consumed-type)
      Void/TYPE
      
      (null? computational-value)
      (do (.aconst_null xb)            ;elide any additional checkcast
          (if (.isPrimitive consumed-type)
            (.class-reference (type/of consumed-type))
            consumed-type))
      
      (type/same? opnd-type consumed-type)
      (do (if (instance? ConstantDesc computational-value)
            (.loadConstant xb ^ConstantDesc computational-value)
            (.ldc xb (.loadable-entry this (.constantPool xb) false)))
          consumed-type)
      
      (instance? Number computational-value)
      (if (.isPrimitive consumed-type)  ;cannot be void
        (do (->> (type/convert-from-constant consumed-type computational-value)
                 (.loadConstant xb))
            consumed-type)
        (do (.loadConstant xb ^ConstantDesc computational-value)
            opnd-type))
      
      :else
      (do (.ldc xb (.loadable-entry this (.constantPool xb) false))
          opnd-type)))
  (value-type [_]
    opnd-type)
  (loadable-entry [this cpb logical-type?]
    (->> (if logical-type? (.datafy this) computational-value)
         (constgen/loadable-entry cpb)))
  (datafy [_]
    (when-not (null? computational-value)
      (if (instance? Integer computational-value)
        (let [x ^int computational-value]
          (condp identical? opnd-type
            Integer/TYPE computational-value
            Boolean/TYPE (object (not= x 0))
            Character/TYPE (object (char x))
            Byte/TYPE (object (byte x))
            Short/TYPE (object (short x))))
        computational-value))))

(defn const? ^boolean [^CodeEmitter ce]
  (instance? ConstantImpl ce))
(defn const-value ^Object [^CodeEmitter ce]
  (when (const? ce)
    (ConstantImpl/.computational-value ce)))

(def emitter-empty (^CodeEmitter fn [xb _ _] Void/TYPE))
(def entity-null (ConstantImpl. ConstantDescs/NULL type/poly-reference))
(defn entity-null? ^boolean [^CodeEmitter ce]
  (identical? entity-null ce))

(def entity-false (ConstantImpl. 0 Boolean/TYPE))
(def entity-true (ConstantImpl. 1 Boolean/TYPE))

(defn mk-constant ^ConstantImpl [^Object computational-value ^Class type]
  (cond                   ;enforce singleton for null, false, and true
    (identical? ConstantDescs/NULL computational-value)
    entity-null
    
    (type/same? Boolean/TYPE type)
    (if (tinyclj.core/zero? ^int computational-value) entity-false entity-true)
    
    :else (ConstantImpl. computational-value type)))

(def entity-int-zero (mk-constant 0 Integer/TYPE))
(defn entity-zero? ^boolean [^CodeEmitter ce]
  (and (const? ce) (zero? (const-value ce))))

;;; ------------------------------------------------------------------------

;;; This interface is used to denote Entity instances whose owning
;;; class cannot be provided at the time the entity is created.  Such
;;; an entity's owner must be set before class generation calls the
;;; entity's `emit-insn*` method.
(definterface SegmentProvidesOwner
  (set-owner! [^ClassDesc owner]))

(defn- dup ^CodeBuilder [^CodeBuilder xb ^Class type]
  (case (.slotSize (TypeKind/from type))
    1 (.dup xb)
    2 (.dup2 xb)))

(deftype StaticField [^String fnm ^Class type ^ClassDesc type-cld
                      ^:unsynchronized-mutable ^ClassDesc __owner]
  SegmentProvidesOwner
  (set-owner! [_ owner]
    (set! __owner owner))
  MutableEntity
  (emit-insn* [_ xb _ _]
    (.getstatic xb __owner fnm type-cld)
    type)
  (value-type [_]
    type)
  (alias-when-let-value? [_]
    false)
  (emit-store [_ xb]
    (throw (UnsupportedOperationException.)))
  (emit-iinc [_ xb const]
    (throw (UnsupportedOperationException.)))
  (emit-setup-code? [_ xb init]
    (when (emit/insn? xb context/fctx-none type init)
      (.putstatic xb __owner fnm type-cld)
      true)))

(defn static-field
  (^StaticField [^String fnm ^Class type]
   (static-field nil fnm type))
  (^StaticField [^ClassDesc owner ^String fnm ^Class type]
   (StaticField. fnm type (reflect/describe-class type) owner)))

(deftype StaticMethod [^String mnm ^Class type ^MethodTypeDesc mtd
                       ^:unsynchronized-mutable ^ClassDesc __owner]
  SegmentProvidesOwner
  (set-owner! [_ owner]
    (set! __owner owner))
  Entity
  (emit-insn* [_ xb _ _]
    (.invokestatic xb __owner mnm mtd)
    type)
  (value-type [_]
    type))

(defn static-method ^StaticMethod [^String mnm ^Class type]
  (StaticMethod. mnm type (MethodTypeDesc/of (reflect/describe-class type)) nil))

(deftype LocalVariable [^String name ^Class type
                        ^:unsynchronized-mutable ^int slot]
  MutableEntity
  (emit-insn* [_ xb consumed-type _]
    (with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  (value-type [_]
    type)
  (alias-when-let-value? [_]
    true)
  (emit-store [_ xb]
    (.storeLocal xb (TypeKind/from type) slot))
  (emit-iinc [_ xb const]
    (.iinc xb slot const))
  (emit-setup-code? [_ xb init]
    (let [tk (TypeKind/from type), label (.newLabel xb)]
      (when-some [on-stack-type (.emit-insn* init xb type false)]
        (assert (identical? type on-stack-type))
        (set! slot (.allocateLocal xb tk))
        (-> (.storeLocal xb tk slot)
            (.labelBinding label)
            (.localVariable slot name (reflect/describe-class type)
                            label (.endLabel xb)))
        true))))

(defn local-variable ^Entity [^String name ^Class type]
  (LocalVariable. name type -1))

(deftype Parameter [^String name ^Class type ^int param-no
                    ^:unsynchronized-mutable ^int slot]
  MutableEntity
  (emit-insn* [_ xb consumed-type _]
    (with-void-empty-if-requested consumed-type
      (.loadLocal xb (TypeKind/from type) slot)
      type))
  (value-type [_]
    type)
  (alias-when-let-value? [_]
    true)
  (emit-store [_ xb]
    (.storeLocal xb (TypeKind/from type) slot))
  (emit-iinc [_ xb const]
    (.iinc xb slot const))
  (emit-setup-code? [_ xb _]
    (set! slot (.parameterSlot xb param-no))
    (.localVariable xb slot name (reflect/describe-class type)
                    (.startLabel xb) (.endLabel xb))
    true))

(defn- parameter ^Entity [^String name ^Class type ^int param-no]
  (Parameter. name type param-no -1))

;;; ------------------------------------------------------------------------

(deftype BindingImpl [^Entity bound-to ^CodeEmitter initialize-with
                      ^String name]
  java.lang.Record
  Binding
  (emit-insn* [this xb consumed-type _]
    ;; skip setup if this binding is an alias, the bound entity is
    ;; immutable, or the entity's value is provided by other means
    (when (or (nil? initialize-with)
              (.emit-setup-code? ^MutableEntity bound-to xb initialize-with))
      Void/TYPE)))

(defn mk-binding ^Binding [^Entity bound-to ^String name
                           ^CodeEmitter initialize-with]
  (BindingImpl. bound-to initialize-with name))

(defn parameter-binding ^Binding [^int param-no ^String name ^Class type]
  (let [ent (parameter name type param-no)]
    (mk-binding ent name emitter-empty)))


;; FIXME... get rid of complete-non-value-invocable eventually
(defn complete-non-value-invocable ^Invocable [^Invocable inv]
  (reify Invocable
    (emit-insn* [_ _ _ _]
      (throw (IllegalStateException.)))
    (value-type [_]
      nil)
    (invoke* [_ fctx form xs]
      (.invoke* inv fctx form xs))))

(defn global-binding ^Binding [^Entity bound-to ^String name
                               ^CodeEmitter initialize-with]
  ;; drop `initialize-with` if `bound-to` is static-method
  (mk-binding bound-to name
              (when (instance? MutableEntity bound-to) initialize-with)))
