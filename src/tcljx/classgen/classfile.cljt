(ns tcljx.classgen.classfile
  (:import
   (java.lang.classfile ClassFile #_Opcode #_TypeKind ClassBuilder #_MethodBuilder
                        CodeBuilder #_Label)
   #_(java.lang.classfile.instruction SwitchCase)
   (java.lang.constant #_ConstantDesc ClassDesc #_MethodTypeDesc #_MethodHandleDesc
                       #_DirectMethodHandleDesc #_DirectMethodHandleDesc$Kind
                       #_ConstantDescs)
   #_(java.lang.invoke MethodHandle TypeDescriptor$OfField MethodHandles$Lookup)
   (java.util.function Consumer #_Function)))

(def acc-method-virtual (bit-or ClassFile/ACC_PUBLIC ClassFile/ACC_FINAL))
(def acc-method-static (bit-or acc-method-virtual ClassFile/ACC_STATIC))

(definterface ClassElementEmitter
  (emit-class-element ^void [^ClassBuilder cb]))
(defn class-element-emitter? ^boolean [x]
  (instance? ClassElementEmitter x))
(defn emit-class-element ^CodeBuilder [^ClassBuilder cb ^ClassElementEmitter cee]
  (.emit-class-element cee cb))

(defmacro accept->
  ([builder handler]
   (if (symbol? builder)
     (list 'do (list '.accept handler builder) builder)
     `(let [builder# ~builder] (.accept ~handler builder#) builder#)))
  ([builder handler arg]
   (if  (symbol? builder)
     (list 'do (list '.accept handler builder arg) builder)
     `(let [builder# ~builder] (.accept ~handler builder# ~arg) builder#))))

(defmacro with-method-body-> [cb [method-name lookup-type-desc flags] & body]
  `(.withMethodBody ~cb ~method-name ~lookup-type-desc ~flags
                    (^Consumer fn ^void [^CodeBuilder xb#]
                     (-> xb# ~@body))))
